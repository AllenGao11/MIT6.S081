# Untitled

常见的有三种方式可以来看待锁，通过这三种方式或许可以帮助你认识锁。

* 锁可以帮助避免丢失更新。如果你回想我们之前在kalloc.c中的例子，丢失更新是指我们丢失了对于某个内存page在kfree函数中的更新。但是加上锁之后，我们就不会丢失这里的更新。
* 锁可以让多个操作一起具有原子性。我们之前介绍了加锁解锁之间的区域是critical section，在critical section的所有操作会作为一个原子操作执行。
* 锁帮助维护共享数据结构的不变性。共享数据结构如果不被任何人访问的话是会保持不变的，当某个进程acquire了锁，我们会做一些操作，共享数据的不变性暂时会被破坏，但是在release锁之后，数据的不变性又恢复了。你们可以回想一下之前在kfree函数中的freelist数据，所有的free page都在一个单链表上。但是在kfree函数中，这个特性临时被破坏了，因为有多个指针指向了freelist的head节点。freelist并不太复杂，对于一些更复杂的数据结构可能会更好的帮助你理解锁的作用。

即使是前面介绍的kfree函数这么一个简单的场景，上面的这些锁的特性都有体现。

接下来我们再来看一下锁可能带来的一些缺点。我们已经知道了锁可以被用来解决一些正确性问题，例如避免race condition。但是不恰当的使用锁，可以可能带来一些锁特有的问题。最明显的一个例子就是死锁（Deadlock）。

![](../.gitbook/assets/image%20%28465%29.png)

一个死锁的最简单的场景就是：首先acquire一个锁，然后进入到critical section；在critical section中，再acquire同一个锁；第二个acquire必须要等到第一个acquire状态被release了才能继续执行，但是不继续执行的话又走不到第一个release，所以程序就一直卡在这了。这就是一个死锁。

![](../.gitbook/assets/image%20%28449%29.png)

这是死锁的一个简单的例子，或许并没有那么有趣，XV6会探测这样的死锁，如果XV6看到了同一个进程多次acquire同一个锁，会触发一个panic。

当有多个锁的时候，场景会更加有趣。现在我们有两个CPU，一个是CPU1，另一个是CPU2。CPU1执行rename将文件d1/x移到d2/y，CPU2执行rename将文件d2/a移到d1/b。这里CPU1将文件从d1移到d2，CPU2正好相反将文件从d2移到d1。我们假设我们按照参数的顺序来acquire锁，那么CPU1会先获取d1的锁，如果程序是真正的并行运行，CPU2同时也会获取d2的锁。之后CPU1需要获取d2的锁，这里不能成功，因为CPU2现在持有锁，所以CPU1会停在这个位置等待d2的锁释放。而另一个CPU2，接下来会获取d1的锁，它也不能成功，因为CPU1现在持有锁。这也是死锁的一个例子，有时候这种场景也被称为deadly embrace。这里的死锁就没那么容易探测了。

![](../.gitbook/assets/image%20%28462%29.png)

这里的解决方案是，如果你有多个锁，你需要对锁进行排序，所有的操作都必须以相同的顺序获取锁。

![](../.gitbook/assets/image%20%28469%29.png)

所以对于一个系统设计者，你需要决定对于所有的锁对象的一个全局的顺序。在这里的例子中我们或许想要让d1一直在d2之前，这样我们在rename的时候，总是先获取排序靠前的目录的锁，再获取排序靠后的目录的锁。如果对于所有的锁有了一个全局的排序，这里的死锁就不会出现了。



