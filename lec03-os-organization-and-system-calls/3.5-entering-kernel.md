# 3.5 Entering Kernel

基于硬件的支持，我们可以重新画一下之前的一张图，我们先画一个矩形，ls程序位于这个矩形中；再画一个矩形，echo程序位于这个矩形中。每个矩形都有一个虚拟内存地址，从0开始到2的n次方。

![](../.gitbook/assets/image%20%2817%29.png)

这样，ls程序有了一个内存地址0，echo程序也有了一个内存地址0，如果操作系统将两个程序的内存地址0映射到不同的物理内存地址，那么ls程序不能访问echo程序的内存，同样echo程序也不能访问ls程序的内存。

类似的，内核位于应用程序下方，假设是XV6，那么它也有自己的内存地址空间，并且与应用程序完全独立。我们可以认为user/kernel mode是分隔用户空间和内核空间的边界，用户空间运行的程序运行在user mode，内核空间的程序运行在kernel mode。操作系统位于内核空间。

![](../.gitbook/assets/image%20%288%29.png)

你们应该将这张图记在你们的脑子中。但是基于我们已经介绍的内容，这张图有点太过严格了，因为我们用矩形包括了一个程序的所有部分，这里没有描述如何从一个矩形将控制权转移到另一个矩形的。而很明显这种转换是需要的，例如当ls程序运行的时候，会调用read系统调用，或者是write系统调用，又或者Shell会调用fork或者exec，所以必须要有一种方式使得用户的应用程序能够将控制权以一种协同工作的方式转移到内核，这样内核才能提供服务。

![](../.gitbook/assets/image%20%2861%29.png)

所以，需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。

在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，所以在一个用户程序。



