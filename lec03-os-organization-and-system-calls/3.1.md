# 3.1 上一节课回顾

这节课的内容是操作系统的组织结构。今天我们主要讨论4个话题：

* Isolation，隔离性。这是操作系统组织结构的设计驱动力。
* Kernel和User mode。这是一种隔离操作系统内核和用户应用程序的方法。
* System calls，系统调用。这是你的应用程序能够转换到内核执行的基本方法，这样你的应用程序才能使用内核服务。
* 最后我们会看到所有的这些是如何以一种简单的方式在XV6中实现的。

![](../.gitbook/assets/image%20%285%29.png)

这些是今天的主要内容。

首先我们来复习一下第一课。学习完第一课之后，你应该对操作系统的结构有个大致的认知。首先，会有类似于Shell，echo，find或者任何你实现了的工具程序，这些程序运行在操作系统之上，而操作系统又抽象了一些硬件资源，例如磁盘，CPU。通常来说操作系统和应用程序之前的接口被称为系统调用接口（System call interface），我们这门课程看到的接口类型是Unix接口。基于这些Unix接口，你们完成了lab1。你们通过系统调用接口或者说Unix API来实际完成了不同的应用程序。

![](../.gitbook/assets/image%20%2851%29.png)

lab1主要集中在理解上图中的应用程序到操作系统内核之间的接口。

![](../.gitbook/assets/image%20%2858%29.png)

而我们这节课以及后面的许多课，我们会实际查看，在操作系统内核，接口是如何实现的。

![](../.gitbook/assets/image%20%2847%29.png)

实际上，在这个学期，我们都会花时间来理解如何实现操作系统接口（也就是系统调用），所以这是第一节有关这些内容的课。你们通过邮件和网站提出了很多非常棒的问题，我们现在还不能立即开始很多细节的讨论，毕竟这是第一节讨论实现的课程，而讨论这些细节需要仔细检查操作系统的内部实现。我们会讨论很多东西，但是很多东西会在后面的课程变得更加清晰，因为我们会在后面的课程进行更加深入的讨论。不管怎样，如果有那个地方不太清楚，请随时打断我并把问题提出来。

在我们进一步讨论之前，让我向你们提一个问题来开始今天的课程。你们在之前的工具程序（也就是lab1的内容）中学到的最有意思的东西是什么？

我会先来回答这个问题。在实现lab1的代码之后，让我感到吃惊的一件事情是，我对于exec的使用频率比我之前更多了。我之前主要用另一种与exec相同功能的方法，但是做完了exec实验之后，我发现使用exec更加的方便。所以，从那以后，我编程了一个更加激进的多的exec的使用者。同时我也好奇，你们的体验是怎么样？我会点几个名字，你们可以来说说你们对于lab1的体验。

> 学生1：对我来说最有趣的事情是pipe，或者说是如何写并发的程序。
>
> Frans教授：很好，你之前在编程中使用过pipe吗？
>
> 学生1：并没有，我之前看过其他的并发工具，但是从来没有看过操作系统级别的pipe。
>
> 学生2：我同意前一个同学的观点，我也认为操作系统的pipe非常有趣。一个具体的例子是，通过特定的pipe，两个进程之间就像彼此关联一样。
>
> Frans教授：是的，可以推测，通过pipe实现Prime实验会比你预想要复杂一些。反正我每次使用pipe都有“惊喜”，需要小心一点才能正确使用。
>
> 学生3：我也认为Prime实验是最有趣的。
>
> Frans教授：这个实验花费了你很长的时间吗？或者其实还好？
>
> 学生3：当我发现我的第一个实现版本不是并发的时候，我花了很多时间去重新实现。所以，当思考并发和非并发的区别时，还是挺有趣的。
>
> 后面还有，但是觉得没意思就不继续了。

我希望你们能喜欢前一个实验，当然我也希望你们能喜欢后面的实验。今天的课程的主要内容从某种程度上来说，有一部分是为了帮助你们继续完成系统调用的实验，如果你们还没有完成的话。再说次，你们可以随时打断我并提出问题。



