# 3.7 kernel的编译运行

接下来我会切换到代码介绍，来看一下XV6是如何工作的。

![](../.gitbook/assets/image%20%2883%29.png)

上面有两个窗口，右边是proc结构体。

首先，我们来看一下代码结构，你们或许已经看过了。代码主要有三个部分组成：

* 第一个是kernel。我们可以ls kernel的内容，里面包含了基本上所有的内核文件。因为XV6是一个宏内核结构，这里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。

![](../.gitbook/assets/image%20%2884%29.png)

* 第二个部分是user。这基本上是运行在user mode的程序。这也是为什么一个目录称为kernel，另一个目录称为user的原因。
* 第三部分叫做mkfs。它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。

接下来，我想简单的介绍一些内核是如何编译的。你们可能看见过编译内核，但是还没有真正的理解，而理解编译过程还是比较重要的。

首先，Makefile会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V 汇编语言；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式。

![](../.gitbook/assets/image%20%2891%29.png)

Makefile会为所有内核文件做相同的操作，比如说pipe.c，会按照同样的套路，先经过gcc编译成pipe.s，再通过汇编解释器生成pipe.o。

![](../.gitbook/assets/image%20%2892%29.png)

之后，系统加载器（Loader）会收集所有的.o文件，将它们链接在一起，并生成内核文件。

![](../.gitbook/assets/image%20%2894%29.png)

这里生成的内核文件就是我们运行的文件。同时，为了你们的方便，Makefile还会创建kernel.asm，这里包含了内核的完整汇编语言，你们可以通过查看它来定位究竟是哪个指令导致了Bug。比如，我接下来查看kernel.asm文件，我们可以看到用汇编指令描述的内核：

![](../.gitbook/assets/image%20%2888%29.png)

这里你们可能已经注意到了，第一个指令位于地址80000000，这里对应的是一个RISC-V指令：auipc指令。有人知道第二列，例如0000a117、83010113、6505，是什么意思吗？有人想来回答这个问题吗？

> 学生回答：这是汇编指令的16进制表现形式对吗？

是的，完全正确。所以这里0000a117就是auipc，这里是二进制编码后的指令。因为每个指令都有一个二进制编码，kernel的asm文件会显示这些二进制编码。当你在运行gdb时，如果你想知道具体在运行什么，你可以看具体的二进制编码是什么，有的时候这还挺方便的。

接下来，让我们不带gdb运行XV6，我会编译一些文件，然后调用QEMU（qemu-system-riscv64指令）。这里本质上是通过C语言来模拟仿真RISC-V处理器。

![](../.gitbook/assets/image%20%28100%29.png)

我们来看传给QEMU的几个参数：

* -kernel：这里传递的是内核文件（kernel目录下的kernel文件），这是将在QEMU中运行的程序。kernel同意所有的程序的起始位置都是80000000。
* -m：这里传递的是RISC-V虚拟机将会使用的内存数量
* -smp：这里传递的是虚拟机可以使用的CPU核数
* -drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img

通过这些参数的设置，使得QEMU表现的就像一个真正的计算机一样。当你想到QEMU时，你不应该认为它是一个C程序，你应该把它想成是下图，一个真正的主板。

![](../.gitbook/assets/image%20%2898%29.png)

图中是一个我办公室中的RISC-V主板，它可以启动一个XV6。当你通过QEMU来运行你的内核时，你应该认为你的内核是运行在这样一个主板之上。主板有一个开关，一个RISC-V处理器，有支持外设的空间，比如说一个接口是连接网线的，一个是PCI-E插槽，主板上还有一些内存芯片，这是一个你会在上面编程的物理硬件，而XV6操作系统管理这样一块主板，你在你的脑海中应该有这么一张图。

对于RISC-V，有完整的文档介绍，比如说下图是一个RISC-V的结构图：

![](../.gitbook/assets/image%20%2899%29.png)

这个图里面有：

* 4个核：US4 Core 1-4
* L2 cache：Banked L2
* 连接DRAM的连接器：DDR Controller
* 各种连接外部设备的方式，比如说UART0，一端连接了键盘，另一端连接了键盘
* 以及连接了时钟的接口：Clock Generation

我们后面会讨论更多的细节，但是这里基本上就是XV6的所有组件，你会修改用来与实际的硬件交互。

实际上，通过QEMU模拟的计算机系统或者说计算机主板，抛开一些细节，与这里由SiFive的计算机主板非常相似。本来想给你们展示一下这块主板的，但是我刚刚说过它在我的办公室，而我已经很久没去过办公室了，或许它已经吃了很多灰了。但是当你们在运行QEMU时，你们需要知道，你们基本上跟在运行硬件是一样的，只是说同样的东西，QEMU在软件中实现了而已。

