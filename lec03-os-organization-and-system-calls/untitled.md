# Untitled

接下来我会切换到代码介绍，来看一下XV6是如何工作的。

![](../.gitbook/assets/image%20%2883%29.png)

上面有两个窗口，右边是proc结构体。

首先，我们来看一下代码结构，你们或许已经看过了。代码主要有三个部分组成：

* 第一个是kernel。我们可以ls kernel的内容，里面包含了基本上所有的内核文件。因为XV6是一个宏内核结构，这里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。

![](../.gitbook/assets/image%20%2884%29.png)

* 第二个部分是user。这基本上是运行在user mode的程序。这也是为什么一个目录称为kernel，另一个目录称为user的原因。
* 第三部分叫做mkfs。它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。

接下来，我想简单的介绍一些内核是如何编译的。你们可能看见过编译内核，但是还没有真正的理解，而理解编译过程还是比较重要的。

首先，Makefile会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V 汇编语言；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式。

![](../.gitbook/assets/image%20%2891%29.png)

Makefile会为所有内核文件做相同的操作，比如说pipe.c，会按照同样的套路，先经过gcc编译成pipe.s，再通过汇编解释器生成pipe.o。

![](../.gitbook/assets/image%20%2892%29.png)

之后，系统加载器（Loader）会收集所有的.o文件，将它们链接在一起，并生成内核文件。

![](../.gitbook/assets/image%20%2894%29.png)

这里生成的内核文件就是我们运行的文件。同时，为了你们的方便，Makefile还会创建kernel.asm，这里包含了内核的完整汇编语言，你们可以通过查看它来定位究竟是哪个指令导致了Bug。比如，我接下来查看kernel.asm文件，我们可以看到用汇编语言描述的内核：

![](../.gitbook/assets/image%20%2888%29.png)



