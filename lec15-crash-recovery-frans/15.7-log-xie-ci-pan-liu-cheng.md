# 15.7 Log写磁盘流程

我之前在bwrite函数中加了一个print语句。这个函数是block cache中实际写磁盘的函数，所以我们将会看到实际写磁盘的记录。在上节课（Lec 14）我将print语句放在了log\_write中，这只能代表文件系统操作的记录，并不能代表实际写磁盘的记录。我们这里会像上节课一样执行echo "hi" &gt; x，并看一下实际的写磁盘过程。

![](../.gitbook/assets/image%20%28661%29.png)

很明显这里的记录要比只在log\_write中记录要长的多。之前的log\_write只有11条记录（注，详见14.5）但是实际上背后有很多个磁盘写操作，让我们来看一下。让我们来分别看一下这里的写磁盘操作：

* 首先是前3行的bwrite 3，4，5。因为block 3是第一个log data block，所以前3行记录了3个写操作。这3个写操作都保存在log中，并且会写入到磁盘中的log部分。
* 第4行的bwrite 2。因为block 2是log的起始位置，也就是log header，所以这条是commit记录。
* 第5，6，7行的bwrite 33，46，32。这里实际就是将前3行的log data写入到实际的block位置，这里实际是install log。
* 第8行的bwrite 2，是清除log（注，也就是将log header中的n设置为0）。到此为止，完成了实际上的写block 33，46，32这一系列的操作。第一部分是记录write操作，第二部分是install log，每一部分后面还跟着一个更新commit记录。

> 学生提问：可以从这里的记录找到一次文件操作的begin\_op和end\_op位置吗？
>
> Frans教授：大概可以知道。我们实际上不知道begin\_op的位置，但是所有的文件系统操作都从begin\_op开始。更新commit记录必然在end\_op中，所以我们可以找到文件系统操作的end\_op位置，之后就是begin\_op。

所以以上就是XV6中文件系统的Log介绍，即使是这么一个简单的logging系统也有一定的复杂度。这里立刻可以想到的一个问题是，通过观察这些记录，这是一个很有效的实现吗？很明显不是的，因为数据被写了两次。如果我写一个大文件，我需要在磁盘中将这个大文件写两次。所以这必然不是一个高性能的实现，为了实现crash safety我们将原本的性能降低了一倍。当你们去读ext3论文时，你们应该时刻思考如何避免这里的性能降低一倍。

> 学生提问：这里是不是将字符h和字符i分别写入的？
>
> Frans教授：是的，稍后我会介绍为什么会这样。

前面说到XV6有一定的复杂性，接下来我将介绍一下三个复杂的地方或者也可以认为是三个挑战。

第一个是eviction。假设transaction还在进行中，我们刚刚更新了block 45，正要更新下一个block，而整个buffer cache都满了并且决定撤回block 45。撤回block 45意味着我们需要将其写入到磁盘的block 45位置，这里会不会有问题？如果我们这么做了的话，会破坏什么规则吗？是的，如果将block 45写入到磁盘之后发生了crash，就会破坏transaction的原子性。这里也破坏了前面说过的write ahead rule，write ahead rule的含义是，你需要先将所有的block写入到log中，之后才能实际的更新文件系统block。所以buffer cache不能撤回任何还位于log的block。

前面在介绍log\_write函数时，其中调用了一个叫做bpin的函数，这个函数的作用就如它的名字一样，将block固定在cache中。它是通过给block cache增加引用计数来实现cache不撤回对应的block。在之前（注，详见14.6）我们看过，如果引用计数不为0，那么buffer cache是不会撤回对于block的cache的。相应的在将来的某个时间，所有的数据都写入到了log中，我们可以在cache中unpin block。所以这是第一个复杂的地方，我们需要pin/unpin buffer  cache中的block。

![](../.gitbook/assets/image%20%28658%29.png)

第二个挑战是，文件系统操作必须适配log的大小。在XV6中，总共有30个log block（注，详见14.3）。当然我们可以提升log的尺寸，在真实的文件系统中会有大得多的log。但是无所谓啦，不管log多大，文件系统操作必须能放在log空间中。如果一个文件系统操作尝试写入超过30个block，那么意味着部分内容需要直接写到文件系统区域，而这时不被允许的因为这违背了write ahead rule。所以所有的文件系统操作都必须适配log的大小。

为什么XV6的log大小是30？因为30比任何一个文件系统操作涉及的写操作数都大，Robert和我看了一下所有的文件系统操作，发现都远小于30，所以就将XV6的log大小设为为30。我们目前看过的一些文件系统操作，例如创建一个文件只包含了写5个block。实际上大部分文件系统操作只会写几个block。你们可以想到一个文件系统操作会写很多很多个block吗？是的，写一个大文件。如果我们调用write系统调用并传入1M字节的数据，这对应了写1000个block，看起来会有很严重的问题，因为这破坏了我们刚刚说的：文件系统操作必须适配log的大小，这条规则。

让我们看一下file.c文件中的file\_write函数。

![](../.gitbook/assets/image%20%28663%29.png)

如果写入的block数超过了30，那么一个写操作会被分割成多个小一些的写操作。这里整个写操作不是原子的，但是这还好啦，因为write系统调用的语义并不要求所有1000个block都是原子的写入，它只要求我们不要损坏文件系统。所以XV6会将一个大的写操作分割成多个小的写操作，每一个小的写操作通过独立的transaction写入。这样文件系统本身不会陷入不正确的状态中。

这里还需要注意，因为block在落盘之前需要在cache中pin住，所以buffer cache的尺寸也要大于log的尺寸。

![](../.gitbook/assets/image%20%28657%29.png)

最后一个要讨论的挑战是并发文件系统调用。让我先来解释一下这里会有什么问题，再看对应的解决方案。假设我们有一段log，和两个并发的执行的transaction，其中transaction t0在log的前半段记录，transaction t1在log的后半段记录。当我们用完了log空间之后，任何一个transaction可能都还没完成。

![](../.gitbook/assets/image%20%28660%29.png)

现在我们能提交任何一个transaction吗？我们不能，因为这样的话我们就提交了一个部分完成的transaction，违背了write ahead rule，log本身也没有起到应该的作用。所以必须要保证多个并发transaction都适配log的大小。所以这是一个挑战，当我们还没有完成一个文件系统操作时，我们必须确保可能写入的总的log数小于log区域的大小的前提下，才允许另一个文件系统操作开始。

XV6通过限制并发文件系统操作的个数来实现这一点。在begin\_op中，我们会检查当前有多少个文件系统操作正在进行。如果有太多正在进行的文件系统操作，我们会通过sleep停止当前文件系统操作的运行，并等待所有其他的文件系统操作都执行完并commit之后再唤醒。这里的其他所有文件系统操作都会一起commit。有的时候这被称为group commit，因为这里将多个操作像一个单个的大的transaction一样提交了，这里的多个操作要么全部发生了，要么全部没有发生。

![](../.gitbook/assets/image%20%28655%29.png)

> 学生提问：group commit有必要吗？不能当一个文件系统操作结束的时候就commit掉，然后再commit其他的操作吗？
>
> Frans教授：如果这样的话你需要非常非常小心。因为有一点我没有说得很清楚，我们需要保证write系统调用的顺序。如果一个read看到了一个write，再执行了一次write，那么第二个write必须要发生在第一个write之后。在log中，本身就反应了write系统调用的顺序，你不能改变log中write系统调用的顺序，因为这可能会导致奇怪的行为，并且对用户程序是可见的。所以必须以transaction发生的顺序commit它们，而一次性提交所有的操作总是比较安全的，这可以保证文件系统处于一个好的状态。

