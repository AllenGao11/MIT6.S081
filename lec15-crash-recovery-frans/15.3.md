# 15.3

我们这节课要讨论的针对文件系统crash之后的问题的解决方案，其实就是logging。如我之前所说，这是文件系统中一个通用的解决方案，并且它来源于数据库。它有一些好的属性：

* 首先，它可以确保文件系统的系统调用是原子性的。比如你调用create/write系统调用，这些系统调用的效果是要么完全出现，要么完全不出现，这样就避免了一个系统调用只有部分写磁盘操作出现在磁盘上。
* 其次，它支持快速恢复（Fast Recovery）。在重启之后，我们不需要做大量的工作来修复文件系统，只需要非常小的工作量。这里的快速是相比另一个解决方案来说，在另一个解决方案中，你可能需要读取文件系统的所有block，读取inode，bitmap block，并检查文件系统是否还在一个正确的状态，再来修复。而logging可以有快速恢复的属性。
* 最后，原则上来说，它可以非常的高效，尽管我们在XV6中看到的实现不是很高效。

我们会在下节课看一下，如何构建一个logging系统，并同时具有原子性的系统调用，快速恢复和高性能，而今天，我们只会关注前两点。

![](../.gitbook/assets/image%20%28629%29.png)

logging的基本思想还是很直观的。首先，你将磁盘分割成两个部分，其中一个部分是log，另一个部分是文件系统，文件系统可能会比log大得多。当需要更新文件系统时，我们并不是更新文件系统本身。假设我们在内存中缓存了bitmap block，也就是block 45。当需要更新bitmap时，我们并不是直接写block 45，而是将数据写入到log中，并记录这个更新应该写入到block 45。对于所有的写 block都会有相同的操作，例如更新inode，也会记录一条写block 33的log。

![](../.gitbook/assets/image%20%28633%29.png)

所以基本上，任何一次写操作都是先log。我们并不是直接写入到block的位置，而总是先将写操作写入到log中。

之后在某个时间，当文件系统的操作结束了，比如说我们前一节看到的4-5个写block操作都结束，并且都存在于log中，我们会提交文件系统的操作。这意味着我们需要在log的某个位置属于同一个文件系统的操作的个数，例如5。当我们在log中存储了所有写block的内容时，如果我们要真正执行这些操作，只需要将block从log分区移到文件系统分区。我们知道第一个操作该写入到block 45，我们会直接将数据写到block45，第二个操作该写入到block 33，我们会将它写入到block 33，依次类推。

一旦完成了，就可以清除log。清除log实际上就是将属于同一个文件系统的操作的个数设置为0。

![](../.gitbook/assets/image%20%28639%29.png)

以上就是log的基本工作方式。为什么这样的工作方式是好的呢？让我们这样想，假设我们crash并重启了。在重启的时候，文件系统会查看commit记录的值，如果是0的话，那么什么也不做。如果大于0的话，我们就知道在log中存在block需要被安装。很明显我们并没有完成

