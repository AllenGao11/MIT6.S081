# 15.3

我们这节课要讨论的针对文件系统crash之后的问题的解决方案就是logging。如我之前所说，这是文件系统中一个通用的解决方案，并且它来自于数据库。它有一些好的属性：

* 首先，它可以确保文件系统的系统调用是原子性的。比如你调用create/write系统调用，这些系统调用的效果是要么完全出现，要么完全不出现，这样就避免了一个系统调用只有部分写磁盘操作出现在磁盘上。
* 其次，它支持快速恢复（Fast Recovery）。在重启之后，我们不需要做大量的工作来修复文件系统，只需要非常小的工作量。这里的快速是相比另一个解决方案来说，在另一个解决方案中，你可能需要读取文件系统的所有block，读取inode，bitmap block，并检查文件系统是否还在一个正确的状态，再来修复。而logging可以有快速恢复的属性。
* 最后，原则上来说，它可以非常的高效，尽管我们在XV6中看到的实现不是很高效。

我们会在下节课看一下，如何构建一个logging系统，并同时具有原子性的系统调用，快速恢复和高性能，而今天，我们只会关注前两点。

![](../.gitbook/assets/image%20%28629%29.png)

logging的基本思想还是很直观的。首先，你将磁盘分割成两个部分，其中一个部分是log，另一个部分是文件系统，文件系统可能会比log大得多。当需要更新文件系统时，我们并不是更新文件系统本身。假设我们在内存中缓存了bitmap block，也就是block 45。当需要更新bitmap时，我们并不是直接写block 45，而是将数据写入到log中，并记录这个更新应该写入到block 45。对于所有的写 block都会有相同的操作，例如更新inode，也会记录一条写block 33的log。

![](../.gitbook/assets/image%20%28633%29.png)

所以基本上，任何一次写操作都是先log。我们并不是直接写入到block的位置，而总是先将写操作写入到log中。

之后在某个时间，当文件系统的操作结束了，比如说我们前一节看到的4-5个写block操作都结束，并且存在于log中，我们会提交文件系统的操作。这意味着，在log的某个位置，我们记录了操作的内容，这样我们就知道log中的5个block，这都属于同一个文件系统操作。

当我们在磁盘上存储了所有的写block操作时，我们会真正执行这些操作。这意味着我们将会将log从log分区移到文件系统分区。我们知道第一个操作该写入到block 45，我们会直接写block45，第二个操作该写入到block 33，我们会将它写入到block 33，依次类推。

![](../.gitbook/assets/image%20%28631%29.png)



