# 19.2

今天课程的第一部分我将会讨论如何实现我们自己的虚拟机。这里我将假设我们要模拟的是RISC-V，并运行针对RISC-V设计的操作系统，例如XV6。我们的目的是让运行在Guest中的软件完全不知道自己运行在一个虚拟机内，我们想要让Guest中的软件不可能区分自己是运行在物理机还是在虚拟机中。这里的原因是，我们希望能在虚拟机中运行任何操作系统，甚至是你没有听说过的操作系统，这意味着任何操作系统的行为，使用硬件的方式，虚拟机都必须提供提供对于硬件的完全相同的模拟，这样任何在真实硬件上能工作的代码，也同样能在虚拟机中工作。

除了不希望Guest能够发现自己是否运行在虚拟机中，类似的目标还有，我们也不希望Guest可以从虚拟机中逃逸。很多时候人们使用虚拟机是因为它为不被信任的软件甚至对于不被信任的操作系统，提供了严格的隔离。假设你是Amazon，并且你出售云服务，通常是你的客户提供了运行在虚拟机内的操作系统和应用程序。如果你的客户运行的不是普通的Linux，而是一个特殊的修改过的Linux，并试图突破虚拟机的限制来访问其他用户的虚拟机或者访问Amazon用来实现隔离的VMM。所以Guest不能从虚拟机中逃逸还挺重要的。Guest可以通过VMM使用内存，但是不能使用其他的内存。类似的，Guest也不应该在没有权限的时候访问存储设备或者网卡。所以这里我们会想要非常严格的隔离。虚拟机在很多方面都比普通的Linux进程提供了更加严格的隔离。Linux进程经常可以相互交互，它们可以杀掉别的进程，它们可以读写相同的文件，或者通过pipe进行通信。但是在一个普通的虚拟机中，不允许做这些。运行在同一个计算机上的不同虚拟机，彼此之间是通过VMM完全隔离的。所以人们出于安全性喜欢使用虚拟机，这是一种可以运行未被信任软件的方式，并且也不用担心bug和恶意攻击。

前面已经指出了虚拟机的目标是提供一种对于物理服务器的完全准确的模拟。但是实际中出于性能的考虑，这个目标又不是那么清晰。你将会看到Linux和一些常用的VMM会相互交互，这样在实际中Linux可以发现自己运行在VMM之上。出于效率，在VMM的允许下，Linux某些时候知道自己正在与VMM交互，以获得对于设备的高速访问权限。但是这是一种仔细控制的例外，大致的策略还是完全准确的模拟。

