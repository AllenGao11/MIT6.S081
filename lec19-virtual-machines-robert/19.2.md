# 19.2

今天课程的第一部分我将会讨论如何实现我们自己的虚拟机。这里我将假设我们要模拟的是RISC-V，并运行针对RISC-V设计的操作系统，例如XV6。我们的目的是让运行在Guest中的软件完全不知道自己运行在一个虚拟机内，我们想要让Guest中的软件不可能区分自己是运行在物理机还是在虚拟机中。这里的原因是，我们希望能在虚拟机中运行任何操作系统，甚至是你没有听说过的操作系统，这意味着任何操作系统的行为，使用硬件的方式，虚拟机都必须提供提供对于硬件的完全相同的模拟，这样任何在真实硬件上能工作的代码，也同样能在虚拟机中工作。

除了不希望Guest能够发现自己是否运行在虚拟机中，类似的目标还有，我们也不希望Guest可以从虚拟机中逃逸。很多时候人们使用虚拟机是因为它为不被信任的软件甚至对于不被信任的操作系统，提供了严格的隔离。假设你是Amazon，并且你出售云服务，通常是你的客户提供了运行在虚拟机内的操作系统和应用程序。如果你的客户运行的不是普通的Linux，而是一个特殊的修改过的Linux，并试图突破虚拟机的限制来访问其他用户的虚拟机或者访问Amazon用来实现隔离的VMM。所以Guest不能从虚拟机中逃逸还挺重要的。Guest可以通过VMM使用内存，但是不能使用其他的内存。类似的，Guest也不应该在没有权限的时候访问存储设备或者网卡。所以这里我们会想要非常严格的隔离。虚拟机在很多方面都比普通的Linux进程提供了更加严格的隔离。Linux进程经常可以相互交互，它们可以杀掉别的进程，它们可以读写相同的文件，或者通过pipe进行通信。但是在一个普通的虚拟机中，不允许做这些。运行在同一个计算机上的不同虚拟机，彼此之间是通过VMM完全隔离的。所以人们出于安全性喜欢使用虚拟机，这是一种可以运行未被信任软件的方式，并且也不用担心bug和恶意攻击。

前面已经指出了虚拟机的目标是提供一种对于物理服务器的完全准确的模拟。但是实际中出于性能的考虑，这个目标又不是那么清晰。你将会看到Linux和一些常用的VMM会相互交互，这样在实际中Linux可以发现自己运行在VMM之上。出于效率，在VMM的允许下，Linux某些时候知道自己正在与VMM交互，以获得对于设备的高速访问权限。但是这是一种仔细控制的例外，大致的策略还是完全准确的模拟。

那么我们该如何构建我们自己的VMM呢？一种可能是完全通过软件来实现，你可以想象写一个类似QEMU的软件，读取包含了XV6指令的文件，并查看每一条指令发现这是一条load指令，这是一条move指令，然后你的软件模拟RISC-V的状态，例如通过软件模拟32个寄存器，当你的软件读取每条指令，确定指令类型，再将指令应用到通过软件模拟的32个寄存器和控制寄存器中。人们实际就是这么做的，并且这从概念上来说也很简单直观，或许为了让细节能正确还是需要很多工作。但是纯软件解析的虚拟机应用的并不广泛，因为它们很慢。如果你按照这种方式实现虚拟机，那么Guest应用程序的运行速度将远低于运行在硬件上，因为你的VMM在解析每一条Guest指令时都可能要转换成几十条实际的机器指令，所以Guest的运行速度比一个真实的计算机要慢几个数量级。在云计算中，这种实现方式非常不实用。所以人们并不会通过软件解析来在生产环境构建虚拟机。

相应的，一种广泛使用的主要策略是在真实的CPU上运行Guest指令。所以如果我们要在VMM之上运行XV6，我们需要先将XV6的指令加载到内存中，之后再跳转到XV6的第一条指令，这样你的计算机才能直接运行XV6的指令。当然，这要求你的计算机拥有XV6期望的处理器。

但是你不能直接这么做，因为当你的Guest操作系统执行了一个privileged指令（注，也就是在普通操作系统中只能在kernel mode中执行的指令，详见3.4）之后，就会出现问题。这就是kernel和普通的用户代码的区别，这里我们尝试在虚拟机里面运行kernel，而kernel使用privileged指令，所以你的Guest kernel可能会要加载一个新的page table到RISC-V的SATP寄存器中。这里就出现了一个问题，如果我们将Guest kernel按照一个Linux中的普通用户进程来运行，在user mode加载SATP寄存器是个非法的操作，这会导致我们的程序（注，也就是虚拟机）crash。但是如果我们蠢到将Guest kernel运行在宿主机的Supervisor mode（注，也就是kernel mode），那么我们的Guest kernel不仅能够修改真实的page table，同时也可以从虚拟机中逃逸，因为它现在可以控制PTE（Page Table Entry）的内容，读写任意的内存内容。所以我们不能直接简单的运行Guest kernel。

相应的，这里会使用一些技巧。

首先将Guest kernel运行在宿主机的user mode，这是最基本的策略。这意味着，当我们自己写了一个VMM，然后通过VMM启动XV6，VMM会将XV6的kernel指令加载到内核的某处，或许再设置好合适的page table使得XV6看起来自己的内存是从地址0开始向高地址走。之后VMM会使用trap或者sret指令（注，详见6.8）来跳转到位于user mode的Guest操作系统的第一条指令，这样不论拥有多少条指令，Guest操作系统就可以一直执行下去。

![](../.gitbook/assets/image%20%28728%29.png)

一旦Guest操作系统需要使用privileged指令，因为它当前运行在user mode而不是Supervisor mode，会使得它通过trap走回到我们的VMM中，之后我们就可以获得控制权。所以当Guest操作系统尝试修改SATP寄存器，RISC-V处理器会通过trap走回到我们的VMM中，之后我们的VMM就可以获得控制权。并且我们的VMM也可以查看是什么指令引起的trap，并做恰当的处理。这里核心的点在于Guest操作系统并没有实际的设置SATP寄存器。

![](../.gitbook/assets/image%20%28726%29.png)



> 学生提问：VMM改如何截获Guest操作系统的指令？它应该要设置好一个trap handler对吧，但这不是一个拥有privileged权限的进程才能做的事情吗？而VMM又是个宿主机上的用户程序，是吧？
>
> Robert教授：我这里假设VMM运行在Supervisor mode。所以在这里的图中，VMM就是启动宿主机的kernel。所以这里我们不是启动类似Linux的操作系统，而是启动VMM（注，类似VMware的ESXi）。VMM以privileged权限运行，并拥有硬件的完整控制权限，这样我们就可以在VMM里面设置各种硬件寄存器。有一些VMM就是这么运行的，你在硬件上启动它们，并且只有VMM运行在Supervisor mode。实际上还有很多很多其他的虚拟机方案，在硬件上启动Linux，之后要么Linux自带一个VMM，要么通过可加载的内核模块将VMM加载至Linux内核中，这样VMM可以在Linux内核中以Supervisor mode运行。今天的论文就采用的这种方法。
>
> 这里主要的点在于，我们自己写的，并且是可信赖的VMM运行在Supervisor mode，而我们将Guest kernel运行在User mode，通过一系列的处理使得Guest kernel看起来像是运行在Supervisor mode。

好消息是，在RISC-V上，如果在user mode尝试运行任何一个Supervisor指令都会触发trap。这里的Supervisor指令要排除与page table相关的指令，我们稍后会介绍相关的内容。所以每当Guest操作系统尝试执行类似于读取SCAUSE寄存器，读写STVEC寄存器，都会触发一个trap，并走到VMM，之后我们就可以获得控制权。

