# 19.2

今天课程的第一部分我将会讨论如何实现我们自己的虚拟机。这里我将假设我们要模拟的是RISC-V，并运行针对RISC-V设计的操作系统，例如XV6。我们的目的是让运行在Guest中的软件完全不知道自己运行在一个虚拟机内，我们想要让Guest中的软件不可能区分自己是运行在物理机还是在虚拟机中。这里的原因是，我们希望能在虚拟机中运行任何操作系统，甚至是你没有听说过的操作系统，这意味着任何操作系统的行为，使用硬件的方式，虚拟机都必须提供提供对于硬件的完全相同的模拟，这样任何在真实硬件上能工作的代码，也同样能在虚拟机中工作。

除了不希望Guest能够发现自己是否运行在虚拟机中，类似的目标还有，我们也不希望Guest可以从虚拟机中逃逸。很多时候人们使用虚拟机是因为它为不被信任的软件甚至对于不被信任的操作系统，提供了严格的隔离。假设你是Amazon，并且你出售云服务，通常是你的客户提供了运行在虚拟机内的操作系统和应用程序。如果你的客户运行的不是普通的Linux，而是一个特殊的修改过的Linux，并试图突破虚拟机的限制来访问其他用户的虚拟机或者访问Amazon用来实现隔离的VMM。所以Guest不能从虚拟机中逃逸还挺重要的。Guest可以通过VMM使用内存，但是不能使用其他的内存。类似的，Guest也不应该在没有权限的时候访问存储设备或者网卡。所以这里我们会想要非常严格的隔离。虚拟机在很多方面都比普通的Linux进程提供了更加严格的隔离。Linux进程经常可以相互交互，它们可以杀掉别的进程，它们可以读写相同的文件，或者通过pipe进行通信。但是在一个普通的虚拟机中，不允许做这些。运行在同一个计算机上的不同虚拟机，彼此之间是通过VMM完全隔离的。所以人们出于安全性喜欢使用虚拟机，这是一种可以运行未被信任软件的方式，并且也不用担心bug和恶意攻击。

前面已经指出了虚拟机的目标是提供一种对于物理服务器的完全准确的模拟。但是实际中出于性能的考虑，这个目标又不是那么清晰。你将会看到Linux和一些常用的VMM会相互交互，这样在实际中Linux可以发现自己运行在VMM之上。出于效率，在VMM的允许下，Linux某些时候知道自己正在与VMM交互，以获得对于设备的高速访问权限。但是这是一种仔细控制的例外，大致的策略还是完全准确的模拟。

那么我们该如何构建我们自己的VMM呢？一种可能是完全通过软件来实现，你可以想象写一个类似QEMU的软件，读取包含了XV6指令的文件，并查看每一条指令发现这是一条load指令，这是一条move指令，然后你的软件模拟RISC-V的状态，例如通过软件模拟32个寄存器，当你的软件读取每条指令，确定指令类型，再将指令应用到通过软件模拟的32个寄存器和控制寄存器中。人们实际就是这么做的，并且这从概念上来说也很简单直观，或许为了让细节能正确还是需要很多工作。但是纯软件解析的虚拟机应用的并不广泛，因为它们很慢。如果你按照这种方式实现虚拟机，那么Guest应用程序的运行速度将远低于运行在硬件上，因为你的VMM在解析每一条Guest指令时都可能要转换成几十条实际的机器指令，所以Guest的运行速度比一个真实的计算机要慢几个数量级。在云计算中，这种实现方式非常不实用。所以人们并不会通过软件解析来在生产环境构建虚拟机。

