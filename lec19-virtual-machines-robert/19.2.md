# 19.2

我们该如何构建我们自己的VMM呢？一种实现方式是完全通过软件来实现，你可以想象写一个类似QEMU的软件，这个软件读取包含了XV6内核指令的文件，查看每一条指令并模拟RISC-V的状态，例如通过软件模拟32个寄存器。你的软件读取每条指令，确定指令类型，再将指令应用到通过软件模拟的32个寄存器和控制寄存器中。实际中有的方案就是这么做的，虽然说考虑到细节还需要做很多工作，但是这种方案从概念上来说很简单直观。

但是纯软件解析的虚拟机方案应用的并不广泛，因为它们很慢。如果你按照这种方式实现虚拟机，那么Guest应用程序的运行速度将远低于运行在硬件上，因为你的VMM在解析每一条Guest指令的时候，都可能要转换成几十条实际的机器指令，所以这个方案中的Guest的运行速度比一个真实的计算机要慢几个数量级。在云计算中，这种实现方式非常不实用。所以人们并不会通过软件解析来在生产环境中构建虚拟机。

相应的，一种广泛使用的主要策略是在真实的CPU上运行Guest指令。所以如果我们要在VMM之上运行XV6，我们需要先将XV6的指令加载到内存中，之后再跳转到XV6的第一条指令，这样你的计算机才能直接运行XV6的指令。当然，这要求你的计算机拥有XV6期望的处理器（注，也就是RISC-V）。

但是实际中你又不能直接这么做，因为当你的Guest操作系统执行了一个privileged指令（注，也就是在普通操作系统中只能在kernel mode中执行的指令，详见3.4）之后，就会出现问题。现在我们在虚拟机里面运行了操作系统内核，而内核会执行需要privileged权限指令，比如说加载一个新的page table到RISC-V的SATP寄存器中，而这时就出现问题了。

前面说过，我们将Guest kernel按照一个Linux中的普通用户进程来运行，所以Guest kernel现在运行在User mode，而在User mode加载SATP寄存器是个非法的操作，这会导致我们的程序（注，也就是虚拟机）crash。但是如果我们蠢到将Guest kernel运行在宿主机的Supervisor mode（注，也就是kernel mode），那么我们的Guest kernel不仅能够修改真实的page table，同时也可以从虚拟机中逃逸，因为它现在可以控制PTE（Page Table Entry）的内容，并且读写任意的内存内容。所以我们不能直接简单的在真实的CPU上运行Guest kernel。

相应的，这里会使用一些技巧。

首先将Guest kernel运行在宿主机的User mode，这是最基本的策略。这意味着，当我们自己写了一个VMM，然后通过VMM启动了一个XV6系统，VMM会将XV6的kernel指令加载到内核的某处，或许再设置好合适的page table使得XV6看起来自己的内存是从地址0开始向高地址走。之后VMM会使用trap或者sret指令（注，详见6.8）来跳转到位于user mode的Guest操作系统的第一条指令，这样不论拥有多少条指令，Guest操作系统就可以一直执行下去。

![](../.gitbook/assets/image%20%28728%29.png)

一旦Guest操作系统需要使用privileged指令，因为它当前运行在user mode而不是Supervisor mode，会使得它通过trap走回到我们的VMM中，之后我们就可以获得控制权。所以当Guest操作系统尝试修改SATP寄存器，RISC-V处理器会通过trap走回到我们的VMM中，之后我们的VMM就可以获得控制权。并且我们的VMM也可以查看是什么指令引起的trap，并做恰当的处理。这里核心的点在于Guest操作系统并没有实际的设置SATP寄存器。

![](../.gitbook/assets/image%20%28726%29.png)



> 学生提问：VMM改如何截获Guest操作系统的指令？它应该要设置好一个trap handler对吧，但这不是一个拥有privileged权限的进程才能做的事情吗？而VMM又是个宿主机上的用户程序，是吧？
>
> Robert教授：我这里假设VMM运行在Supervisor mode。所以在这里的图中，VMM就是启动宿主机的kernel。所以这里我们不是启动类似Linux的操作系统，而是启动VMM（注，类似VMware的ESXi）。VMM以privileged权限运行，并拥有硬件的完整控制权限，这样我们就可以在VMM里面设置各种硬件寄存器。有一些VMM就是这么运行的，你在硬件上启动它们，并且只有VMM运行在Supervisor mode。实际上还有很多很多其他的虚拟机方案，在硬件上启动Linux，之后要么Linux自带一个VMM，要么通过可加载的内核模块将VMM加载至Linux内核中，这样VMM可以在Linux内核中以Supervisor mode运行。今天的论文就采用的这种方法。
>
> 这里主要的点在于，我们自己写的，并且是可信赖的VMM运行在Supervisor mode，而我们将Guest kernel运行在User mode，通过一系列的处理使得Guest kernel看起来像是运行在Supervisor mode。

好消息是，在RISC-V上，如果在user mode尝试运行任何一个Supervisor指令都会触发trap。这里的Supervisor指令要排除与page table相关的指令，我们稍后会介绍相关的内容。所以每当Guest操作系统尝试执行类似于读取SCAUSE寄存器，读写STVEC寄存器，都会触发一个trap，并走到VMM，之后我们就可以获得控制权。

VMM会Guest维护虚拟状态信息。所以VMM里面会维护虚拟的STVEC寄存器，虚拟的SEPC寄存器以及其他所有的privileged寄存器。当Guest操作系统运行指令需要读取某个privileged寄存器时，首先会通过trap走到VMM，因为在用户空间读取privileged寄存器是非法的。之后VMM会检查这条指令并发现这是一个读取SEPC寄存器的指令，之后VMM会模拟这条指令，并将自己维护的虚拟SEPC寄存器，拷贝到trapframe的用户寄存器中（注，有关trapframe详见Lec06，这里假设Guest操作系统通过类似sread a0, sepc的指令想要将spec读取到用户寄存器a0）。之后，VMM会将trapframe中保存的用户寄存器拷贝回真正的用户寄存器，通过sret指令，使得Guest从trap中返回，这时，用户寄存器里面保存的就是spec寄存器的值了。之后Guest操作系统会继续执行指令，但是又没有意识到这里与实际的操作系统trap过程有什么不一样。最终，Guest读到了VMM替自己保管的虚拟SEPC寄存器。这就是trap and emulate的过程。

![](../.gitbook/assets/image%20%28732%29.png)

> 学生提问：VMM是怎么区分不同的Guest？
>
> Robert教授：VMM会为每个Guest保存一份虚拟状态信息，然后它就像XV6知道是哪个进程一样，VMM也知道是哪个Guest通过trap走到VMM的。XV6有一个针对每个CPU的变量表明当前运行的是哪个指令，类似的VMM也有一个针对每个CPU的变量表明当前是哪个虚拟机在运行，并查看对应的虚拟状态信息。
>
> 学生提问：VMM可以给一个Guest分配多个CPU核吗？
>
> Robert教授：稍微复杂点的VMM都可以实现这个。
>
> 学生提问：Guest操作系统在实际的硬件中会有对应寄存器，那么为什么我们不直接使用硬件中的寄存器，而是使用虚拟的寄存器？
>
> Robert教授：这里的原因是，VMM需要使用真实的寄存器。举个例子，想象一下SCAUSE寄存器，当Guest操作系统尝试做任何privileged操作时（注，也就是读写privileged寄存器），会发生trap。硬件会将硬件中真实的SCAUSE寄存器设置成引起trap的原因，这里的原因是因为权限不够。但是假设Guest操作系统只是从Guest用户进程执行了一个系统调用，Guest操作系统需要看到SCAUSE的值是系统调用。
>
> Guest操作系统在trap handler中处理来自Guest进程的系统调用时，需要SCAUSE的值表明是系统调用。

![](../.gitbook/assets/image%20%28733%29.png)

> 而实际的SCAUSE寄存器的值却表明是因为指令违反了privilege规则。通常情况下，VMM需要看到真实寄存器的值，而Guest操作系统需要能看到符合自己视角的寄存器的值。

这种虚拟机的实现风格中，Guest运行在用户空间，任何时候它想要执行任何需要privilege权限的指令时，会通过trap走到VMM，VMM可以模拟这些指令。这种实现风格叫做trap and emulate。这种风格很好，你可以完全通过软件实现这种风格，你可以只通过修改软件就将XV6修改成一个可以运行在RISC-V上的VMM，然后再在之上运行XV6虚拟机。当然，VMM需要运行在Supervisor mode。

所有以S开头的寄存器，也就是所有的Supervisor控制寄存器都必须保存在虚拟状态信息中。同时还有一些数据并不是可以直接通过这些控制寄存器访问的，然后又必须在这个虚拟状态信息中完成。其中一个就是mode，VMM需要知道虚拟机是运行在Guest user mode还是Guest Supervisor mode。例如，Guest中的用户代码尝试执行privileged指令，比如读取SCAUSE寄存器，这也会导致trap并走到VMM。但是这种情况下VMM不应该模拟指令并返回，因为这并不是一个user mode中的合法指令。所以VMM需要跟踪Guest是在user mode还是Supervisor mode，所以在虚拟状态信息里面也会保存mode。

![](../.gitbook/assets/image%20%28729%29.png)

