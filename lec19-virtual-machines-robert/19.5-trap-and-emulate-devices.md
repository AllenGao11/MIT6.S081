# 19.5 Trap-and-Emulate --- Devices

接下来我们来看Trap and Emulate的最后一个部分，也就是外部设备。例如，一个普通的操作系统期望能有一个磁盘来在存储文件系统，又或者是期望有一个网卡，甚至对于XV6来说期望有一个UART设备来与console交互，或者期望有一张声卡，一个显卡，键盘鼠标等等各种各样的东西。所以我们需要我们的虚拟机方案能够至少使得Guest认为所有它们需要的外部设备至少是存在的。

人们通常会使用三种策略。

第一种是，模拟一些需要用到的并且使用非常广泛的设备，例如磁盘。也就是说，Guest并不是拥有一个真正的设备，只是VMM使得与Guest交互的磁盘看起来好像存在一样。这里的实现方式是，Guest操作系统会通过Memory Map控制寄存器与设备进行交互，这也是XV6与UART交互的方式。操作系统会假设硬件已经将自己的控制寄存器映射到了内核地址空间的某个地址中。你在VMM中可以这样模拟，你实际上不映射这些内存Page，相应的你将这些Page设置成无效的，这样每当Guest操作系统尝试使用UART或者其他硬件时，会通过trap走到VMM。VMM会查看指令并发现Guest正在尝试在UART发送字符或者从磁盘中读取数据。VMM会对磁盘有一些模拟，或者对串口设备有一些模拟，通过这些模拟，VMM知道如何响应Guest的指令，之后再恢复Guest的执行。这就是我们之前基于QEMU介绍XV6时，QEMU实现UART的方式。在之前的介绍中，并没有UART硬件的存在，但是QEMU模拟了一个UART来使得XV6正常工作。所以这是一个常见的实现方式。但是这种方式可能会非常的低效，因为每一个Guest与外设硬件的交互，都会触发一个trap。但是对于一些低速场景，这种方式工作的较好。如果你的目标就是能启动操作系统并使得它们完全不知道自己运行在虚拟机上，你只能使用这种策略。

![](../.gitbook/assets/image%20%28738%29.png)

在现代的世界中，操作系统在最底层是知道自己运行在虚拟机之上的。所以第二种策略是提供虚拟设备，并不是模拟一个真实的设备，而是构建一个设备接口，它为Guest中的设备驱动提供了高效的方式来与VMM内支持的设备进行交互。所以你或许没有Memory Mapped寄存器，相应的你或许会有一个命令队列在内存中，Guest操作系统会将读写设备的命令写到队列中。实际上XV6也使用了一种这个方式，XV6的virtio\_disk.c文件中，你可以看到一个设备驱动尝试与QEMU实现的虚拟磁盘设备交互。在这个驱动里面要么只是有了很少的，要么没有使用Memory Mapped Register，所以它并不依赖trap，相应的它在内存中格式化了一个命令队列，如我们之前所说。之后QEMU从内存中读取这些指令，并没有将它们应用到磁盘中，而是将它们应用到一个文件，对于XV6来说就是fs.image。QEMU将这些命令应用到fs.image，而不是使用一个真实的硬件。这比直接模拟设备性能要更高，因为你可以设计接口使得并不需要太多的trap。

![](../.gitbook/assets/image%20%28739%29.png)

第三个策略是对于真实设备的pass-through，这里典型的例子就是网卡。现代的网卡具备硬件的支持，可以与VMM运行的多个Guest操作系统交互。所以你可以配置你的现代的网卡，使得它表现的就像多个独立的网卡，每个Guest操作系统拥有其中一个。经过VMM的配置，Guest操作系统可以直接与它在网卡上那一部分进行交互，并且效率非常的高。所以这是现代的高性能方法。理论上，我认为你可以设置好使得操作系统并不知道会有任何奇怪的事情，但是实际中Guest操作系统驱动知道它们正在与这种特别的网卡交互。

![](../.gitbook/assets/image%20%28737%29.png)

以上就是实现外部设备的选项。我认为现在在实现一个VMM的主要困难在于构建设备模拟和设备驱动，使得它们足够好以至于能正确的与Guest操作系统工作。所以这里或许是实现VMM的主要工作。尤其是当你使用第一种策略时。

> 学生提问：我并没有太理解策略一emulation和策略二virtual device的区别。
>
> Robert教授：它们是类似的。可以这么想，如果你启动了一个完全不知道虚拟机的操作系统，它或许包含了很多磁盘驱动，但是所有的驱动都是为真实硬件提供的。如果你想要在虚拟机中启动这样一个操作系统，你需要选择其中一种真实的硬件，并且以一种非常准确的方式来模拟该硬件。这种方式并没有问题，只是大部分情况下硬件接口并没有考虑Trap and Emulate VMM下的性能。所以真实的设备驱动需要你频繁的读写它的控制寄存器，而VMM需要为每一次写控制寄存器都获取控制权，因为它需要模拟真实的硬件。这意味着每一次写控制寄存器都会出发一次trap走到VMM，并消耗数百个CPU cycles。这意味着策略一非常的慢且低效。
>
> 策略二并没有卑微的模仿真实的设备，某些设计人员提出了一种设备驱动，这种设备驱动并不对接任何真实的硬件设备，只对接由VMM实现的虚拟设备。这种驱动设计的并不需要很多trap，这种驱动与对应的虚拟设备是解耦的，并且并不需要立即的交互。
>
> 从功能层面上来说，使用策略一的话，你可以启动任何操作系统，使用策略二的话，如果你想要使用虚拟设备，你只能启动知道虚拟设备的操作系统。实际中，策略二是一种标准，并且被多种虚拟机方法提供。虽然我们并没有在除了QEMU以外的其他场景测试过，XV6中的virtio\_disk.c稍作修改或许也可以在其他虚拟机方案上运行。
>
> 学生提问：所以对于每一种主板，取决于不同的磁盘，编译XV6都需要不同的磁盘驱动，是吗？
>
> Robert教授：是的。我认为或许你可以买到支持virtio\_disk驱动的真实硬件，但是大部分的磁盘硬件还不支持这个驱动，这时你需要实现为真实的硬件实现一种新的驱动。

