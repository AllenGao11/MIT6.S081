# 19.7

今天的[论文](https://pdos.csail.mit.edu/6.828/2020/readings/belay-dune.pdf)，利用了上一节介绍的对于虚拟机的硬件支持，但是却将其用作其他的用途。这是这篇论文的有趣之处，它利用了这种完全是为了虚拟机而设计的硬件，但是却用来做一些与虚拟机无关的事情。

从一个全局的视角来看这篇论文的内容，它只是想要实现普通的进程。所以现在我们的场景是在一个Linux而不是虚拟机中，但是硬件中又存在VT-x。我们假设我们加载了DUNE的可加载模块到Linux中，所以DUNE软件作为kernel的一部分运行在Supervisor mode，除此之外，内核的大部分还是Linux。

因为我们这里会运行Linux进程，所以我们期望这里支持的抽象是进程，以及包括系统调用在内的各种Linux进程可以做的事情。但是我们想要使用VT-x硬件来使得普通的进程可以做一些额外的事情。DUNE会运行这些进程，或者说允许一个进程切换到DUNE模式，这意味着，与其只是被Page Table保护和隔离，现在这个进程完全被VT-x机制隔离开了。所以现在进程有了一套完整的虚拟控制寄存器，例如CR3，因此也会有属于自己的Page Table，因为这些进程会运行在non-root Supervisor mode，所以它可以在虚拟状态信息上执行所有的privileged指令，这是由VT-x实现的。所以被DUNE管理的进程可以做的一个关键事情是，通过属于自己的CR3寄存器，设置好属于自己的Page Table。当然DUNE为这个进程控制了EPT。而EPT会被设置的只包含这个进程相关的内存。所以进程可以向CR3寄存器写入任意的Page Table地址，但是因为MMU会在翻译完正常的Page Table之后再将地址送到EPT去翻译，所以进程不能从分配给它的内存中逃逸。所以进程并不能修改其他进程或者kernel的内存，它只是有了一种更灵活的设置自己内存的方式。所以，DUNE管理的进程可以拥有属于自己的Page Table，基本上它需要有属于自己的Page Table，否则它是不能工作的。

![](../.gitbook/assets/image%20%28747%29.png)

DUNE管理的进程可以做的另一件事情是，可以拥有Supervisor mode和User mode，就像一个小的虚拟机一样。并且可以保护运行在Supervisor mode的代码，不受运行在User mode的代码影响。

![](../.gitbook/assets/image%20%28749%29.png)

论文中提到了可以基于 Dune做的两件事情：能够在硬件层面支持Supervisor mode和User mode使得进程可以在自己的User mode中运行未被信任的插件代码。这里的主进程或许是一个网页浏览器，你可以下载各种各样的插件并运行在网页浏览器中，或许是一个新的视频解码器，一个新的广告拦截插件等等。但是我们并不完全信任这个插件，所以我们希望能够在权限受限制的前提下运行它。在一个普通的Linux中也可以达到这个目的，但是会比较麻烦。而通过DUNE，我们可以在User mode下运行插件，而网页浏览器运行在进程的Supervisor mode下，并且可以为User mode配置一个不同的Page Table，因为它可以修改CR3寄存器。这使得进程可以运行这里的未被信任的插件代码，并且只能访问网页流量器的某些内存Page，所以即使插件是恶意的，它也不能任意的读写主浏览器的内存。User代码或许会想要执行系统调用，但是这些提供调用会通过trap走到进程的Supervisor mode，而不是Linux，所以这里的插件代码或许会认为自己调用了fork/read/write等系统调用，但是实际上这里尝试运行的系统调用通过trap走到了进程对应的网页浏览器，网页浏览器可以做任意的事情，它可以选择执行或者不执行系统调用。所以现在网页浏览器对于插件代码有了完整的控制能力。

公平的说，这里的效果可以通过现存的Linux中包含的非常不一样的技术实现。但是DUNE使得你可以提供一个特别优雅且有效的方式通过使用VT-x硬件。

另一个事情是，DUNE提供的机制可以使得垃圾回收（Garbage Collect，GC）更快。现在没有了Supervisor mode和User mode，假设我们在运行任意一种带有GC的编程语言，比如说Java或者Python。GC可能会很慢，有非常非常多的技术可以使得GC变快，但是GC中一件重要的事情是，许多GC都会跟踪并找到仍然在使用的内存，通过从寄存器中保存的对象开始，跟踪所有对象的所有指针。如果在trace之后没能找到某个对象，那说明这个对象不被任何指针引用，那么它就可以被释放了。许多GC会同时在主程序的另一个线程中运行。所以GC会从寄存器中保存的指针开始，根据指针之间的树或者图的关系，走到一个个的对象。

![](../.gitbook/assets/image%20%28746%29.png)

但是因为GC是与程序本身并发的在运行，或许程序会修改GC已经查看过的对象。这很糟糕，因为现在GC确定的要回收和不回收的对象清单可能已经不正确了，因为一些已经查看过的对象已经被修改了。所以DUNE使用了Page Table支持来提供一种方式供GC来检测这样的修改。DUNE会设置好由VT-x提供的虚拟CR3寄存器，指向属于自己的Page Table。它会让其中的PTE都是有效的，但是会查看dirty位。每个PTE的dirty位表明对该Page存在写操作，所以如果有个程序写了某些对象，那么对应Page的dirty位会被设置为1。当GC查找完所有的对象之后，它会查看PTE中的dirty位，来找到所有包含了可能修改过对象的内存Page，然后重新扫描这些对象。实际中，获取dirty位的过程在普通的Linux中既困难又慢。我甚至都不确定Linux是否支持这个操作，在某些操作系统中你可以通过系统调用来查询dirty位。但是如果你使用DUNE和  
BT-x，进程可以使用普通的load和store指令获取PTE，进而获取dirty位，并且这很快。所以这里的技巧使得某些需要频繁出发GC的程序明显的更快。

> 学生提问：如果User mode中的插件程序想要运行属于自己的GC会怎样？
>
> Robert教授：所以现在我们使用了DUNE，并且有一个进程是被DUNE管理。这个进程通过VT-x实现了Supervisor mode和User mode，我们在User mode运行了一个插件。并且插件也是由带GC的编程语言写的，所以它有属于自己的Page Table，并且其中的PTE也包含了dirty位。但是刚刚说的GC加速在这不能工作，因为DUNE会将插件运行在Guest User mode，而就像User mode一样，Guest User mode不允许使用CR3寄存器，所以在Guest User mode，我们不能快速的访问PTE的dirty位。只有在Guest Supervisor mode，才能通过CR3寄存器访问Page Table。所以，没有一个明显的方法可以结合DUNE提供的两种功能。

![](../.gitbook/assets/image%20%28740%29.png)

> 学生提问：如果某人基于DUNE写了个浏览器，那么对于不支持DUNE的计算机来说很难使用这样的浏览器，对吗？就像很难直接让Chrome使用DUNE，因为不是所有人都有这个内核模块。
>
> Robert教授：首先，需要运行在支持VT-x的计算机上，也就是说底层的计算机必须支持VT-x，所以需要VT-x来运行DUNE，其次DUNE需要被加载来运行浏览器以利用前面说到的特性。所以是的，你需要将所有的东西都设置好。并且你懂的，这是一个研究项目，它的目标是使得人们去思考可以在真实世界部署的东西，并看看这些东西是否有足够的价值。就像Linux一样，Linux有成千上万个功能，如果某人决定将DUNE添加到Linux中作为一个标准功能，那么我们就可以依赖这个功能，并且Chrome也可以直接用它了。
>
> 学生提问：所以从整体来看，这里就像是创建了一个VM，但是实际上运行的又是一个进程？
>
> Robert教授：你可以这么描述。这里主要是对进程进行抽象，但是这里没有用Page Table硬件，这里使用的是CPU上的硬件来支持进程，这里说的CPU上的硬件就是VT-x，它包含了一些额外的功能，例如设置好属于进程的Page Table。
>
> 学生提问：如果DUNE管理的一个进程fork了，那就会变成一个不被DUNE管理的进程，这不会是一个安全漏洞吗？比如说你通过DUNE运行了一个进程，并且认为它现在是安全的。但是通过fork之后它又逃逸了。
>
> Robert教授：DUNE管理的进程的Guest Supervisor mode中，不存在安全的问题。这部分代码已经拥有了相应的privilege，通过fork也不会获得更多的privillege。但是另一方面，DUNE的Guest User mode代码中，我们有未被信任的代码。

