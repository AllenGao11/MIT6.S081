# 19.7

今天的[论文](https://pdos.csail.mit.edu/6.828/2020/readings/belay-dune.pdf)，利用了上一节介绍的对于虚拟机的硬件支持，但是却将其用作其他的用途。这是这篇论文的有趣之处，它利用了这种完全是为了虚拟机而设计的硬件，但是却用来做一些与虚拟机无关的事情。

从一个全局的视角来看这篇论文的内容，它只是想要实现普通的进程。所以现在我们的场景是在一个Linux而不是虚拟机中，但是硬件中又存在VT-x。我们假设我们加载了DUNE的可加载模块到Linux中，所以DUNE软件作为kernel的一部分运行在Supervisor mode，除此之外，内核的大部分还是Linux。

因为我们这里会运行Linux进程，所以我们期望这里支持的抽象是进程，以及包括系统调用在内的各种Linux进程可以做的事情。但是我们想要使用VT-x硬件来使得普通的进程可以做一些额外的事情。DUNE会运行这些进程，或者说允许一个进程切换到DUNE模式，这意味着，与其只是被Page Table保护和隔离，现在这个进程完全被VT-x机制隔离开了。所以现在进程有了一套完整的虚拟控制寄存器，例如CR3，因此也会有属于自己的Page Table，因为这些进程会运行在non-root Supervisor mode，所以它可以在虚拟状态信息上执行所有的privileged指令，这是由VT-x实现的。所以被DUNE管理的进程可以做的一个关键事情是，通过属于自己的CR3寄存器，设置好属于自己的Page Table。当然DUNE为这个进程控制了EPT。而EPT会被设置的只包含这个进程相关的内存。所以进程可以向CR3寄存器写入任意的Page Table地址，但是因为MMU会在翻译完正常的Page Table之后再将地址送到EPT去翻译，所以进程不能从分配给它的内存中逃逸。所以进程并不能修改其他进程或者kernel的内存，它只是有了一种更灵活的设置自己内存的方式。所以，DUNE管理的进程可以拥有属于自己的Page Table，基本上它需要有属于自己的Page Table，否则它是不能工作的。

![](../.gitbook/assets/image%20%28747%29.png)

DUNE管理的进程可以做的另一件事情是，可以拥有Supervisor mode和User mode，就像一个小的虚拟机一样。并且可以保护运行在Supervisor mode的代码，不受运行在User mode的代码影响。

![](../.gitbook/assets/image%20%28750%29.png)

论文中提到了可以基于 Dune做的两件事情：能够在硬件层面支持Supervisor mode和User mode使得进程可以在自己的User mode中运行未被信任的插件代码。这里的主进程或许是一个网页浏览器，你可以下载各种各样的插件并运行在网页浏览器中，或许是一个新的视频解码器，一个新的广告拦截插件等等。但是我们并不完全信任这个插件，所以我们希望能够在权限受限制的前提下运行它。在一个普通的Linux中也可以达到这个目的，但是会比较麻烦。而通过DUNE，我们可以在User mode下运行插件，而网页浏览器运行在进程的Supervisor mode下，并且可以为User mode配置一个不同的Page Table，因为它可以修改CR3寄存器。这使得进程可以运行这里的未被信任的插件代码，并且只能访问网页流量器的某些内存Page，所以即使插件是恶意的，它也不能任意的读写主浏览器的内存。User代码或许会想要执行系统调用，但是这些提供调用会通过trap走到进程的Supervisor mode，而不是Linux，所以这里的插件代码或许会认为自己调用了fork/read/write等系统调用，但是实际上这里尝试运行的系统调用通过trap走到了进程对应的网页浏览器，网页浏览器可以做任意的事情，它可以选择执行或者不执行系统调用。所以现在网页浏览器对于插件代码有了完整的控制能力。

公平的说，这里的效果可以通过现存的Linux中包含的非常不一样的技术实现。但是DUNE使得你可以提供一个特别优雅且有效的方式通过使用VT-x硬件。

另一个事情是，DUNE提供的机制可以使得垃圾回收（Garbage Collect，GC）更快。现在没有了Supervisor mode和User mode，假设我们在运行任意一种带有GC的编程语言，比如说Java或者Python。GC可能会很慢，有非常非常多的技术可以使得GC变快，但是GC中一件重要的事情是，许多GC都会跟踪并找到仍然在使用的内存，通过从寄存器中保存的对象开始，跟踪所有对象的所有指针。如果在trace之后没能找到某个对象，那说明这个对象不被任何指针引用，那么它就可以被释放了。许多GC会同时在主程序的另一个线程中运行。所以GC会从寄存器中保存的指针开始，根据指针之间的树或者图的关系，走到一个个的对象。

![](../.gitbook/assets/image%20%28748%29.png)

但是因为GC是与程序本身并发的在运行，或许程序会修改GC已经查看过的对象。这很糟糕，因为现在GC确定的要回收和不回收的对象清单可能已经不正确了，因为一些已经查看过的对象已经被修改了。所以DUNE使用了Page Table支持来提供一种方式供GC来检测这样的修改。DUNE会设置好由VT-x提供的虚拟CR3寄存器，指向属于自己的Page Table。它会让其中的PTE都是有效的，但是会查看dirty位。每个PTE的dirty位表明对该Page存在写操作，所以如果有个程序写了某些对象，那么对应Page的dirty位会被设置为1。当GC查找完所有的对象之后，它会查看PTE中的dirty位，来找到所有包含了可能修改过对象的内存Page，然后重新扫描这些对象。实际中，获取dirty位的过程在普通的Linux中既困难又慢。我甚至都不确定Linux是否支持这个操作，在某些操作系统中你可以通过系统调用来查询dirty位。但是如果你使用DUNE和  
BT-x，进程可以使用普通的load和store指令获取PTE，进而获取dirty位，并且这很快。所以这里的技巧使得某些需要频繁出发GC的程序明显的更快。

> 学生提问：如果User mode中的插件程序想要运行属于自己的GC会怎样？
>
> Robert教授：所以现在我们使用了DUNE，并且有一个进程是被DUNE管理。这个进程通过VT-x实现了Supervisor mode和User mode，我们在User mode运行了一个插件。并且插件也是由带GC的编程语言写的，所以它有属于自己的Page Table，并且其中的PTE也包含了dirty位。但是刚刚说的GC加速在这不能工作，因为DUNE会将插件运行在Guest User mode，而就像User mode一样，Guest User mode不允许使用CR3寄存器，所以在Guest User mode，我们不能快速的访问PTE的dirty位。只有在Guest Supervisor mode，才能通过CR3寄存器访问Page Table。所以，没有一个明显的方法可以结合DUNE提供的两种功能。

![](../.gitbook/assets/image%20%28740%29.png)

> 学生提问：如果某人基于DUNE写了个浏览器，那么对于不支持DUNE的计算机来说很难使用这样的浏览器，对吗？就像很难直接让Chrome使用DUNE，因为不是所有人都有这个内核模块。
>
> Robert教授：首先，需要运行在支持VT-x的计算机上，也就是说底层的计算机必须支持VT-x，所以需要VT-x来运行DUNE，其次DUNE需要被加载来运行浏览器以利用前面说到的特性。所以是的，你需要将所有的东西都设置好。并且你懂的，这是一个研究项目，它的目标是使得人们去思考可以在真实世界部署的东西，并看看这些东西是否有足够的价值。就像Linux一样，Linux有成千上万个功能，如果某人决定将DUNE添加到Linux中作为一个标准功能，那么我们就可以依赖这个功能，并且Chrome也可以直接用它了。
>
> 学生提问：所以从整体来看，这里就像是创建了一个VM，但是实际上运行的又是一个进程？
>
> Robert教授：你可以这么描述。这里主要是对进程进行抽象，但是这里没有用Page Table硬件，这里使用的是CPU上的硬件来支持进程，这里说的CPU上的硬件就是VT-x，它包含了一些额外的功能，例如设置好属于进程的Page Table。
>
> 学生提问：如果DUNE管理的一个进程fork了，那就会变成一个不被DUNE管理的进程，这不会是一个安全漏洞吗？比如说你通过DUNE运行了一个进程，并且认为它现在是安全的。但是通过fork之后它又逃逸了。
>
> Robert教授：DUNE管理的进程的Guest Supervisor mode中，不存在安全的问题。这部分代码已经拥有了相应的privilege，通过fork也不会获得更多的privillege。但是另一方面，DUNE的Guest User mode代码中，我们有未被信任的代码，如果让它在没有DUNE管理的情况下运行会有一定的风险。所以这部分代码不能fork，如果它尝试fork系统调用，会通过trap走到进程的Guest Supervisor mode。

![](../.gitbook/assets/image%20%28741%29.png)

> 假设进程的Guest Supervisor mode部分代码写的非常的小心，并且不会被欺骗，那么它不会执行fork，所以这时fork不能工作。如果Supervisor mode的代码允许fork，它会调用Linux的fork系统调用，并得到一个fork进程包含了与原进程有相同的内存镜像。所以我们在新进程中包含插件代码。如果新进程没有意识到DUNE已经被关闭了，那么原来的Supervisor mode中的privileged指令会是非法的。所以我们需要假设DUNE管理的进程中Supervisor mode中的代码足够的小心且足够的聪明，来组织User mode中的插件代码执行fork。
>
> 学生：被DUNE管理的进程拥有Supervisor mode并没有不安全，因为它实际上是non-root mode下的Supervisor mode，就像是Guest操作系统中的Supervisor mode一样，你可以让它做任何事情，因为VT-x的存在，进程就像是一个虚拟机一样，并不能伤害到真正的操作系统。
>
> Robert教授：是的，进程不能逃逸出来，因为存在EPT，而EPT会限制进程的地址空间。
>
> 学生提问：在EPT的介绍文档中，有一段说到，User Page Table可以通过重新映射到之前的layout扩展地址。
>
> Robert教授：在x86上，物理内存地址比虚拟内存地址少几个bit位，接下来都是我猜的，这意味着，EPT，你懂的普通的Page Table将虚拟内存地址映射到少了几个bit的物理内存地址。这意味着，当DUNE为一个进程设置到内存地址空间时，进程内存地址空间需要适配在更少的bit位中。我们假设虚拟内存地址是48bit，物理内存地址可能只有36bit，普通的用户进程可以使用所有的48bit作为虚拟内存地址，而一个DUNE管理的进程只能使用36bit。
>
> 学生提问：在VT-x的方案中，当我们访问Page Table时，因为我们需要通过EPT进行第二层翻译，将Guest物理内存地址翻译到Host物理内存地址，返回Page Table的延时是不是增加了？
>
> Robert教授：这里可能会花费更多的时间让硬件MMU来翻译内存地址。在最坏的情况下，比如在RISC-V中，会有多层Page Table，MMU需要一层一层的去查找PTE，x86下同样也有多层Page Table，所以在x86中首先会查找主Page Table，如果要访问更多的内存地址，每一次内存地址的访问都需要走到EPT，而EPT也是一个多层的Page Table。所以我并不知道最差情况下需要内存地址需要访问几次，但是在VT-x下会比普通情况下差得多。实际中会有cache所以通常不会走到最坏的情况。
>
> 学生提问：今天的虚拟机还是普遍会更慢吗？如果是的话，AWS是怎么工作的，因为看起来还挺快的，并且工作的也很好。
>
> Robert教授：我认为他们使用了硬件上的VT-x支持，并且使用了我们讨论过的一些功能，这样使得AWS虚拟机比较快，或者并不比真实的计算机慢多少。
>
> 学生提问：我对于Trap and Emulate中的Shadow Page Table有个问题，每次都会创建吗？难道不能记住上次的Shadow Page Table吗？
>
> Robert教授：VMM需要创建新的Page Table以供真实的硬件使用。当然有很多的机会都可以做cache，对于一个聪明的VMM，它可以注意到Guest更新了一个PTE，VMM可以做相应的有限的工作来更新Shadow Page Table。如果机器是在多个虚拟机上分时复用的，VMM会为还在运行的虚拟机保存Shadow Page Table，这样这些虚拟机可以在恢复时直接重用。 
>
> 学生提问：这难道不是意味着为每个虚拟机中的每个进程都保存Shadow Page Table的拷贝？
>
> Robert教授：是的，虚拟机里面有很多很多个Page Table，而虚拟机知道所有的Page Table。而维护Shadow Page Table需要消耗大量的工作。而类似与VT-x的硬件支持使得这部分更加的容易了，因为EPT表示你不用构建Shadow Page Table了。
>
> 学生提问：我有个问题有关GC的，如果有dirty位的话需要重新扫描对象，那么有没有可能会无限扫描？
>
> Robert教授：使得，这有个问题，如果一直有对象在更新，扫描能正常结束吗？实际中，GC会先扫描一次，之后它会冻结除了GC以外的其他对象，所以这期间不能发生任何其他的事情，之后它会查看dirty位，但是因为其他所有对象都冻结了，所以不可能会有更多的dirty位了，所以GC查看了所有的dirty位，并知道扫描完成了，然后结束扫描并创建需要释放对象的列表，然后恢复所有之前停止的线程的执行。GC是一个复杂的流程，DUNE的论文中并没有足够的空间讨论它。

