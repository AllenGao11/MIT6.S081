# 22.7 Meltdown Fix

我最后想讨论的是Meltdown的修复，你们实际已经接触了一些了。当[论文](https://pdos.csail.mit.edu/6.828/2020/readings/meltdown.pdf)发表的时候，它获取了很多的关注。实际中还有另一篇论文，也是由这篇论文的部分作者参与完成，另一篇论文讨论了一种使用了CPU内一种叫做Spectre的不同的预测执行的不同攻击。这一对论文的同时出现让人非常兴奋\(￣▽￣\)"。

人们发现现在危害比较大了，因为现在我们讨论的是操作系统的隔离性被破坏了。你几乎不会考虑到这种情况，但是这里的技术破坏了Page Table的保护，这是我们用来实现用户和内核间隔离的技术，所以这是一个非常基础的攻击，或者至少以一种非常通用的方式破坏了安全性非常重要的一个部分。所以人们非常非常迫切的想要修复Meltdown。

很多操作系统在这篇论文发表之后数周内就推出的一个快速修复是一个叫做KAISER，现在在Linux中被称为KPTI的技术（Kernel page-table isolation）。这里的想法很简单，也就是不将内核内存映射到Page Table中，相应的，就像XV6一样，在系统调用时切换Page Table。所以在用户空间时，只有用户内存地址映射，如果执行了系统调用，会有类似于XV6中trampoline的机制，切换到拥有内核内存映射的一个Page Table中，这样才能执行内核代码。

![](../.gitbook/assets/image%20%28875%29.png)

这会导致Meltdown不能工作，因为现在你会切换Page Table，本来代表内核虚拟内存地址的r1寄存器不仅是没有权限，并且也没有意义了，因为现在的用户Page Table并没有包含对它的翻译，所以CPU并不知道该如何处理这个内存地址。现在这个虚拟内存地址不会存在于cache中，甚至都不会出现在TLB中。所以当在用户空间发起Meltdown Attack时，也就没有办法知道对应这个虚拟内存地址的数据是什么。这个虚拟内存地址并不是非法的，只是在用户空间没有意义了，这样会导致Meltdown Attack不能工作。

KAISER的缺点是，系统调用的代价更高了，因为如果不做任何事情的话，切换Page Table会导致TLB被清空，因为现在TLB中的映射关系现在都是前一个Page Table的。同时也会导致L1 cache被清空，因为其中对应的是虚拟内存地址。在一些机器上，切换Page Table会使得系统调用明显变慢。

最近的CPU拥有叫做PCID（process-context identifiers）的技术，它可以帮助你在切换Page Table时清空Cache，尽管它还是要花费一些时间。

如果你上网看的话，当时人们有很多顾虑，当时人们认为这种两个Page Table的方案是不可接受的慢。但是实际中这并不是一个严重的问题，你上网看的话就可以发现人们对于典型工作负载的猜想，也就是对工作负载的整体影响有多少，因为毕竟程序也不是一直在进出内核，这里的影响大概是5%，所以这并不是一个坏的主意。人们非常快的采用了这种方案，实际上在论文发表时，已经有内核采用了这种方案来抵御其他的攻击。

除此之外，还有一个合理的硬件修复。我相信Intel在最近的处理器上已经添加了这个修复，AMD之前就已经有这个修复。

