# 23.7 RCU代码

为了巩固前面介绍的内容，接下来看一段使用了RCU的简单代码。上半段是读取被RCU保护的链表 ，下半段代码是替换链表的第一个元素。

![](../.gitbook/assets/image%20%28711%29.png)

数据读取位于rcu\_read\_lock和rcu\_read\_unlock之间，这两个函数几乎不做任何事情。rcu\_read\_lock会设置一个标志位，表明如果发生了定时器中断，请不要执行context switch，因为我正在RCU critical 区域中。所以rcu\_read\_lock会设置一个标志位来阻止定时器中断导致的context switch，中断或许还会发生，但是不会导致context switch。rcu\_read\_unlock取消该标志位。所以这是一个集成在RCU critical区域的计数器。rcu\_read\_lock和rcu\_read\_unlock因为几乎不做任何工作所以极其的快。

其中的while循环会扫描链表，rcu\_dereference函数会插入memory barrier，它首先会从内存中拷贝e，触发一个memory barrier，之后返回指向e的指针。之后我们就可以读取e指针指向的数据内容，并走向下一个链表元素。数据读取部分非常简单。

数据写入部分更复杂点。RCU并不能帮助数据写入者之间避免相互干扰，所以必须有一种方法能确保一次只能有一个数据写入者更新链表。这里我们假设我们将使用普通的spinlock，所以最开始数据写入者获取锁。如果我们要替换链表的第一个元素，我们需要保存先保存链表第一个元素的拷贝，因为最后我们需要释放它，所以有old=head。接下来的代码执行的是之前介绍的内容，首先是分配一个全新的链表元素，之后是设置该链表元素的内容，设置该链表元素的next指针指向旧元素的next指针。之后的rcu\_assign\_pointer函数会设置一个memory barrier，以确保之前的所有写操作都执行完，之后再将head指向新分配的链表元素e。之后就是释放锁。

之后调用synchronize\_rcu确保任何一个可能持有了旧的链表元素的CPU都执行一次context switch，因此这些CPU会放弃指向旧链表元素的指针。最后是释放旧的链表元素。

这里有件事情需要注意，在数据读取代码中，我们可以在循环中查看链表元素，但是我们不能将链表元素返回。例如，我们使用RCU的时候，不能写一个list\_lookup函数来返回链表元素或者返回指向链表元素中数据的指针，比如说嵌入在链表元素中的字符串。因为如果这样的话，

