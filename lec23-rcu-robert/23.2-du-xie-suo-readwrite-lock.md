# 23.2 读写锁 \(Read-Write Lock\)

这种锁被称为读写锁（Read-Write Lock），它的接口相比spinlock略显复杂。如果只是想要读取数据，那么可以调用r\_lock，将锁作为参数传入，同样的还会有个r\_unlock，数据的读取者使用这些接口。数据的写入者调用w\_lock和w\_unlock接口。

![](../.gitbook/assets/image%20%28676%29.png)

这里的语义是，要么你可以有多个数据的读取者获取了读取数据的锁这样可以获得并行执行的能力，要么你只能有一个数据的写入者获取了写数据的锁。但是不能同时有两者，读写锁排除了某人获取了数据的写锁，同时又有别人获取读锁可能性。你要么只有一个数据写入者，要么有多个数据的读取者，不可能有别的可能。

> 学生提问：当某人持有了读锁时，读写锁是采用什么方案来阻止其他人写入数据的？
>
> Robert教授：并没有什么方案，这就像XV6的锁一样。我们这里讨论的是由值得信赖且负责的开发人员编写的内核代码，所以就像XV6的spinlock一样，如果使用锁的代码是不正确的，那么结果就是不正确的，这既是内核代码典型的编写方式，你只能假设开发内核的人员遵循这里的规则。

如果我们有一个大部分是读取操作的数据结构，我们会希望能有多个用户能同时使用这个数据结构，这样我们就可以通过多核CPU获得真正的性能提升。如果没有问题的话，那么读写锁就可以解决今天的问题，我们也没有必要读RCU这篇论文。但实际上是，如果你深入细节，你会发现当你使用读写锁时，尤其对于大部分都是读取操作的数据结构，会有一些问题。为了了解实际发生了什么，我们必须看一下读写锁的实现。

![](../.gitbook/assets/image%20%28668%29.png)

Linux实际上有读写锁的实现，上面是一种简化了的Linux代码。首先有一个结构体是rwlock，这与XV6中的lock结构体类似。rwlock结构体里面有一个计数器n，

* 如果n等于0那表示锁没有以任何形式被被任何人持有
* 如果n等于-1那表示当前有个数据写入者持有锁
* 如果n大于0表示有n个数据读取者持有锁我们需要记录这里的数字，因为我们只有在n减为0的时候才能让数据写入者持有锁。

r\_lock函数会一直在一个循环里面等待数据写入者释放锁。首先它获取读写锁中计数器n的拷贝，如果n的拷贝小于0的话那意味着存在一个数据写入者，我们只能继续循环以等待数据写入者退出。如果n的拷贝不小于0，我们会增加读写锁的计数器。但是我们只能在读写锁的计数器仍然大于等于0的时候，对其加1。所以我们不能直接对n加1，因为如果一个数据写入者在我们检查n和我们增加n之间潜入了，那么我们有可能在数据写入者将n设置为-1的同时，将n又加了1。所以我们只能在检查完n大于等于0，且n没有改变的前提下，将其加1。

人们通过利用特殊的原子指令来实现这一点，我们之前在看XV6中spinlock的实现时看过类似的指令（注，详见10.7中的test\_and\_set指令）。其中一个使用起来很方便的指令是compare-and-swap（CAS）。CAS接收三个参数，第一个参数是内存的某个地址，第二个参数是我们认为内存中地址持有的数值，第三个参数是我们想设置到内存地址的数值。CAS的语义是，硬件首先会设置一个内部的锁，使得一个CAS指令针对一个内存地址原子的执行；之后硬件会检查当前内存地址的数值是否还是x；如果是的话，将其设置为第三个参数，也就是x+1，之后CAS指令会返回1；如果不是的话，并不会改变内存地址的数值，并返回0。这里必须是原子性，因为这里包含了两个操作，首先是检查当前值，其次是设置一个新的数值。

> 13:50 - 16:45是个不太清晰的提问，没什么价值故略过
>
> 学生提问：有没有可能计算x的过程中，发生了一个中断？
>
> Robert教授：你是指我们在执行CAS指令之前计算它的参数吗？CAS实际上是一个指令，如果中断发生在我们计算x+1的过程中，那么意味着我们还没有调用CAS，这时包括中断在内的各种事情都可能发生。如果我们在最初读取n的时候读到0，那么不管发不发生中断，我们都会将1作为CAS的第三个参数传入，因为中断并不会更改作为本地变量的x，所以CAS的第二个和第三个参数会是0和1。如果n还是0，我们会将其设置为1，这是我们想看到的；如果n不是0，那么CAS并不会更新n。
>
> 如果这里没有使用本地变量x，那么就会有大问题了，因为n可能在任意时间被修改，所以我们

