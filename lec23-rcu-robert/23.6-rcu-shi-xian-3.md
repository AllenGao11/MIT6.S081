# 23.6 RCU实现\(3\) -

RCU实现的第三个部分，前面有同学也提到过，数据写入者会将E1的next指针从指向旧的E2切换到指向新的E2‘，但是可能有数据读取者在切换之前读到了旧的E2，并且仍然在查看旧的E2。我们需要在某个时候释放旧的E2，但是最好不要在某些数据读取者还在读的时候释放。所以我们需要等待最后一个数据读取者读完旧的E2，然后才能释放旧的E2。这就是RCU需要解决的第三个问题，数据写入者到底要等待多久才能释放E2？你可以想到好几种方法来实现这里的等待。

例如，我们可以为每个链表元素设置一个引用计数，并让数据读取者在开始使用链表元素时对引用计数加一，用完之后对应用计数减一，然后让数据写入者等待引用计数为0。但是我们会第一时间就否定这个方案，因为RCU的核心思想就是在读数据的时候不引入任何的写数据，因为我们前面看过了，如果有大量的数据读取者同时更新引用计数，相应的代价将十分高。所以我们绝对不会想要有引用计数的存在。

另一种可能是使用自带垃圾回收（Garbage Collect）的编程语言。在带有GC的编程语言中，你不用释放任何对象，相应的GC会记住是否有任何线程或者任何数据结构对于某个对象还存在引用。如果GC发现对象不可能再被使用时，就会释放对象。这也是一种可能且合理的用来释放链表元素的方法。但是使用了RCU的Linux系统，并不是由带有GC的编程语言编写，并且我们也不确定GC能不能提升性能，所以这里我们也不能使用一个标准GC来释放E2。

RCU使用的是另一种方法，数据读取者和写入者都需要遵循一个规则使得数据读者者可以稍后再释放链表元素。

* 数据读取者不允许在context switch（注，是指线程切换的context switch，详见11.4）时持有一个被RCU保护数据（也就是链表元素）的指针。所以数据读取者不能在RCU的关键区域内出让CPU。
* 对于数据写入者，它会在每一个CPU核都执行过至少一次context switch之后再释放链表元素。

![](../.gitbook/assets/image%20%28709%29.png)

这里的第一条规则也是针对spin lock的规则，在spin lock的加锁区域内是不能出让CPU的。第二条规则更加复杂点，但是相对来说也更清晰因为每个CPU核都知道自己发生了context switch，所以第二条规则是数据写入者需要等待的明确的条件。数据写入者或许要在第二条规则上等待几个毫秒的时间才能确保没有数据读取者还在使用链表元素，进而释放链表元素。

人们创造了多种技术来实现上面第二条规则中的等待，[论文](https://pdos.csail.mit.edu/6.828/2020/readings/rcu-decade-later.pdf)里面讨论的最简单的一种方法是通过调整线程调度器，使得写入线程简短的在操作系统的每个CPU核上都运行一下，这个过程中每个CPU核必然完成了一次context switching。因为数据读取者不能在context switch的时候持有数据的引用，所以经过这个过程，数据写入者已经等的足够长了。

所以数据写入者的代码实际上看起来是这样的：

* 首先完成任何对于数据的修改
* 之后调用实现了上面第二条规则synchronize\_rcu函数

