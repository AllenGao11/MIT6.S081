# 8.5 Demand paging

接下来我们将介绍Demand paging。这是另一个非常流行的功能，许多操作系统都实现了它。

我们回到exec，在未修改的XV6中，操作系统会加载程序内存的text，data区域，并且以eager的方式将这些区域加载进page table。

![](../.gitbook/assets/image%20%28269%29.png)

但是根据我们在lazy allocation和zero-filled的经验，为什么我们要以eager的方式加载到内存中？为什么不再等等，直到应用程序实际需要这些指令的时候再加载内存？程序的二进制文件可能非常的巨大，将它全部从磁盘加载到内存中将会是一个代价很高的操作，或许data区域远大于常见的场景所需要的大小，我们并不一定需要将整个二进制都加载到内存中。

所以对于exec，在虚拟地址空间中，我们为text和data分配好空间，但是相应的PTE并不对应任何物理内存page。对于这些PTE，我们只需要将valid bit位设置为0即可。

如果我们修改XV6使其按照上面的方式工作，我们什么时候会得到第一个page fault呢？或者说，用户应用程序运行的第一条指令是什么？用户应用程序在哪里启动的？

应用程序是从地址0开始运行。text区域从地址0开始向上增长。位于地址0的指令是会触发第一个page fault的指令，因为我们还没有真正的加载内存。

![](../.gitbook/assets/image%20%28296%29.png)

那么该如何处理这里的page fault呢？首先我们可以发现，这些page是on-demand page。我们之前在某个地方记录了这些page对应于某些文件，我们在page fault handler中需要从文件中读取page数据，加载到内存中；将内存page映射到page table；再重新执行指令。

![](../.gitbook/assets/image%20%28280%29.png)

之后程序就可以运行了。在最坏的情况下，用户程序使用了text中的所有内容，使用了data中的所有内容，那么我们将会在应用程序的每个page都收到一个page fault。但是如果我们幸运的话，用户程序并没有使用所有的text区域或者data区域，那么我们一方面可以节省一些物理内存，另一方面我们可以让exec运行的更快（注，因为不需要为整个程序分配内存），只要程序启动了就能立即运行，我们基本上不用在exec中做任何工作。

前面描述的流程其实是有点问题的。我们将要读取的文件，它的text和data区域可能大于物理内存的容量。又或者多个应用程序按照demand paging的方式启动，它们二进制文件的和大于实际物理内存的容量。对于demand paging来说，如果内存耗尽了或者说OOM了，这个时候如果得到了一个page fault，一些内容需要从文件系统拷贝到内存中，但这时你又没有任何可用的物理内存page，你需要有某些行为。这回到了之前的一个问题：在lazy allocation中，如果内存耗尽了该如何办？

如果内存耗尽了，一个选择是撤回page。比如说将page中的内容写回到文件系统再撤回page。比如说，如果是一个修改过的data page，你可以将它写回到文件系统。一旦你撤回并释放了page，那么你就有了一个新的空闲的page，你可以使用这个刚刚空闲出来的page，用到刚刚的page fault handler中，再重新执行指令。

![](../.gitbook/assets/image%20%28284%29.png)

重新运行指令稍微有些复杂，这包含了整个userret函数背后的机制以及将程序运行切换回用户空间等等。

以上就是常见操作系统的行为。这里的关键问题是，什么样的page可以被撤回？该使用什么样的策略来撤回page？

> 学生回答：Least Recently Used

是的，这是最常用的策略，Least Recently Used，或者叫LRU。基于这个策略，还有一些小的优化。如果你要撤回一个page，你需要在dirty page和non-dirty page中做选择。dirty page是曾经被写过的page，而non-dirty page是只被读过，但是没有被写过的page。你们会选择哪个来撤回？

> 学生回答：我会选择dirty page，因为它在某个时间点会被重新写回到内存中。

是的，如果dirty page之后再被修改，但是现在你或许需要对它写两次了。现实中会选择non-dirty page，你不用做任何操作就可以重新使用它。如果它出现在page table1中，你将它标记为non-valid，这就完成了所有的工作了，之后你就可以在另一个page table重复使用这个page。所以通常来说这里优先会选择non-dirty page来撤回。

> 学生提问：在一个cache中，我们有一些内存，之后我们可以说一行是dirty，因为它还没有写入到内存中。那么在内存中的page呢？它怎么就是dirty了？它在什么时候需要回写？它就是存在于内存中，而不存在于其他地方。那么它什么时候会变成dirty呢？
>
> Frans教授：对于memory mapped files，你将一个文件映射到内存中，然后恢复它，你就会设置内存page为dirty。
>
> 学生提问：所以这只对一个不仅映射了内存，还映射了文件的page有效？
>
> Frans教授：是的，完全正确。

如果你们再看PTE，我们有RSW位，你们可以发现在bit7，对应的就是Dirty bit。当硬件向一个page写入数据，会设置dirty bit，之后操作系统就可以发现这个page曾经被写入了。类似的，还有一个Access bit，任何时候一个page被读或者被写了，这个Access bit会被设置。

![](../.gitbook/assets/image%20%28253%29.png)

为什么这两个信息重要呢？它们能怎样帮助内核呢？

> 学生回答：没有被Access过的page可以直接撤回，是吗？

是的，或者说如果你想实现LRU



