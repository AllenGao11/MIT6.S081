# 8.2 Lazy page allocation

我们首先来看一下allocation，或者更具体的说sbrk。sbrk是XV6提供的系统调动，它使得用户应用程序能扩大自己的heap。当一个应用程序启动的时候，sbrk指向的是heap的最底端，stack的最顶端。同时这也是_p-&gt;sz_指向的位置。

![](../.gitbook/assets/image%20%28316%29.png)

当调用sbrk时，它的参数是整数，代表了你想要申请的page数量。sbrk会扩展stack的上边界（也就是会扩大stack）。

![](../.gitbook/assets/image%20%28309%29.png)

这意味着，当sbrk实际发生或者被调用的时候，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间，然后将内存内容初始化为0，再返回sbrk系统调用。这样，应用程序可以通过多次调用sbrk系统调用来增加它所需要的内存。类似的，应用程序还通过给sbrk传入负数作为参数，来减少或者压缩它的地址空间。现在我们只关注增加地址空间的场景。

在XV6中，sbrk实现的是eager allocation。这表示了，一旦调用了sbrk，内核会立即分配应用程序需要的物理内存。但是实际上，对于应用程序来说很难预测自己需要多少内存，所以通常来说，应用程序倾向于申请多于自己所需要的内存。这意味着，地址空间会增加许多，但是有部分内存永远也不会被应用程序所使用到。你或许会认为这里很蠢，怎么可以这样呢？你可以设想自己写了一个应用程序，读取了一些输入，通过一个矩阵进行一些运算。你需要为最坏的情况做准备，比如说为最大可能的矩阵分配内存，但是应用程序可能永远也用不上这些内存，通常情况下，应用程序会在一个小得多的矩阵上进行运算。所以，程序员过多的申请内存但是过少的使用内存，这种情况还挺常见的。

原则上来说，这不是一个大问题。但是使用虚拟内存和page fault handler，我们完全可以以某种更聪明的方法来解决这里的问题。这里就是通过lazy allocation来实现，核心思想非常简单，sbrk系统调基本上不做任何事情，唯一需要做的事情就是提升_p-&gt;sz_，将_p-&gt;sz_增加n，其中n是需要新分配的内存page数量。但是内核在这个时间点并不会分配任何物理内存。之后在某个时间点，应用程序使用到了新申请的那部分内存，这会触发page fault，因为我们还没有将新申请的内存映射到page table。所以，如果我们解析一个大于旧的_p-&gt;sz_，但是又小于新的_p-&gt;sz（注，也就是旧的p-&gt;sz + n）_的虚拟地址，我们希望内核能够分配一个内存page，并且重新执行指令。

所以，当我们看到了一个page fault，相应的虚拟地址小于当前_p-&gt;sz_，同时大于stack，那么我们就知道这是一个来自于heap的地址，但是内核还没有分配任何物理内存。所以对于这个page fault的响应也理所当然直接明了：在page fault handler中，通过kalloc函数分配一个内存page；初始化这个page；将这个page映射到user page table中；最后重新执行指令。比方说，如果是load指令，或者store指令要访问属于当前进程但是还未被分配的内存，在我们映射完新申请的物理内存page之后，重新执行指令应该就能通过了。

![](../.gitbook/assets/image%20%28249%29.png)

> 学生提问：在eager allocation的场景，一个进程可能消耗了太多的内存进而耗尽了物理内存资源。如果我们不使用eager allocation，而是使用lazy allocation，应用程序怎么才能知道当前已经没有物理内存可用了？
>
> Frans教授：这是个非常好的问题。从应用程序的角度来看，会有一个错觉：存在无限多的物理内存。但是在某个时间点，应用程序可能会用光了物理内存，之后如果应用程序再访问一个未被分配的page，但这时又没有物理内存，这时内核可以有两个操作，我稍后会介绍更复杂的那个操作。你们在lazy lab中要做的是，返回一个错误并杀掉进程。因为现在已经OOM（Out Of Memory）了，内核也无能为力，所以在这个时间点可以杀掉进程。
>
> 在这节课稍后的部分会介绍，可以有更加精致的解决方案。我认为这个问题带出了一个话题，我们在一个操作系统上有一系列运行的进程，但是物理内存数量是有限的。物理内存必须以某种方式在应用程序之间共享。我们稍后会详细看这块。
>
> 学生提问：如何判断一个地址是新分配的内存还是一个无效的地址？
>
> Frans教授：在地址空间中，我们有stack，data和text。通常来说我们将p-&gt;sz设置成一个较大的数，新分配的内存位于旧的p-&gt;sz和新的p-&gt;sz之间，但是这部分内存还没有在物理上进行分配。如果使用的地址低于p-&gt;sz，那么这是一个用户空间的有效地址。如果大于p-&gt;sz，对应的就是一个程序错误，这意味着用户应用程序在尝试解析一个自己不拥有的内存地址。希望这回答了你的问题。
>
> 学生提问：为什么我们需要杀掉进程？操作系统不能只是返回一个错误说现在已经OOM了，尝试做一些别的操作吧。
>
> Frans教授：让我们稍后再回答这个问题。在page fault中我们会直接杀掉进程，但是这里的处理可以更加聪明。实际的操作系统的处理都会更加聪明，尽管如此，如果最终还是找不到可用内存，实际的操作系统还是可能会杀掉进程。

为了进一步理解lazy allocation，我们大概来看一下它的代码会是怎么样？这也是今天唯一编程相关的内容。实际上你可能会感到奇怪相关的代码是如此的简单，并且这部分对于接下来的lazy lab或许会有很大的帮助。

我们首先要修改的是sys\_sbrk函数，sys\_sbrk会完成实际增加应用程序的地址空间，分配内存等等一系列相关的操作。

![](../.gitbook/assets/image%20%28237%29.png)

这里我们要修改这个函数，让它只对p-&gt;sz加n，并不执行增加内存的操作。

![](../.gitbook/assets/image%20%28270%29.png)

所以这里，只会对虚拟地址空间增加n。之后启动XV6，并且执行“echo hi”，我们会得到一个page fault。

![](../.gitbook/assets/image%20%28269%29.png)

之所以会得到一个page fault是因为，Shell会先fork一个进程，子进程会通过exec执行echo（注，详见1.9）。在这个过程中，Shell会申请一些内存，所以Shell会调用sys\_sbrk，然后就出错了（注，因为前面修改了代码，调用sys\_sbrk不会实际分配所需要的内存）。

这里输出的内容包含了一些有趣的信息。这里输出了SCAUSE寄存器内容，我们可以看到它的值是15，表明这是一个store page fault（详见8.1）。我们可以看到进程的pid是3，这极可能是Shell的pid。我们还可以看到SEPC寄存器的值，是0x12a4。最后还可以看到出错的虚拟内存地址，也就是STVAL寄存器的内容，0x4008。

我们可以查看Shell的汇编代码，这是由makefile创建的。我们搜索SEPC对应的地址，可以看到这的确是一个store指令。这看起来就是我们出现page fault的位置。

![](../.gitbook/assets/image%20%28313%29.png)

如果我们向前看看汇编代码，我们可以看到这里实际上是在malloc实现的代码中。这也非常合理，在malloc的实现中，我们使用sbrk系统调用来获得一些内存，之后会初始化我们刚刚获取到的内存，在0x12a4位置，我们向size字段写入一些数据，但是现在我们实际上在向未被分配的内存写入数据。

另一个可以证明内存还没有分配的地方是，XV6中Shell通常是有4个page，包含了text和data。出错的地址在4个page之外，也就是第5个page，实际上我们在4个page之外8个字节。这也合理，因为在0x12a4对应的指令中，a0持有的是0x4000，而8相对a0的偏移量。偏移之后的地址就是我们想要使用的地址。

以上就是page fault的信息。我们想要做的是，稍微更加聪明的处理方式。

