# 8.2 Lazy page allocation

接下来我将看一下RISC-V提供的基本的机制和基本的信息，并且我想过一个功能清单，来帮助我们理解如何能够使用page fault handler来修复page table并做一些有趣的事情。

我们首先来看一下allocation，或者更具体的说sbreak。sbreak是XV6提供的系统调动，它使得用户应用程序能扩大自己的heap。当一个应用程序启动的时候，sbrk指向的是heap的最底端，stack的最顶端。同时这也是p-&gt;sz指向的位置。

![](../.gitbook/assets/image%20%28307%29.png)

当调用sbrk时，比如以参数12345调用，它的参数代表了你想要分配的page数量，sbrk会扩展stack的上边界。

![](../.gitbook/assets/image%20%28305%29.png)

这意味着，当sbrk实际发生或者被调用的时候，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间，然后将内存内容初始化为0，再返回sbrk系统调用。这样，应用程序可以通过多次调用sbrk系统调用来增加它所需要的内存。类似的，应用程序还通过给sbrk传入负数作为参数，来减少或者压缩它的地址空间。但是现在我们只关注增加地址空间。

在XV6中，sbrk实现的是eager allocation。这表示了，一旦调用了sbrk，内核会立即分配应用程序需要的物理内存。但是实际上，对于应用程序来说很难预测自己需要多少内存，所以通常来说，应用程序倾向于申请多于自己所需要的内存。这意味着，地址空间会增加许多，但是有部分内存永远也不会被应用程序所使用。你或许会认为这里很蠢，怎么能这样呢？你可以设想你写了一个应用程序，读取了一些输入，通过一个矩阵进行一些运算，你需要为最坏的情况做准备，比如说为最大的矩阵分配内存，但是应用程序可能永远也用不上这些内存，通常情况下，应用程序会在一个小得多的矩阵上进行运算。所以，程序员过多的申请内存，但是过少的使用内存这种情况还挺常见的。

原则上来说，这不是一个大问题。但是使用虚拟内存和page fault handler，我们完全可以以某种更聪明的方法来应对这个情况，也就是通过lazy allocation来实现。这里的核心思想非常简单，sbrk系统调基本不做任何事情，唯一需要做的事情就是提升p-&gt;sz。将p-&gt;sz增加n，其中n是需要新分配的内存数量。但是内核在这个时间点并没有分配任何物理内存。之后在某个时间点，应用程序将会使用新申请的那部分内存，这会触发page fault，因为我们还没有将新申请的内存映射到page table。所以，如果我们解析一个大于_p-&gt;sz_，但是又小于_p-&gt;sz + n_的虚拟地址，我们希望有的结果是内核分配一个内存page，并且重新执行指令。

所以，当我们看到了一个page fault，相应的虚拟地址小于p-&gt;sz，同时大于stack，那么我们就知道这是一个来自于heap的地址，但是内核还没有分配任何物理内存。所以对于这个page fault的响应也理所当然的直接明了：在page fault handler中，通过kalloc函数分配一个内存page；初始化这个page；将这个page映射到page table中；最后重新执行指令。比方说，如果是load指令，或者store指令要访问属于当前进程但是还未被分配的内存，在我们映射完新申请额物理内存page之后，重新执行指令应该就能通过了。

![](../.gitbook/assets/image%20%28246%29.png)

> 学生提问：在eager allocation的场景，一个进程可能消耗了太多的内存进而耗尽了物理内存资源。如果我们不使用eager allocation，而是使用lazy allocation，应用程序怎么才能知道当前已经没有物理内存可用了？
>
> Frans教授：这是个非常好的问题。从应用程序的角度来看，会有一个错觉：存在无限多的物理内存。在某个时间点，应用程序可能会用光了物理内存，之后如果应用程序再访问一个未被分配的page，但这时又没有物理内存，这时内核可以有两个操作，我稍后会介绍更复杂的那个操作。你们在lazy lab中要做的是，返回一个错误并杀掉进程。所以因为现在已经OOM了，内核也无能为力，所以在这个时间点可以杀掉进程。
>
> 在这节课稍后的部分会介绍，可以有更加精致的解决方案。我认为这个问题带出了一个话题，我们在一个操作系统上有一系列运行的进程，但是物理内存数量是有限的。物理内存必须以某种方式在应用程序之间共享。我们稍后会详细看这块。





