# 8.2 Lazy page allocation

我们首先来看一下allocation，或者更具体的说sbrk。sbrk是XV6提供的系统调动，它使得用户应用程序能扩大自己的heap。当一个应用程序启动的时候，sbrk指向的是heap的最底端，stack的最顶端。同时这也是_p-&gt;sz_指向的位置。

![](../.gitbook/assets/image%20%28321%29.png)

当调用sbrk时，它的参数是整数，代表了你想要申请的page数量。sbrk会扩展stack的上边界（也就是会扩大stack）。

![](../.gitbook/assets/image%20%28318%29.png)

这意味着，当sbrk实际发生或者被调用的时候，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间，然后将内存内容初始化为0，再返回sbrk系统调用。这样，应用程序可以通过多次调用sbrk系统调用来增加它所需要的内存。类似的，应用程序还通过给sbrk传入负数作为参数，来减少或者压缩它的地址空间。现在我们只关注增加地址空间的场景。

在XV6中，sbrk实现的是eager allocation。这表示了，一旦调用了sbrk，内核会立即分配应用程序需要的物理内存。但是实际上，对于应用程序来说很难预测自己需要多少内存，所以通常来说，应用程序倾向于申请多于自己所需要的内存。这意味着，地址空间会增加许多，但是有部分内存永远也不会被应用程序所使用到。你或许会认为这里很蠢，怎么可以这样呢？你可以设想自己写了一个应用程序，读取了一些输入，通过一个矩阵进行一些运算。你需要为最坏的情况做准备，比如说为最大可能的矩阵分配内存，但是应用程序可能永远也用不上这些内存，通常情况下，应用程序会在一个小得多的矩阵上进行运算。所以，程序员过多的申请内存但是过少的使用内存，这种情况还挺常见的。

原则上来说，这不是一个大问题。但是使用虚拟内存和page fault handler，我们完全可以以某种更聪明的方法来解决这里的问题。这里就是通过lazy allocation来实现，核心思想非常简单，sbrk系统调基本上不做任何事情，唯一需要做的事情就是提升_p-&gt;sz_，将_p-&gt;sz_增加n，其中n是需要新分配的内存page数量。但是内核在这个时间点并不会分配任何物理内存。之后在某个时间点，应用程序使用到了新申请的那部分内存，这会触发page fault，因为我们还没有将新申请的内存映射到page table。所以，如果我们解析一个大于旧的_p-&gt;sz_，但是又小于新的_p-&gt;sz（注，也就是旧的p-&gt;sz + n）_的虚拟地址，我们希望内核能够分配一个内存page，并且重新执行指令。

所以，当我们看到了一个page fault，相应的虚拟地址小于当前_p-&gt;sz_，同时大于stack，那么我们就知道这是一个来自于heap的地址，但是内核还没有分配任何物理内存。所以对于这个page fault的响应也理所当然直接明了：在page fault handler中，通过kalloc函数分配一个内存page；初始化这个page；将这个page映射到user page table中；最后重新执行指令。比方说，如果是load指令，或者store指令要访问属于当前进程但是还未被分配的内存，在我们映射完新申请的物理内存page之后，重新执行指令应该就能通过了。

![](../.gitbook/assets/image%20%28260%29.png)

> 学生提问：在eager allocation的场景，一个进程可能消耗了太多的内存进而耗尽了物理内存资源。如果我们不使用eager allocation，而是使用lazy allocation，应用程序怎么才能知道当前已经没有物理内存可用了？
>
> Frans教授：这是个非常好的问题。从应用程序的角度来看，会有一个错觉：存在无限多的物理内存。但是在某个时间点，应用程序可能会用光了物理内存，之后如果应用程序再访问一个未被分配的page，但这时又没有物理内存，这时内核可以有两个操作，我稍后会介绍更复杂的那个操作。你们在lazy lab中要做的是，返回一个错误并杀掉进程。因为现在已经OOM（Out Of Memory）了，内核也无能为力，所以在这个时间点可以杀掉进程。
>
> 在这节课稍后的部分会介绍，可以有更加精致的解决方案。我认为这个问题带出了一个话题，我们在一个操作系统上有一系列运行的进程，但是物理内存数量是有限的。物理内存必须以某种方式在应用程序之间共享。我们稍后会详细看这块。
>
> 学生提问：如何判断一个地址是新分配的内存还是一个无效的地址？
>
> Frans教授：在地址空间中，我们有stack，data和text。通常来说我们将p-&gt;sz设置成一个较大的数，新分配的内存位于旧的p-&gt;sz和新的p-&gt;sz之间，但是这部分内存还没有在物理上进行分配。如果使用的地址低于p-&gt;sz，那么这是一个用户空间的有效地址。如果大于p-&gt;sz，对应的就是一个程序错误，这意味着用户应用程序在尝试解析一个自己不拥有的内存地址。希望这回答了你的问题。
>
> 学生提问：为什么我们需要杀掉进程？操作系统不能只是返回一个错误说现在已经OOM了，尝试做一些别的操作吧。
>
> Frans教授：让我们稍后再回答这个问题。在page fault中我们会直接杀掉进程，但是这里的处理可以更加聪明。实际的操作系统的处理都会更加聪明，尽管如此，如果最终还是找不到可用内存，实际的操作系统还是可能会杀掉进程。

为了进一步理解lazy allocation，我们大概来看一下它的代码会是怎么样？这也是今天唯一编程相关的内容。实际上你可能会感到奇怪相关的代码是如此的简单，并且这部分对于接下来的lazy lab或许会有很大的帮助。

我们首先要修改的是sys\_sbrk函数，sys\_sbrk会完成实际增加应用程序的地址空间，分配内存等等一系列相关的操作。

![](../.gitbook/assets/image%20%28238%29.png)

这里我们要修改这个函数，让它只对p-&gt;sz加n，并不执行增加内存的操作。

![](../.gitbook/assets/image%20%28274%29.png)

所以这里，只会对虚拟地址空间增加n。之后启动XV6，并且执行“echo hi”，我们会得到一个page fault。

![](../.gitbook/assets/image%20%28273%29.png)

之所以会得到一个page fault是因为，Shell会先fork一个进程，子进程会通过exec执行echo（注，详见1.9）。在这个过程中，Shell会申请一些内存，所以Shell会调用sys\_sbrk，然后就出错了（注，因为前面修改了代码，调用sys\_sbrk不会实际分配所需要的内存）。

这里输出的内容包含了一些有趣的信息。这里输出了SCAUSE寄存器内容，我们可以看到它的值是15，表明这是一个store page fault（详见8.1）。我们可以看到进程的pid是3，这极可能是Shell的pid。我们还可以看到SEPC寄存器的值，是0x12a4。最后还可以看到出错的虚拟内存地址，也就是STVAL寄存器的内容，0x4008。

我们可以查看Shell的汇编代码，这是由makefile创建的。我们搜索SEPC对应的地址，可以看到这的确是一个store指令。这看起来就是我们出现page fault的位置。

![](../.gitbook/assets/image%20%28319%29.png)

如果我们向前看看汇编代码，我们可以看到这里实际上是在malloc实现的代码中。这也非常合理，在malloc的实现中，我们使用sbrk系统调用来获得一些内存，之后会初始化我们刚刚获取到的内存，在0x12a4位置，我们向size字段写入一些数据，但是现在我们实际上在向未被分配的内存写入数据。

另一个可以证明内存还没有分配的地方是，XV6中Shell通常是有4个page，包含了text和data。出错的地址在4个page之外，也就是第5个page，实际上我们在4个page之外8个字节。这也合理，因为在0x12a4对应的指令中，a0持有的是0x4000，而8相对a0的偏移量。偏移之后的地址就是我们想要使用的地址。

以上就是page fault的信息。我们想要做的是，比现在稍微更聪明的处理方式。

首先查看trap.c中的usertrap函数，usertrap在lec06中有介绍。在usertrap中根据不同的SCAUSE完成不同的操作。

![](../.gitbook/assets/image%20%28322%29.png)

在lec06中，我们是因为SCAUSE == 8进入的trap，这是我们处理普通系统调用的代码。如果不是SCAUSE不等于8，会检查是否有任何的设备中断，之后会处理相关的设备中断。如果两个条件都不满足，这里会打印一些信息，并且杀掉进程。

现在我们需要增加一个检查，判断SCAUSE == 15，如果符合条件，我们需要一些定制化的处理。我们这里想要做什么样的定制化处理呢？

> 学生回答：我们想要检查p-&gt;sz是否大于当前存在STVAL寄存器中的虚拟地址。如果大于的话，再来分配内存。

这是一种处理方式。这里我会以演示为目的简单的处理一下，在lazy lab中你们需要完成更多的工作。（注，下图中多了一个“} else {”）

![](../.gitbook/assets/image%20%28331%29.png)

首先，打印一些调试信息。之后分配一个物理内存page，如果ka等于0，表明没有物理内存我们现在OOM了，我们会杀掉进程。如果有物理内存，首先会将内存内容设置为0，之后将物理内存page指向用户地址空间中合适的虚拟内存地址。具体来说，我们将物理内存page指向向下取整的虚拟地址。所以，这里引起page fault的地址是0x4008，物理内存page对应的虚拟地址是0x4000。之后需要设置常用的权限标志位，也就是u，w，r bit位。

接下来运行一些这部分代码。重新编译XV6，再执行“echo hi”，我们或许可以乐观的认为现在可以正常工作了。

![](../.gitbook/assets/image%20%28271%29.png)

但是实际上并没有正常工作。我们这里有两个page fault，第一个对应的虚拟内存地址是0x4008，但是很明显在处理这个page fault时，我们有另一个page fault 0x13f48。现在唯一的问题是，uvmunmap在报错，一些它尝试unmap的page并没有map上。这里可能的原因是什么？你认为我们这里看到panic的原因是什么？这里unmap的内存是什么？

> 学生回答：之前lazy allocation但是又没有实际分配的内存。

是的，完全正确。这里unmap的是之前lazy allocated，但是又还没有用到的地址。所以对于这个内存，并没有对应的物理内存。所以在这里，当PTE的v标志位为0，还没有对应的mapping，这并不是一个实际的panic。这是我们预期的行为。

![](../.gitbook/assets/image%20%28225%29.png)

实际上，对于这个page我们并不用做任何事情，我们可以直接continue跳到下一个page。

![](../.gitbook/assets/image%20%28240%29.png)

接下来，我们再重新编译XV6，并执行“echo hi”。

![](../.gitbook/assets/image%20%28289%29.png)

现在我们可以看到2个page fault，但是echo hi正常工作了。现在，我们一定程度上有了最基本最简单的lazy allocation。这里有什么问题吗？

> 学生提问：我并不能理解为什么在uvmunmap中可以直接改成continue？
>
> Frans教授：之前的panic表明，我们尝试在释放一个并没有map的page。怎么会发生这种情况呢？唯一的原因是sbrk增加了p-&gt;sz，但是应用程序并没有使用那部分内存。所以这部分新增加的内存的确没有映射关系，因为对应的物理内存还没有分配，因为我们现在是lazy allocation，我们只会为需要的内存分配物理内存page。如果我们不需要这部分内存，那么就不会存在map关系，这非常的合理。相应的，我们对于这部分内存也不能释放，因为没有实际的物理内存可以释放，所以这里最好的处理方式就是continue，跳过并处理下一个page。
>
> 学生提问：在uvmunmap中，我认为之前的panic存在是有理由的，所以一个更正确的实现方式是有两个版本，我们使用的是不panic的那个版本。
>
> Frans教授：为什么之前的panic会存在？对于未修改的XV6，永远也不会出现用户内存未map的情况，所以一旦出现这种情况需要panic。但是现在我们更改了XV6，所以我们需要去掉这里的panic，因为之前的不可能变成了可能。

这部分内容对于下一个实验有很大的帮助，实际上这是下一个实验3个部分中的一个，但是很明显这部分不足以完成下一个lazy lab。我们这里做了一些修改，但是很多地方还是有可能出错。就像有人提到的，我这里并没有检查触发page fault的虚拟地址是否小于p-&gt;sz。还有其他的可能出错的地方吗？

