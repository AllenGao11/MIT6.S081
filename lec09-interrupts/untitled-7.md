# Untitled

最后我想介绍一下Interrupt在最近几十年的演进。当Unix被开发出来的时候，Interrupt还是很快的。这使得修改硬件变得很简单，当外设有数据需要处理时，硬件可以中断CPU的执行，并让CPU处理硬件的数据。

而现在，中断变慢了。从前面的介绍可以看出来这一点。需要很多步骤才能真正的处理中断数据。如果一个设备正在高速的产生中断，处理器将会很难跟上。所以如果查看现在的设备，可以发现，设备做了更多的工作。所以在产生中断之前，设备上会执行大量的操作。这样可以避免太过频繁的中断处理器。

如果你真的有一个高性能的设备，例如你有一个千兆网卡，这个网卡收到了大量的小包，网卡每秒可以生成1.5Mpps，这意味着每一个微秒，CPU都需要处理一个中断。这超过了CPU的处理能力，所以需要一个其他的处理方式。当网卡收到了大量的包，并且处理器不能处理这么多中断的时候该怎么办呢？

这里的解决方法就是使用polling。除了依赖Interrupt，CPU可以一直读取外设的控制寄存器，来检查是否有数据。对于UART来说，我们可以一直读取RHR寄存器，来检查是否有数据。现在，CPU不停的在轮询设备，直到设备有了数据。

这种方法浪费了CPU cycles，当我们在使用CPU不停的检查寄存器的内容时，我们并没有用CPU来运行任何程序。在我们之前的例子中，如果没有数据，内核会让Shell进程sleep，这样可以运行另一个进程。

所以，对于一个慢设备，你肯定不想一直轮询它来得到数据。我们想要在没有数据的时候切换出来运行一些其他程序。但是如果是一个快设备，那么Interrupt的overhead也会很高，那么我们在polling设备的时候，是经常能拿到数据的，这样可以节省进出中断的代价。

所以对于一个高性能的网卡，如果有大量的包要传入，那么应该用polling。对于一些精心设计的驱动，它们会在polling和Interrupt之间动态切换。

![](../.gitbook/assets/image%20%28381%29.png)

> 学生提问：uartinit只被调用了一次，所以才导致了所有的CPU核都共用一个buffer吗？
>
> Frans教授：因为只有一个UART设备，一个buffer只针对一个UART设备，而这个buffer会被所有的CPU核共享，这样运行在多个CPU核上的多个程序可以同时向Console打印输出，而驱动中是通过锁来确保多个CPU核上的程序串行的向Console打印输出。
>
> 学生提问：我们之所以需要锁是因为有多个CPU核，但是却只有一个Console，对吧？
>
> Frans教授：是的，如我们之前说的驱动的top和bottom部分可以并行的运行。所以一个CPU核可以执行uartputc函数，而另个一CPU核可以执行uartintr函数，我们需要确保它们是串行执行的，而锁确保了这一点。
>
> 学生提问：那是不是意味着，某个时间，其他所有的CPU核都需要等待某一个CPU核的处理？
>
> Frans教授：这里并不是死锁。其他的CPU核还是可以在等待的时候运行别的进程。

