# 5.1 C程序到汇编程序的转换

（00:00 - 05:25 在讨论syscall lab，没有什么实质内容故跳过）

今天的课程，我们会稍微讨论C语言转换到汇编语言的过程，以及处理器相关的内容。今天的课程更多偏向的是实际应用，或者至少我们的目标是这样。所以这节课的目标是让你们熟悉RISC-V处理器，汇编语言，以及RISC-V的calling convention。对于page table来说这些内容不太重要，但是对于这周要发布的traps lab来说，这些内容至关重要，因为在这个实验中你们将会频繁用到trapframe（注，XV6用来实现trap的一个内存page，lecture 6有详细内容）和栈。这些就是今天这节课的主要内容。

![](../.gitbook/assets/image5.1-01.png)

我们首先来简单看一下C语言是如何转换成汇编语言的。这部分内容有点像是对你们之前学过的6.004或者任意其他计算机架构课程的简单回顾。

通常来说，我们的C语言程序会有一个main函数，假设在这个函数内你执行了一些打印然后退出了。

![](../.gitbook/assets/image%20%28232%29.png)

目前看起来都还不错。但是如果你学过了6.004的话，你应该知道，处理器并不能理解C语言。处理器能够理解的是汇编语言，或者更具体的说，处理器能够理解的是二进制编码之后的汇编代码。

在下面这张图中，我从一个SiFive（注，一家基于RISC-V处理器的厂商）主板上圈出了一个实际的RISC-V处理器。

![](../.gitbook/assets/image%20%28261%29.png)

当我们说到一个RISC-V处理器时，意味着这个处理器能够理解RISC-V的指令集。所以，任何一个处理器都有一个关联的ISA（Instruction Sets Architecture），ISA就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。上图中的处理器正好能理解RISC-V汇编语言，而C语言会编译成汇编语言。

所以通常来说，要让C语言能够运行在你的处理器之上。我们首先写出C程序，之后这个程序被编译成汇编语言。这个过程中有一些链接和其他的步骤，但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。之后汇编语言会被翻译成二进制文件也就是.obj或者.o文件。

![](../.gitbook/assets/image%20%28259%29.png)

如果你们曾经注意过你们的lab目录，在运行完make  qemu之后你会看到一些.o文件，这些就是处理器能够理解的文件。虽然你还没有写任何汇编程序，你们也可以在目录中看到一些asm文件，这是由C语言编译生成的。如果你们学过了6.004，那么你们必然已经看过一些汇编语言。

汇编语言不具备C语言的组织结构，在汇编语言中你只能看到一行行的指令，比如add，mult等等。汇编语言中没有很好的控制流程，没有循环，虽然有函数但是与你们知道的C语言函数不太一样，汇编语言中的函数是以label的形式存在而不是真正的函数定义。汇编语言是一门非常底层的语言，许多其他语言，比如C++，都会编译成汇编语言。运行任何编译型语言都需要先生成汇编语言。

以上就是让计算机能够理解我们的C代码的基本流程。你们将会注意到，我们在这节课中反复会提到了RISC-V汇编。这一点很重要，因为汇编语言有很多种。如果你使用RISC-V，你不太能将Linux运行在上面。相应的，大多数现代的计算机都运行在x86和x86-64处理器上。x86是一种不同的ISA，不同的指令集，看起来与RISC-V非常相似，通常你们的个人电脑上运行的都是x86。Intel和AMD的CPU实现了x86。

![](../.gitbook/assets/image%20%28283%29.png)

RISC-V和x86并没有它们第一眼看起来那么相似。RISC-V中的RISC是Reduced Instruction Set Computer，而x86通常被称为CISC，Complex Instruction Set Computer。这两者有一些关键的区别：

* 指令的数量。实际上，创造RISC-V的一个大的初衷就是因为Intel手册中指令数量太多了。
  * x86-64由3个文档组成，并且新的指令以每个月3条指令的速度在增加。因为x86-64是在1970年代发布的，所以我认为现在有大于15000条指令。
  * RISC-V由两个文档组成，在这节课中，不需要你们记住每一个RISC-V指令，但是如果你感兴趣的话或者你发现你不能理解某个具体的指令，在课程网站的参考页面会有RISC-V的特殊权限指令和普通权限指令。这两个文档包含了RISC-V的指令集的所有信息，分别是240页和135页，相比x86的指令集文档要小得多的多。这是有关RISC-V比较好的一个方面。所以在RISC-V中，我们有更少的指令数量，除此之外，指令也更加简单。在x86-64中，有大量的指令完成了多件事情。它们执行了一些复杂的操作集合并返回了结果给你。但是RISC-V不会这样做，RISC-V的指令趋向于完成更简单的工作，相应的也消耗更少的CPU执行时间。这其实是设计人员的底层设计的取舍。并没有一些真理性的原因说RISC比CISC更好。它们各自有各自的使用场景。
  * 相比x86来说，RISC另一件有意思的事情是它是开源的。这是市场上唯一的一款开源指令集，这意味着任何人都可以为RISC-V开发主板。RISC-V是来自于UC-Berkly的一个研究项目，之后被大量的公司选中并做了支持，网上有这些公司的名单，许多公司对于支持一个开源指令集都感兴趣。我记得最近，作为主要的RISC-V处理器生产商，SiFive宣称会发布一款适用于个人计算机的主板，用来在个人计算机上，通过RISC-V处理器运行Linux系统。如果你好奇或者想要使用RISC-V，在你学完了6.S081之后，大概率你可以在你的个人电脑上通过RISC-V处理器上运行Linux。
  * 不过在你们的日常生活中，你们可能在完全不知情的情况下使用了RISC。比如说ARM也是一个RISC，高通的Snapdragon处理器就是基于ARM。如果你使用一个Android手机，那么大概率你的手机运行在RISC上。如果你使用IOS，苹果公司也实现某种版本的ARM，这些处理器运行在iPad，iPhone和大多数苹果移动设备上，甚至对于Mac，苹果公司也在尝试向ARM做迁移（注，刚刚发布的Macbook）。所以精简指令集出现在所有的地方。如果你想在现实世界中找到RISC-V，你可以在一些嵌入式设备中找到。所以RISC-V是有应用的，当然它可能没有x86那么流行。在最近几年，精简指令集的使用越来越多，由于Intel的指令集是在是太大了。Intel的指令集之所以这么大，是因为Intel对于向后兼容非常看重。所以一个现代的Intel处理器可以运行30/40年前的指令。Intel并没有下线任何指令。而RISC-V更加新，所以不存在这个问题。

> 学生提问：为什么x86会有15000条指令？
>
> TA：如我刚刚说的，我们需要许多指令来实现向后兼容，向后兼容是否重要因人而异。我认为这里大部分指令都是cmd指令，用来完成一些特殊的操作。我从来没有见过一个Intel的汇编代码使用了所有的15000个指令。大多数这些指令都是为了向后兼容和cmd的需求创建。

* 如果查看RISC-V的文档，RISC-V是特殊的，它区分了Base Integer Instruction Set，这里包含了所有的常用指令，比如add，mult。除此之外，处理器可以选择实现许多其他的模块。例如，一个处理器可以选择支持Standard Extension for Single-Precision Float-Point。这种模式使得RISC-V更容易支持向后兼容。 你可以声明支持了哪些扩展模块，然后编译器可以根据支持的模块来编译代码。

> 学生提问：看起来使用x86而不是RISC-V的唯一优势就是能得到性能的提升，但是这里的性能是以复杂度和潜在的安全为代价的，我的问题是为什么我们还在使用x86，而不是使用RISC-V处理器？
>
> TA：我并没有一个很好的答案来解释。现在整个世界都运行在x86上，如果你突然将处理器转变成RISC-V，那么你就会失去很多重要部分的支持。同时，Intel在它的处理器里面做了一些有意思的事情，例如安全相关的enclave，这是Intel最近加到处理器中来提升安全性的功能。Intel实现的一些其他指令非常的具体，可以非常高效的进行一些特定的运算。所以Intel有非常多的指令，通常来说对于一个场景来说都有一个完美的指令，执行效率要高于RISC-V中的同等指令。但是更实际的答案是，RISC-V相对来说更新一些，目前还没有人基于RISC-V来制造个人计算机，SiFive也就是最近才成为第一批将RISC-V应用到个人计算机的公司。所以，从实际的角度来说，不能在RISC-V上运行所有为Intel设计的软件，是我对这个问题的最好的答案。

![](../.gitbook/assets/image%20%28276%29.png)

