# 6.1

今天我想讨论一下，用户代码到内核执行之间的转换。每当

* 程序执行系统调用
* 程序出现了类似页缺失（page fault）、运算时除以0
* 一个设备触发了中断使得当前程序需要响应内核设备驱动

都会发生这样的转换。

这里从user到kernel空间的陷阱（trap）涉及了许多细心的设计和重要的细节。这些细节对于实现安全隔离和性能来说非常重要，因为很多应用程序的执行，要么因为系统调用，要么因为页缺失，都会频繁的转换到内核中。所以，trap机制要尽可能的简单，这一点非常重要。

初始的场景你们已经非常熟悉了。我们有一些用户应用程序，例如Shell，它运行在用户空间，同时我们还有内核空间。

![](../.gitbook/assets/image%20%28131%29.png)

Shell可能会执行系统调用，将程序运行转到内核。比如说执行write系统调用，通过Shell来输出提示信息，这是你启动XV6的第一个提示

