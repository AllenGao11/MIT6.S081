# 6.1 Trap

今天我想讨论一下，用户代码到内核执行之间的转换。每当

* 程序执行系统调用
* 程序出现了类似页缺失（page fault）、运算时除以0
* 一个设备触发了中断使得当前程序需要响应内核设备驱动

都会发生这样的转换。

这里从user到kernel空间的陷阱（trap）涉及了许多细心的设计和重要的细节。这些细节对于实现安全隔离和性能来说非常重要，因为很多应用程序的执行，要么因为系统调用，要么因为页缺失，都会频繁的转换到内核中。所以，trap机制要尽可能的简单，这一点非常重要。

初始的场景你们已经非常熟悉了。我们有一些用户应用程序，例如Shell，它运行在用户空间，同时我们还有内核空间。Shell可能会执行系统调用，将程序运行转到内核。比如XV6启动之后的一些提示信息，就是通过执行write系统调用来输出的。这是Shell尝试执行wrtie系统调用的一个例子。

![](../.gitbook/assets/image%20%28133%29.png)

所以我们需要清楚如何让程序的执行，从只拥有user权限并且位于用户空间的Shell，转换到拥有supervisor权限的内核。在这个过程中，硬件的状态将会非常重要，因为我们很多的工作都是将硬件从适合运行用户应用程序的状态，改变到适合运行内核代码的状态。

我们最关心的状态可能是32个用户寄存器，这在上节课中有介绍。我们有这么些用户寄存器：a0，a1等等。RISC-V总共有32个这样的寄存器，并且用户程序可以使用全部的寄存器。当使用全部寄存器的时候，性能是最好的。

![](../.gitbook/assets/image%20%28134%29.png)

这里的很多寄存器都有特殊的作用，我们之后都会看到。其中一个特别有意思的寄存器是stack pointer（也叫做堆栈寄存器 stack register）。所以，我们有了包含堆栈寄存器在内的这32个寄存器。

此外，

* 在硬件中还有一个寄存器叫做程序计数器（Program Counter Register）。
* 表明当前mode的寄存器，这个寄存器表明了当前是supervisor mode还是user mode。当我们在运行Shell的时候，自然是在user mode。
* 还有一堆控制CPU工作方式的寄存器，比如SATP（Supervisor Address Translation and Protection）寄存器，它包含了指向页表的指针。
* 还有一些对于今天讨论非常重要的寄存器，比如STVEC（Supervisor Trap Vector Base Address Register）寄存器，它指向了应该处理内核中trap的指令地址。
* SEPC（Supervisor Exception Program Counter）寄存器，在trap的过程中保存了程序计数器的值。
* SSRATCH（Supervisor Scratch Register）寄存器，这也是个非常重要的寄存器。

![](../.gitbook/assets/image%20%28132%29.png)

这些寄存器表明了系统调用时，运行机器的状态。

从用户空间进入内核空间时，我们实际上需要更改一些这里的状态，或者对状态做一些操作。这样我们才可以运行内核中普通的C程序。可以肯定的是，在trap的最开始，CPU的所有状态都设置成运行用户代码而不是内核代码。接下来我们先来预览一下需要做的操作：

* 首先，我们需要保存32个用户寄存器。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核所使用，所以在trap之前，你必须先在某处保存这32个用户寄存器。
* 程序计数器也需要在某个地方保存，它几乎跟一个用户寄存器的地位是一样的，我们需要能够在中断的位置继续执行用户程序。
* 我们需要将mode改成supervisor mode，因为我们想要使用内核中的各种各样的特权指令。
* 页表指针现在正指向user页表（SATP寄存器），而user页表只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的映射。所以在运行内核代码之前，我们需要将页表指针指向内核的页表。
* 我们需要将堆栈寄存器指向位于内核的一个地址，因为我们需要一个堆栈来调用C函数。
* 一旦我们设置好了，并且所有的硬件状态都适合在内核中使用， 我们需要跳入内核的C代码。

一旦我们运行在C代码中，那就跟平常的C代码是一样的。

