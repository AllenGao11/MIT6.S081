# 6.3

接下来，我将切换到gdb的世界中。 大家可以看我共享的屏幕，我们将要看一个XV6的系统调用，也就是Shell将它最开始的提示信息通过write系统调用走到操作系统再输出。你们可以看到，是用户代码sh.c初始化的这一切。

![](../.gitbook/assets/image%20%28209%29.png)

上图中选中的行，是一个write系统调用，它的参数是一个美元符（$）。接下来我将打开gdb并启动XV6。

![](../.gitbook/assets/image%20%28213%29.png)

当作为用户代码的Shell调用write时，实际上调用的是关联到Shell的一个库函数。你可以查看这个库函数的源代码，在usys.s。

![](../.gitbook/assets/image%20%28212%29.png)

上面这几行代码就是实际被调用的write函数的实现。这是个非常短的函数，它的工作只有将SYS\_write加载到a7寄存器，SYS\_write是常量16。这里告诉内核，我想要运行第16个系统调用，而这个系统调用正好是write。之后这个函数中执行了ecall指令，在这里代码执行跳转到了内核。内核完成它的工作之后，代码执行会返回到用户空间，继续执行ecall之后的指令，也就是ret，返回到Shell中。所以ret 从write库函数返回到了Shell中。

为了展示这里的系统调用部分，我会在ecall指令处放置一个断点，为了能放置断点，我们需要知道ecall指令的地址，我们可以通过查看由XV6编译过程产生的sh.asm找出这个地址。sh.asm是带有指令地址的汇编代码。我这里会在ecall指令处放置一个断点，这条指令的地址是0xde6。

![](../.gitbook/assets/image%20%28211%29.png)

现在，我要让XV6开始运行。我期望的是XV6在Shell代码中正好在执行ecall之前就会停住。

