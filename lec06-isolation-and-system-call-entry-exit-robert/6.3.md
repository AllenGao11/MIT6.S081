# 6.3

接下来，我将切换到gdb的世界中。 大家可以看我共享的屏幕，我们将要看一个XV6的系统调用，也就是Shell将它最开始的提示信息通过write系统调用走到操作系统再输出。你们可以看到，是用户代码sh.c初始化的这一切。

![](../.gitbook/assets/image%20%28210%29.png)

上图中选中的行，是一个write系统调用，它的参数是一个美元符（$）。接下来我将打开gdb并启动XV6。

![](../.gitbook/assets/image%20%28219%29.png)

当作为用户代码的Shell调用write时，实际上调用的是关联到Shell的一个库函数。你可以查看这个库函数的源代码，在usys.s。

![](../.gitbook/assets/image%20%28217%29.png)

上面这几行代码就是实际被调用的write函数的实现。这是个非常短的函数，它的工作只有将SYS\_write加载到a7寄存器，SYS\_write是常量16。这里告诉内核，我想要运行第16个系统调用，而这个系统调用正好是write。之后这个函数中执行了ecall指令，在这里代码执行跳转到了内核。内核完成它的工作之后，代码执行会返回到用户空间，继续执行ecall之后的指令，也就是ret，返回到Shell中。所以ret 从write库函数返回到了Shell中。

为了展示这里的系统调用部分，我会在ecall指令处放置一个断点，为了能放置断点，我们需要知道ecall指令的地址，我们可以通过查看由XV6编译过程产生的sh.asm找出这个地址。sh.asm是带有指令地址的汇编代码。我这里会在ecall指令处放置一个断点，这条指令的地址是0xde6。

![](../.gitbook/assets/image%20%28214%29.png)

现在，我要让XV6开始运行。我期望的是XV6在Shell代码中正好在执行ecall之前就会停住。

![](../.gitbook/assets/image%20%28216%29.png)

完美，从gdb可以看出，我们下一条要执行的指令就是ecall。我们来检验一下我们真的在我们以为自己在的位置，让我们来打印程序计数器（Program Counter），正好我们期望在的0xde6。

![](../.gitbook/assets/image%20%28212%29.png)

我们还可以输入_info reg_打印全部32个寄存器，

![](../.gitbook/assets/image%20%28215%29.png)

这里有一些数值我们还不知道，也不关心，但是这里的a0，a1，a2是Shell传递给write系统调用的参数。所以a0是文件描述符2；a1是Shell想要写入字符串的指针；a2是想要写入的字符数。我们还可以通过打印Shell想要写入的字符串内容，来证明我们正在看的代码正是自己以为的代码。

![](../.gitbook/assets/image%20%28218%29.png)

可以看出，输出的确是美元符（$）和一个空格。所以，我们现在位于我们期望所在的系统调用。

有一件事情需要注意，程序计数器（pc）和堆栈指针（sp）的地址都在距离0比较近的地址。这加强了我们对于当前代码正在用户空间执行的认识，因为用户空间中所有的地址都比较小。但是一旦我们进入到了内核，内核会使用大得多的内存地址。

系统调用的时间点会切换大量的状态，其中一个最重要的需要切换的状态，并且在它切换之前我们对它还有依赖的是当前的page table。我们可以查看STAP寄存器。

![](../.gitbook/assets/image%20%28211%29.png)

这里输出的是无内存地址，它并没有告诉我们有关page table中的映射关系是什么，page table长什么样。幸运的是，在QEMU中有一个方法可以打印当前的page table。从QEMU界面，输入_ctrl a + c_可以进入到QEMU的console，之后输入_info mem_，QEMU会打印完整的page table。

![](../.gitbook/assets/image%20%28209%29.png)

这是个非常小的page table，它只包含了6条映射关系。这是对于Shell的page table，而Shell是一个非常小的程序，这6条映射关系是有关Shell的指令和数据，以及一条

