# 6.7 usertrapret函数

![](../.gitbook/assets/image%20%28216%29.png)

usertrap函数的最后调用了usertrapret函数，来设置好我之前说过的，在返回到用户空间之前内核要做这个做那个。我们可以查看这个函数的内容。

![](../.gitbook/assets/image%20%28235%29.png)

它首先关闭了中断。我们之前在系统调用的过程中是打开了中断的，这里关闭中断是因为我们将要更新STVEC寄存器来指向用户空间的trap处理代码，而之前在内核中的时候，我们指向的是内核空间的trap处理代码（6.6）。我们关闭中断因为一旦我们将STVEC更新到指向用户空间的trap处理代码时，我们仍然在内核中执行代码。如果这时发生了一个中断，那么程序执行会走向用户空间的trap处理代码，即使我们现在仍然在内核中，出于各种各样具体细节的原因，这会导致内核出错。所以我们这里关闭中断。

![](../.gitbook/assets/image%20%28238%29.png)

在下一行我们设置了STVEC寄存器指向trampoline代码，在哪里最终会执行sret指令返回到用户空间。位于trampoline代码最后的sret指令会重新打开中断。这样，即使我们刚刚关闭了中断，当我们在执行用户代码时中断是打开的。

![](../.gitbook/assets/image%20%28221%29.png)

接下来的几行填入了trapframe的内容，这些内容对于执行trampoline代码非常有用。这里的代码就是：

* 存储了kernel page table的指针
* 存储了当前用户进程的kernel stack
* 存储了usertrap函数的指针，这样trampoline代码才能跳转到这个函数
* 从tp寄存器中读取当前的CPU核编号，并存储在trapframe中，这样trampoline代码才能恢复这个数字，因为用户代码可能会修改这个数字

现在我们在usertrapret函数中，我们正在设置trapframe中的数据，这样下一次从用户空间转换到内核空间时可以用到这些数据。

> 学生提问：为什么trampoline代码中不保存SEPC寄存器？
>
> Robert教授：这里可以存储。trampoline代码没有像其他寄存器一样保存这个寄存器，但是我们非常欢迎大家修改XV6来保存它。如果你还记得的话（详见6.6），这个寄存器实际上是在C代码usertrap中保存的，而不是在汇编代码trampoline中保存的。我想不出理由这里哪种方式更好。用户寄存器（User Registers）必须在汇编代码中保存，因为任何需要经过编译器的语言，例如C语言，都不能修改任何用户寄存器。所以对于用户寄存器，必须要在进入C代码之前在汇编代码中保存好。但是对于SEPC寄存器（注，因为是控制寄存器），我们可以早点保存或者晚点保存。

![](../.gitbook/assets/image%20%28263%29.png)

接下来我们要设置SSTATUS寄存器，这是一个控制寄存器。这个寄存器的SPP bit位。 

