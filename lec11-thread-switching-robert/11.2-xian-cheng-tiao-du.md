# 11.2 线程调度

如果我们要实现线程系统，有关线程有一些挑战我们需要能理解。

第一个是如何实现线程间的切换，这样多个线程才能交织运行。这里的停止一个线程的运行并启动另一个线程的控制通常被称为线程调度（Scheduling），我们将会看到XV6对于每个CPU核都有一个线程调度器（Scheduler）。通常来说，从一个线程切换到另一个线程，如何挑选下一个线程来运行被称为线程调度。

第二个挑战是，当你想要实际实现从一个线程切换到另一个线程时，你需要保存并恢复线程的状态，所以需要决定什么是必须保存的，在哪保存。

最后一个问题是如何处理运算密集型线程（compute bound thread）。对于线程切换，很多直观的实现是由线程自己自愿的保存自己的状态，再让其他的线程运行。但是如果我们有一些程序正在执行一些可能要花费数小时的长时间的计算任务，这样的线程并不能自愿的出让给其他的线程运行。所以最方便的方法是能从长时间运行的运算密集型线程，自动撤回控制，将其放置于一边，稍后再运行它。

![](../.gitbook/assets/image%20%28460%29.png)

接下来，我将首先介绍如何处理运算密集型线程。这里的具体实现你们之前或许接触过了，就是利用定时器中断。在每个CPU核上，都存在一个硬件设备，它会定时产生中断。XV6与其他所有的操作系统一样，将这个中断传输到了内核中。所以即使我们在用户空间运行π的前100万位，定时器中断仍然能在例如每隔10ms的某个时间触发，并将程序运行的控制权从用户空间代码切换到内核中的中断处理程序。这就是内核从不同的用户空间进程获取控制的第一步，哪怕这些用户空间进程并不配合工作（注，也就是用户空间进程一直占用CPU）。

位于内核的定时器中断处理程序，会自愿的将CPU出让（yield）给线程调度器，并告诉线程调度器说，你可以让一些其他的线程运行了。这里的出让其实也是一种线程切换，它会保存当前线程的状态，并在稍后恢复。

![](../.gitbook/assets/image%20%28473%29.png)

在之前的课程中，你们已经了解过了中断处理的流程。这里的基本流程是，定时器中断将CPU控制权给到内核，内核再自愿的出让CPU。

这里的处理流程被称为pre-emptive scheduling。pre-emptive的意思是，即使代码本身没有出让CPU，定时器中断仍然会将控制权拿走，并出让给线程调度器。与之相反的是voluntary scheduling。

![](../.gitbook/assets/image%20%28464%29.png)

有趣的是，在XV6和其他的操作系统中，线程调度是这么实现的：定时器中断会强制的将CPU控制权给到内核，这里是pre-emptive scheduling，之后内核会代表那个进程，使用voluntary scheduling。

在执行线程调度的时候，操作系统需要能区分：

* 当前在CPU上运行的线程
* 一旦CPU有空闲时间就将要运行在CPU上的线程
* 以及不想运行在CPU上的线程，因为这些线程可能在等待I/O或者其他事件

这里，不同的线程是由状态区分，但是实际上线程的完整状态会要复杂的多（注，线程的完整状态包含了程序计数器，寄存器，栈等等）。下面是我们将会看到的一些线程状态：

* RUNNING，线程当前正在某个CPU上运行
* RUNABLE，线程还没有在某个CPU上运行，但是一旦有空闲的CPU就可以运行
* SLEEPING，这节课我们不会介绍，下节课会重点介绍，这个状态以为着线程在等待一些I/O事件，它只会在I/O事件发生了之后运行

![](../.gitbook/assets/image%20%28465%29.png)

今天这节课，我们主要关注在RUNNING和RUNABLE这两类线程。前面介绍的定时器中断或者说pre-emptive scheduling，实际上就是将一个RUNNING线程转换成一个RUNABLE线程。通过出让CPU，pre-emptive scheduling将一个正在运行的线程转换成了一个当前不在运行，但是随时可以再运行的线程，因为在定时器中断触发时，这个线程还在好好的运行着。

对于RUNNING状态下的线程，它的程序计数器和寄存器正在运行它的CPU硬件中。而RUNABLE线程，因为并没有CPU与之关联，所以对于每一个RUNABLE线程，当我们将它从RUNNING转变成RUNABLE时，我们需要将它还是RUNNING时的CPU状态拷贝到内存中的某处，注意这里不是从内存中的某处进行拷贝，而是拷贝CPU中的寄存器。这里我们需要拷贝的信息就是程序计数器（Program Counter）和寄存器。

当线程调度器决定要运行一个RUNABLE线程时，这里涉及了很多步骤，但是其中一步是将之前保存的程序计数器和寄存器拷贝回调度器决定运行线程的CPU中。



