# Untitled

接下来我将通过两张图来介绍XV6中的线程是如何实现的，其中一张图是简单的，另一张图包含了更多的细节。

我们或许会运行多个用户空间进程，例如C compiler（CC），LS，Shell，它们或许会，也或许不会想要同时运行。在用户空间，每个进程有自己的内存，对于我们这节课来说，我们更关心的是每个进程都包含了一个用户程序栈（user stack），并且当进程运行的时候，它在RISC-V中会有程序计数器和寄存器。当程序在运行时，会有一个控制线程运行在用户空间。所以这里是一个用户的线程，用户程序栈，用户内存， 用户程序计数器，用户寄存器作为一个整体在运行。如果程序执行了一个系统调用并走到了内核中，那么相应的状态会被保存在程序的trapframe中（注，详见lec06），同时属于这个用户程序的内核线程被激活了。所以首先，用户的程序计数器，寄存器等等被保存到了trapframe中，之后CPU被切换到内核栈上运行。这里我们不需要恢复寄存器，因为内核线程并不是真正的运行，所以它没有真实的状态。实际上会走到trapoline和user trap代码中。之后内核会运行一段时间处理系统调用或者执行中断处理程序。

在某个时间，如果系统调用返回到用户空间，会将trapframe中保存的用户进程的状态进行恢复。

![](../.gitbook/assets/image%20%28461%29.png)

但是用户进程也有可能是因为类似于定时器中断走到了内核空间，那么这里将会切换到另一个用户进程。如果XV6决定从一个进程切换到另一个进程，首先发生的是从第一个进程的内核线程切换到第二个进程的内核线程。在第二个进程的内核线程中，在返回到用户空间的进程。

假设CC程序需要读取磁盘，那么它会出让CPU并且进入休眠状态等待读取磁盘结束。这时或许LS想要执行程序，并且它正在RUNABLE状态下。如果LS正在RUNABLE状态，那么意味着它的程序运行了一半，并且它的线程状态或许被定时器中断保存在某处。所以LS也会有一个trapframe，里面保存了程序计数器，用户寄存器以及它自己的内核栈。同时它也会保存内核寄存器，这被称为context。

所以XV6从CC的内核线程切换到LS的内核线程，XV6会首先保存CC程序的内核线程的内核寄存器在一个context中，再从之前保存的context中，恢复LS程序的内核线程的内核寄存器。之后LS或许会继续在它的内核线程栈上，完成它的系统调用，然后从LS的系统调用，通过恢复LS的trapframe中的用户进程状态，返回到用户空间的LS程序中，最后恢复执行LS。

这里核心点在于，在XV6中，任何时候需要从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存进程的状态，运行第一个用户进程的内核线程，从第一个用户进程的内核线程切换到第二个用户进程的内核线程，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器，并返回到第二个用户进程。总是这么曲折的一个线路。

![](../.gitbook/assets/image%20%28494%29.png)

> 学生提问：线程调度器的切换发生在这个过程中，是吗？
>
> Robert教授：是的，我接下来会介绍线程调度器。

实际的流程会明显复杂的多。假设我们有进程P1正在运行，进程P2是RUNABLE但是当前并不在运行。而在XV6中我们实际上有多个CPU核，假设我们有2个CPU核，这意味着在硬件层面我们有CPU0和CPU1。

![](../.gitbook/assets/image%20%28453%29.png)

我们从一个正在运行的用户空间进程切换到另一个RUNABLE但是还没有运行的用户空间进程的更完整的故事是，首先与我之前介绍的一样，一个定时器中断强迫CPU从用户空间进程切换到内核，trampoline代码将用户寄存器保存于用户进程对应的trapframe中；之后运行usertrap，来实际执行相应的中断或者系统调用，在这段时间CPU正在进程P1的内核栈上，执行内核中普通的C代码；假设进程P1对应的内核代码决定它想出让CPU，它会做很多工作，这个我们稍后会看，但是最后它会调用名为switch的函数，这是整个线程切换的核心函数之一；switch会保存用户进程P1对应内核线程的context对象，里面包含了的内核寄存器，所以这里有两类寄存器：用户寄存器在trapframe中，内核线程的寄存器在context中，

