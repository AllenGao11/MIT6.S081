# Untitled

接下来我将通过两张图来介绍XV6中的线程是如何实现的，其中一张图是简单的，另一张图包含了更多的细节。

我们或许会运行多个用户空间进程，例如C compiler（CC），LS，Shell，它们或许会，也或许不会想要同时运行。在用户空间，每个进程有自己的内存，对于我们这节课来说，我们更关心的是每个进程都包含了一个用户程序栈（user stack），并且当进程运行的时候，它在RISC-V中会有程序计数器和寄存器。当程序在运行时，会有一个控制线程运行在用户空间。所以这里是一个用户的线程，用户程序栈，用户内存， 用户程序计数器，用户寄存器作为一个整体在运行。如果程序执行了一个系统调用并走到了内核中，那么相应的状态会被保存在程序的trapframe中（注，详见lec06），同时属于这个用户程序的内核线程被激活了。所以首先，用户的程序计数器，寄存器等等被保存到了trapframe中，之后CPU被切换到内核栈上运行。这里我们不需要恢复寄存器，因为内核线程并不是真正的运行，所以它没有真实的状态。实际上会走到trapoline和user trap代码中。之后内核会运行一段时间处理系统调用或者执行中断处理程序。

在某个时间，如果系统调用返回到用户空间，会将trapframe中保存的用户进程的状态进行恢复。

![](../.gitbook/assets/image%20%28462%29.png)

但是用户进程也有可能是因为类似于定时器中断走到了内核空间，那么这里将会切换到另一个用户进程。如果XV6决定从一个进程切换到另一个进程，首先发生的是从第一个进程的内核线程切换到第二个进程的内核线程。在第二个进程的内核线程中，在返回到用户空间的进程。

假设CC程序需要读取磁盘，那么它会出让CPU并且进入休眠状态等待读取磁盘结束。这时或许LS想要执行程序，并且它正在RUNABLE状态下。如果LS正在RUNABLE状态，那么意味着它的程序运行了一半，并且它的线程状态或许被定时器中断保存在某处。所以LS也会有一个trapframe，里面保存了程序计数器，用户寄存器以及它自己的内核栈。同时它也会保存内核寄存器，这被称为context。

所以XV6从CC的内核线程切换到LS的内核线程，XV6会首先保存CC程序的内核线程的内核寄存器在一个context中，再从之前保存的context中，恢复LS程序的内核线程的内核寄存器。之后LS或许会继续在它的内核线程栈上，完成它的系统调用，然后从LS的系统调用，通过恢复LS的trapframe中的用户进程状态，返回到用户空间的LS程序中，最后恢复执行LS。

这里核心点在于，在XV6中，任何时候需要从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存进程的状态，运行第一个用户进程的内核线程，从第一个用户进程的内核线程切换到第二个用户进程的内核线程，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器，并返回到第二个用户进程。总是这么曲折的一个线路。

![](../.gitbook/assets/image%20%28498%29.png)

> 学生提问：线程调度器的切换发生在这个过程中，是吗？
>
> Robert教授：是的，我接下来会介绍线程调度器。

实际的流程会明显复杂的多。假设我们有进程P1正在运行，进程P2是RUNABLE但是当前并不在运行。而在XV6中我们实际上有多个CPU核，假设我们有2个CPU核，这意味着在硬件层面我们有CPU0和CPU1。

![](../.gitbook/assets/image%20%28454%29.png)

我们从一个正在运行的用户空间进程切换到另一个RUNABLE但是还没有运行的用户空间进程的更完整的故事是，首先与我之前介绍的一样，一个定时器中断强迫CPU从用户空间进程切换到内核，trampoline代码将用户寄存器保存于用户进程对应的trapframe中；之后运行usertrap，来实际执行相应的中断或者系统调用，在这段时间CPU正在进程P1的内核栈上，执行内核中普通的C代码；假设进程P1对应的内核代码决定它想出让CPU，它会做很多工作，这个我们稍后会看，但是最后它会调用名为switch的函数，这是整个线程切换的核心函数之一；switch会保存用户进程P1对应内核线程的context对象，里面包含了的内核寄存器，所以这里有两类寄存器：用户寄存器在trapframe中，内核线程的寄存器在context中。

![](../.gitbook/assets/image%20%28449%29.png)

switch函数实际上并不是从一个线程切换到另一个线程，实际上XV6中，一个CPU上运行的内核线程可以切换到的是这个CPU对应的调度器线程。所以我们不能直接切换到另一个线程，我们只是切换到了调度器线程。所以如果我们运行在CPU0，switch函数会恢复之前为调度器线程0保存的寄存器，在针对CPU0的调度器线程中，switch通过恢复这些寄存器和stack pointer，从switch函数返回之后就到达了scheduler函数。

![](../.gitbook/assets/image%20%28477%29.png)

在scheduler函数中会做一些清理工作，包括将将进程P1设置成sleep状态，之后查找进程表单去找到下一个可运行的进程。如果找到了一个进程，哪怕找到的还是进程P1，scheduler函数会再次调用switch函数，先保存自己的寄存器，自己的context；找到进程P2之前保存的context，其中的寄存器会被恢复。进程P2在进入sleep状态之前必然也调用了switch函数，正如进程P1一样，这个switch函数会被恢复，并返回到进程P2所在的系统调用或者中断中，当这完成之后了，会有之前通过系统调用也好，中断也好进入到内核时保存在trapframe中的用户寄存器，这些寄存器会被恢复，之后用户进程P2就恢复运行了。

![](../.gitbook/assets/image%20%28472%29.png)

对于每个CPU，都有一个完全不同的调度器线程，所以同样的，内核也保存了针对CPU1的调度器线程的context。任何运行在CPU1上的进程，当它决定出让CPU，它会切换到CPU1对应的调度器线程。

![](../.gitbook/assets/image%20%28495%29.png)

这里有个问题，context保存在哪？对于线程切换，包含了内核线程的寄存器的context保存在process结构体中。所以任何一个内核线程只能有一组保存的内核寄存器，因为每个内核线程只能在一个地方运行，context反映了它运行的位置，所以内核线程只需要一个context用来保存内核寄存器。它保存在p-&gt;context中。

对于每一个调度器线程，它也有自己的context，但是它却没有对应的进程和procee结构体，所以调度器线程的context保存在cpu结构体中。在内核中，有一个cpu结构体的数组，每个cpu结构体对应一个CPU核，每个结构体中都有一个context字段。

> 学生提问：为什么不能将context保存在进程对应的trapframe中？
>
> Robert教授：context可以保存在trapframe中，因为每一个进程都只有内核线程对应的一组寄存器，我们可以将这些寄存器保存在任何一个与进程一一对应的数据结构中。对于每个进程来说，有一个proc结构体，有一个trapframe结构体，所以我们可以将context保存于trapframe中。但是或许出于简化代码或者让代码更清晰，trapframe还是只包含进入和离开内核时的数据。而context结构体中包含的是在内核线程和调度器线程之间切换时，需要保存和恢复的数据。
>
> 学生提问：出让CPU是由用户发起的还是由内核发起的？
>
> Robert教授：对于XV6来说，并不会直接让用户线程出让CPU或者完成切换，而是由内核在合适的时间点做决定。有的时候你可以猜到特定的系统调用会导致出让CPU，例如一个用户进程读取pipe，而它知道pipe中并不能读到任何数据，这时你可以预测读取会被阻塞，而内核在等待数据的过程中会运行其他的进程。
>
> 内核会在两个场合下出让CPU，当定时器中断触发了，内核总是会让当前进程出让CPU，这是基于我们应该在定时器中断间隔的时间点上交织执行所有想要运行的进程，所以定时器中断总是会触发出让CPU。另外就是任何时候一个进程调用了系统调用并等待I/O，例如等待你敲入下一个按键，在你还没有按下按键时，等待I/O的机制会触发出让CPU。
>
> 学生提问：调用sleep是不是会调用某个系统调用，然后将用户进程的信息保存在trapframe，然后触发进程切换，这时就不是定时器中断决定，而是用户进程自己决定了吧？
>
> Robert教授：如果进程执行了read系统调用，然后进入到了内核中。而read系统调用要求进程等待磁盘，这时系统调用代码会调用sleep，而sleep最后会调用switch函数。switch函数会保存内核线程的寄存器到进程的context中，然后切换到对应CPU的调度器线程，再让其他的线程运行。这样在当前线程等待磁盘读取结束时，其他线程还能运行。所以，这里的流程除了没有定时器中断，其他都一样，只是这里是因为一个系统调用需要等待I/O。
>
> 学生提问：每一个CPU的调度器线程有自己的栈吗？
>
> Robert教授：是的，每一个调度器线程都有自己独立的栈。实际上调度器线程的所有内容，包括栈、context都以一种与用户进程不同的方式设置好的。它们是在系统启动时就设置好了，如果你查看XV6的start.s文件，你就可以看到为每个CPU核设置好调度器线程。

这里有一些行话，术语。当人们在说context switch，他们通常说的是从一个线程切换到另一个线程，因为在切换的过程中需要先保存前一个线程的寄存器，然后再恢复之前保存的后一个线程的寄存器。在有些时候，context switching也指从一个用户进程切换到另一个用户进程的完整过程。偶尔你也会看到context switching是指从用户空间和内核空间之间的切换。对于我们这节课来说，context switching主要是指从一个内核线程切换到调度器线程。

这里有一些有用的信息可以记住。每一个CPU核在一个时间只会做一件事情，每个CPU核在一个时间只会运行一个线程，它要么是运行用户进程的线程，要么是运行内核线程，要么是运行这个CPU核对应的调度器线程。所以在任何一个时间点，CPU核并没有做多件事情，而是只做一件事情。线程的切换创造了多个线程运行在一个CPU上的假象。

