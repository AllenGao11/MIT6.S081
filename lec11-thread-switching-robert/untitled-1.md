# Untitled

接下来我将通过两张图来介绍XV6中的线程是如何实现的，其中一张图是简单的，另一张图包含了更多的细节。

我们或许会运行多个用户空间进程，例如C compiler（CC），LS，Shell，它们或许会，也或许不会想要同时运行。在用户空间，每个进程有自己的内存，对于我们这节课来说，我们更关心的是每个进程都包含了一个用户程序栈（user stack），并且当进程运行的时候，它在RISC-V中会有程序计数器和寄存器。当程序在运行时，会有一个控制线程运行在用户空间。所以这里是一个用户的线程，用户程序栈，用户内存， 用户程序计数器，用户寄存器作为一个整体在运行。如果程序执行了一个系统调用并走到了内核中，那么相应的状态会被保存在程序的trapframe中（注，详见lec06），同时属于这个用户程序的内核线程被激活了。所以首先，用户的程序计数器，寄存器等等被保存到了trapframe中，之后CPU被切换到内核栈上运行。这里我们不需要恢复寄存器，因为内核线程并不是真正的运行，所以它没有真实的状态。实际上会走到trapoline和user trap代码中。之后内核会运行一段时间处理系统调用或者执行中断处理程序。

在某个时间，如果系统调用返回到用户空间，会将trapframe中保存的用户进程的状态进行恢复。

![](../.gitbook/assets/image%20%28465%29.png)

但是用户进程也有可能是因为类似于定时器中断走到了内核空间，那么这里将会切换到另一个用户进程。如果XV6决定从一个进程切换到另一个进程，首先发生的是从第一个进程的内核线程切换到第二个进程的内核线程。在第二个进程的内核线程中，在返回到用户空间的进程。

假设CC程序需要读取磁盘，那么它会出让CPU并且进入休眠状态等待读取磁盘结束。这时或许LS想要执行程序，并且它正在RUNABLE状态下。如果LS正在RUNABLE状态，那么意味着它的程序运行了一半，并且它的线程状态或许被定时器中断保存在某处。所以LS也会有一个trapframe，里面保存了程序计数器，用户寄存器以及它自己的内核栈。同时它也会保存内核寄存器，这被称为context。

所以XV6从CC的内核线程切换到LS的内核线程，XV6会首先保存CC程序的内核线程的内核寄存器在一个context中，再从之前保存的context中，恢复LS程序的内核线程的内核寄存器。之后LS或许会继续在它的内核线程栈上，完成它的系统调用，然后从LS的系统调用，通过恢复LS的trapframe中的用户进程状态，返回到用户空间的LS程序中，最后恢复执行LS。

这里核心点在于，在XV6中，任何时候需要从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存进程的状态，运行第一个用户进程的内核线程，从第一个用户进程的内核线程切换到第二个用户进程的内核线程，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器，并返回到第二个用户进程。总是这么曲折的一个线路。

![](../.gitbook/assets/image%20%28506%29.png)

> 学生提问：线程调度器的切换发生在这个过程中，是吗？
>
> Robert教授：是的，我接下来会介绍线程调度器。

实际的流程会明显复杂的多。假设我们有进程P1正在运行，进程P2是RUNABLE但是当前并不在运行。而在XV6中我们实际上有多个CPU核，假设我们有2个CPU核，这意味着在硬件层面我们有CPU0和CPU1。

![](../.gitbook/assets/image%20%28457%29.png)

我们从一个正在运行的用户空间进程切换到另一个RUNABLE但是还没有运行的用户空间进程的更完整的故事是，首先与我之前介绍的一样，一个定时器中断强迫CPU从用户空间进程切换到内核，trampoline代码将用户寄存器保存于用户进程对应的trapframe中；之后运行usertrap，来实际执行相应的中断或者系统调用，在这段时间CPU正在进程P1的内核栈上，执行内核中普通的C代码；假设进程P1对应的内核代码决定它想出让CPU，它会做很多工作，这个我们稍后会看，但是最后它会调用名为switch的函数，这是整个线程切换的核心函数之一；switch会保存用户进程P1对应内核线程的context对象，里面包含了的内核寄存器，所以这里有两类寄存器：用户寄存器在trapframe中，内核线程的寄存器在context中。

![](../.gitbook/assets/image%20%28452%29.png)

switch函数实际上并不是从一个线程切换到另一个线程，实际上XV6中，一个CPU上运行的内核线程可以切换到的是这个CPU对应的调度器线程。所以我们不能直接切换到另一个线程，我们只是切换到了调度器线程。所以如果我们运行在CPU0，switch函数会恢复之前为调度器线程0保存的寄存器，在针对CPU0的调度器线程中，switch通过恢复这些寄存器和stack pointer，从switch函数返回之后就到达了scheduler函数。

![](../.gitbook/assets/image%20%28482%29.png)

在scheduler函数中会做一些清理工作，包括将将进程P1设置成sleep状态，之后查找进程表单去找到下一个可运行的进程。如果找到了一个进程，哪怕找到的还是进程P1，scheduler函数会再次调用switch函数，先保存自己的寄存器，自己的context；找到进程P2之前保存的context，其中的寄存器会被恢复。进程P2在进入sleep状态之前必然也调用了switch函数，正如进程P1一样，这个switch函数会被恢复，并返回到进程P2所在的系统调用或者中断中，当这完成之后了，会有之前通过系统调用也好，中断也好进入到内核时保存在trapframe中的用户寄存器，这些寄存器会被恢复，之后用户进程P2就恢复运行了。

![](../.gitbook/assets/image%20%28477%29.png)

对于每个CPU，都有一个完全不同的调度器线程，所以同样的，内核也保存了针对CPU1的调度器线程的context。任何运行在CPU1上的进程，当它决定出让CPU，它会切换到CPU1对应的调度器线程。

![](../.gitbook/assets/image%20%28503%29.png)

这里有个问题，context保存在哪？对于线程切换，包含了内核线程的寄存器的context保存在process结构体中。所以任何一个内核线程只能有一组保存的内核寄存器，因为每个内核线程只能在一个地方运行，context反映了它运行的位置，所以内核线程只需要一个context用来保存内核寄存器。它保存在p-&gt;context中。

对于每一个调度器线程，它也有自己的context，但是它却没有对应的进程和procee结构体，所以调度器线程的context保存在cpu结构体中。在内核中，有一个cpu结构体的数组，每个cpu结构体对应一个CPU核，每个结构体中都有一个context字段。

> 学生提问：为什么不能将context保存在进程对应的trapframe中？
>
> Robert教授：context可以保存在trapframe中，因为每一个进程都只有内核线程对应的一组寄存器，我们可以将这些寄存器保存在任何一个与进程一一对应的数据结构中。对于每个进程来说，有一个proc结构体，有一个trapframe结构体，所以我们可以将context保存于trapframe中。但是或许出于简化代码或者让代码更清晰，trapframe还是只包含进入和离开内核时的数据。而context结构体中包含的是在内核线程和调度器线程之间切换时，需要保存和恢复的数据。
>
> 学生提问：出让CPU是由用户发起的还是由内核发起的？
>
> Robert教授：对于XV6来说，并不会直接让用户线程出让CPU或者完成切换，而是由内核在合适的时间点做决定。有的时候你可以猜到特定的系统调用会导致出让CPU，例如一个用户进程读取pipe，而它知道pipe中并不能读到任何数据，这时你可以预测读取会被阻塞，而内核在等待数据的过程中会运行其他的进程。
>
> 内核会在两个场合下出让CPU，当定时器中断触发了，内核总是会让当前进程出让CPU，这是基于我们应该在定时器中断间隔的时间点上交织执行所有想要运行的进程，所以定时器中断总是会触发出让CPU。另外就是任何时候一个进程调用了系统调用并等待I/O，例如等待你敲入下一个按键，在你还没有按下按键时，等待I/O的机制会触发出让CPU。
>
> 学生提问：调用sleep是不是会调用某个系统调用，然后将用户进程的信息保存在trapframe，然后触发进程切换，这时就不是定时器中断决定，而是用户进程自己决定了吧？
>
> Robert教授：如果进程执行了read系统调用，然后进入到了内核中。而read系统调用要求进程等待磁盘，这时系统调用代码会调用sleep，而sleep最后会调用switch函数。switch函数会保存内核线程的寄存器到进程的context中，然后切换到对应CPU的调度器线程，再让其他的线程运行。这样在当前线程等待磁盘读取结束时，其他线程还能运行。所以，这里的流程除了没有定时器中断，其他都一样，只是这里是因为一个系统调用需要等待I/O。
>
> 学生提问：每一个CPU的调度器线程有自己的栈吗？
>
> Robert教授：是的，每一个调度器线程都有自己独立的栈。实际上调度器线程的所有内容，包括栈、context都以一种与用户进程不同的方式设置好的。它们是在系统启动时就设置好了，如果你查看XV6的start.s文件，你就可以看到为每个CPU核设置好调度器线程。

这里有一些行话，术语。当人们在说context switch，他们通常说的是从一个线程切换到另一个线程，因为在切换的过程中需要先保存前一个线程的寄存器，然后再恢复之前保存的后一个线程的寄存器。在有些时候，context switching也指从一个用户进程切换到另一个用户进程的完整过程。偶尔你也会看到context switching是指从用户空间和内核空间之间的切换。对于我们这节课来说，context switching主要是指从一个内核线程切换到调度器线程。

这里有一些有用的信息可以记住。每一个CPU核在一个时间只会做一件事情，每个CPU核在一个时间只会运行一个线程，它要么是运行用户进程的线程，要么是运行内核线程，要么是运行这个CPU核对应的调度器线程。所以在任何一个时间点，CPU核并没有做多件事情，而是只做一件事情。线程的切换创造了多个线程运行在一个CPU上的假象。类似的每一个线程要么是只运行在一个CPU核上，要么它的状态被保存在context中。线程永远不会运行在多个CPU核上，线程要么运行在一个CPU核上，要么就没有运行。

在XV6的设置中，保存了内核线程寄存器的context，它总是由switch的调用产生，所以context总是保存了内核线程在执行switch函数的状态。当我们在恢复一个内核线程时，对于刚恢复的线程所做的第一件事情就是从之前的switch函数中返回。所以context总是保存了内核线程在switch函数中执行的状态。

> 学生提问：我们这里一直在说线程，但是从我看来XV6的实现中，一个进程就只有一个线程，有没有可能一个进程有多个线程？
>
> Robert教授：我们这里的用词的确有点让人混淆。在XV6中，一个进程要么在用户空间执行指令，要么是在内核空间执行指令，要么它的状态被保存在context和trapframe中，并且没有执行任何指令。这里该怎么称呼它呢？你可以根据自己的喜好来称呼它，对于我来说，每个进程有两个线程，一个用户空间线程，一个内核空间线程，并且存在限制使得一个进程要么运行在用户空间线程，要么为了执行系统调用或者响应中断而运行在内核空间线程 ，但是永远也不会两者同时运行。

接下来，让我切换到代码。首先让我展示一下我们刚刚介绍的内容。我们先来看一下proc.h中的proc结构体，从结构体总我们可以看到很多之前介绍的内容。

![](../.gitbook/assets/image%20%28490%29.png)

* 首先是保存了用户空间寄存器的trapframe字段
* 其次是保存了内核线程寄存器的context字段
* 还有保存了当前进程的内核栈的kstack字段，这是进程在内核中执行时函数调用保存的位置
* state字段保存了当前进程状态，要么是RUNNING，要么是RUNABLE，要么是SLEEPING等等
* lock字段保护了很多数据，目前来说至少保护了对于state字段的更新。举个例子，两个调度器线程不会同时尝试拉取同一个RUNABLE进程并运行他

我接下来会运行一个简单的演示程序，在这个程序中我们会从一个线程切换到另一个。

![](../.gitbook/assets/image%20%28512%29.png)

这个程序中会创建两个进程，两个进程会一直运行。代码首先通过fork创建了一个子进程，然后两个进程都会进入一个死循环，并每隔一段时间生成一个输出表明程序还在运行。但是它们都不会很频繁的打印输出，并且它们也不会主动出让CPU。所以我们这里有了两个运算密集型进程，并且它们会运行在同一个CPU上，因为我们接下来启动的XV6只有一个CPU核。所以为了让这两个进程都能运行，有必要让两个进程之间能相互切换。

接下来让我运行spin程序，

![](../.gitbook/assets/image%20%28514%29.png)

你可以看到一直有字符在输出，一个进程在输出“/”，另一个进程在输出"\"。从输出看，每隔一会，XV6就在两个进程之间切换，因为现在XV6只有一个CPU核。“/”输出了一会之后，定时器中断将CPU切换到另一个进程运行然后又输出“\”一会。所以在这里我们可以看到定时器中断在起作用。

接下来，我在trap.c的devintr函数中的207行设置一个断点，这一行会识别出当前是在响应定时器中断。

![](../.gitbook/assets/image%20%28446%29.png)

![](../.gitbook/assets/image%20%28515%29.png)

之后在gdb中continue。立刻会停在中断的位置，因为定时器中断还是挺频繁的。现在我们可以确认我们在usertrap函数中，并且usertrap函数调用devintr函数来处理这里的中断。

![](../.gitbook/assets/image%20%28475%29.png)

接下来我在gdb中输入finish来从devintr函数中返回到usertrap函数中，因为devintr函数中处理定时器中断的代码基本没有内容。

当我们返回到usertrap函数时，虽然我们刚刚从devintr函数中返回，但是我们期望运行到下面的yield函数。所以我们期望devintr函数返回2。

![](../.gitbook/assets/image%20%28448%29.png)

可以从gdb中看到devintr的确返回的是2。

![](../.gitbook/assets/image%20%28496%29.png)

yield函数中，当前进程会出让CPU并让另一个进程运行。这个我们稍后再看。

现在让我们看一下当中断发生的时候，正在执行什么内容。我在gdb中输入print p来打印名称为p的变量。变量p包含了当前进程的proc结构体。

> 学生提问：是什么使得每一个进程的内核线程不一样？
>
> Robert教授：每一个进程都有一个独立的内核线程。实际上有两件事情可以区分不同进程的内核线程，因为多个内核线程可以同时运行在不同的CPU核上。其中一件事情是，每个进程都有不同的内核栈，这是由proc结构体中的kstack字段所指向。另外，我们现在usertrap函数中，这是当中断发生时由trampoline调用的C代码。任何内核代码都可以通过调用myproc函数来获取当前CPU正在运行的进程。这就是另一个区分内核线程的事情。内核线程可以通过调用这个函数知道自己属于哪个进程。myproc函数会使用tp寄存器来获取当前的CPU核的ID，并使用这个ID在一个保存了每个CPU上运行进程对象的结构体数组中，找到对应的proc结构体。这就是不同的内核线程区分自己的方法。

我首先会打印p-&gt;name来获取进程的名称，

![](../.gitbook/assets/image%20%28508%29.png)

当前进程是spin程序，如预期一样。

![](../.gitbook/assets/image%20%28450%29.png)

当前的进程ID是3，进程切换之后，我们预期进程ID会不一样。

我们还可以通过打印变量p的trapframe字段获取表示用户空间状态的32个寄存器，这些都是我们在Lec06中学过的内容。这里面最有意思的可能是trapframe中保存的用户程序寄存器。

![](../.gitbook/assets/image%20%28484%29.png)

我们可以查看spin.asm文件来确定对应地址的指令。

![](../.gitbook/assets/image%20%28521%29.png)

可以看到定时器中断触发时，用户进程正在执行死循环的加1，这符合我们的预期。

回到devintr函数返回到usertrap函数中的位置。

