# 11.1 线程（Thread）概述

我们今天的课程会讨论线程，以及XV6是如何完成线程切换。这节课与之前介绍系统调用，Interrupt，page table和锁的课程一样，都是介绍XV6底层实现的课程。今天我们将讨论XV是如何在多个进程之间完成切换。

为什么计算机需要运行多线程的原因很多：

* 首先，人们希望他们的计算机在同一时间不只完成一件任务。有可能计算机正在执行分时复用的任务，例如MIT的公共计算机系统Athena允许多个用户同时登陆一台计算机，并运行各自的进程。甚至在一个单用户的计算机上或者在你的iphone上，你会运行多个进程，并期望计算机完成所有的任务而不仅仅是一个任务。
* 其次，多线程可以让程序的结构变得简单。线程在有些场合可以帮助程序员将代码以简单优雅的方式进行组织，并减少复杂度。实际上在第一个lab中prime number部分，通过多个进程可以更简单，方便，优雅的组织代码。
* 最后，使用多线程可以通过并行运算，在多核CPU计算机上获得更快的处理速度。常见的方式是将程序进行拆分，并使用线程在不同的CPU核上运行程序的不同部分。如果你足够幸运的话，你可以将你的程序拆分并在4个CPU核上通过4个线程运行你的程序，同时你也可以获取4倍的程序运行速度。你可以认为XV6就是一个多核并行运算的程序。 

所以，线程可以认为是，当你有多个任务时，为了简化编程的一种抽象。一个线程可以认为是单个串行执行代码的单元。如果你写了一个程序只是按顺序的一个个执行任务，那么你可以认为这个程序就是个单线程程序。这是对于线程的一个宽松的定义，人们对于线程有很多不同的定义。在这里，我们认为线程就是单个串行的代码执行。当你只使用一个CPU来运行你的程序时，你就得到了线程。它就是以普通的方式一个接一个的执行指令。

![](../.gitbook/assets/image%20%28488%29.png)

我们通常会说到线程具有状态，因为我们会想要保持线程的状态，并在之后恢复它。正确理解线程状态的方式是，它包含了程序计数器（Program Counter），因为它是对指令的执行单元，我们会关心它正在执行哪个位置的指令。同时，我们也关心处理器中为了支持代码执行的其他部分， 这意味着线程的状态还包含了编译器用来保存变量的寄存器。同时，根据编译器生成代码的方式，线程的状态还包含了stack。所以通常来说每个线程都有属于自己的stack，stack记录了函数调用的记录，并反映了当前线程的执行点。

![](../.gitbook/assets/image%20%28521%29.png)

线程系统的工作就是管理多个线程的运行。我们可能会启动成百上千个线程，而线程系统的工作就是弄清楚如何管理这些线程并让它们都能运行。

多线程的运行主要有两个策略：

* 第一个策略是在多核处理器上使用多个CPU，每个CPU都可以运行一个线程，如果你有4个CPU，那么每个CPU可以运行一个线程。每个线程自动的根据所在CPU就有了程序计数器和寄存器。但是如果你只有4个CPU，却有上千个线程，每个CPU都运行一个线程就不能解决这里的问题。
* 所以这节课大部分时间我们都会关注第二个策略，也就是一个CPU在多个线程之间完成切换。假设我只有一个CPU，但是有1000个线程，我们将会看到XV6是如何构建一个线程切换系统使得XV6能够先运行一个线程，之后将线程的状态保存，再切换到运行第二个线程，然后再试第三个线程依次类推直到每个线程都运行了一会，再回来执行第一个线程。

![](../.gitbook/assets/image%20%28513%29.png)

实际上，与大多数其他操作系统一样，XV6结合了这两种策略，首先线程会运行在所有可用的CPU核上，其次每个CPU核会在多个线程之间切换，因为通常来说，线程数会远远多于CPU的核数。

不同线程系统之间的一个大的区别在于，线程之间是否会共享内存。一种可能是你有一个地址空间，多个线程都在这一个地址空间内运行，并且它们可以看到彼此的更新，如果共享一个地址空间的线程修改了一个变量，共享地址空间的另一个线程可以看到变量的修改。所以当多个线程运行在一个共享地址空间时，我们需要用到上节课降到的锁。

XV6内核共享了内存，并且XV6支持内核线程的概念，对于每个进程都有一个内核线程用来执行来自进程的系统调用。所有的内核线程都共享内核内存，所以XV6的内核线程的确会共享内存。

另一方面，XV6有另外一种线程。每一个用户进程本质上有一个线程控制了用户进程代码指令的执行。实际上许多XV6的内核线程机制最终支持在多个用户进程之间切换每个用户进程有一些内存，并且包含了一个进程运行在这些内存之上。所以每个XV6的用户进程都有一个线程 ，在XV6的用户进程之间没有共享内存。当然你可以有多个用户进程，但是每个用户进程都是个拥有一个线程的独立地址空间。XV6中的进程不会共享内存。

在一些其他更加复杂的系统中，例如Linux，允许在一个用户进程中包含多个线程，进程中的多个线程共享进程的地址空间。当你想要实现一个运行在多个CPU核上的用户进程时，你就可以在用户进程中创建多个线程。这里也用到了我们今天会介绍的很多技术，但是在Linux中跟踪每个进程的多个线程要比每个进程只有一个线程要复杂的多。

![](../.gitbook/assets/image%20%28526%29.png)

还有一些其他的方式可以支持在一台计算机上交织的运行多个任务，我们不会讨论它们，但是如果你感兴趣的话，你可以去搜索event-driven programming或者state machine，这些是不使用线程技术在一台计算机上运行多个任务。在所有的支持多任务的方法中，线程技术并不是非常有效的方法，但是线程通常是最方便，对程序员最友好的，用来支持大量不同任务的方法。

