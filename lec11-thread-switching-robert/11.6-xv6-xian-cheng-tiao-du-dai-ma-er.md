# 11.6 XV6线程调度代码（二）

回到devintr函数返回到usertrap函数中的位置。在gdb里面输入几次step走到yield函数的调用。yield是整个出让CPU并让调度器选择另一个内核线程的第一步，下面是yield函数的内容：

![](../.gitbook/assets/image%20%28489%29.png)

yield函数只做了几件事情，它首先获取了进程的锁。实际上，在锁释放之前，进程的状态会变得不一致，例如，yield将要将进程的状态改为RUNABLE，表明进程并没有在运行，但是实际上这个进程还在运行，代码正在当前进程的内核线程中运行。所以这里加锁的目的之一就是，即使我们将进程的状态改为了RUNABLE，其他的CPU核的调度器线程也不可能看到进程的状态为RUNABLE并尝试运行它。否则的话，就在两个CPU核上运行了，而一个进程只有一个栈，这意味着两个CPU核在同一个栈上运行代码（注，因为XV6中一个用户进程只有一个用户线程）。

接下来yield函数中将进程的状态改为RUNABLE。这里的意思是，当前进程要出让CPU，并切换到调度器线程。当前进程的状态是RUNABLE意味着它还会再次运行，因为毕竟现在是一个定时器中断打断了当前正在运行的进程。

之后yield函数中调用了位于proc.c文件中的sched函数。我们进入到sched函数中，

![](../.gitbook/assets/image%20%28503%29.png)

可以看出，sched函数基本没有干任何事情，只是做了一些合理性检查，如果发现异常就panic。为什么会有这么多检查？因为这里的XV6代码已经有很多年的历史了，这些代码经历过各种各样的bug，相应的这里就有各种各样的合理性检查和panic来避免可能的bug。我将跳过所有的检查，直接走到位于底部的switch函数。

switch函数会将当前的内核线程寄存器保存到p-&gt;context中。switch函数的另一个参数c-&gt;context，c表示当前CPU的结构体。CPU结构体中的context保存了当前CPU核的调度器线程的寄存器。所以switch函数在保存完当前内核线程的内核寄存器之后，就会恢复当前CPU核的调度器线程，并继续执行当前CPU核的调度器线程。

接下来，我们快速的看一下我们将要切换到的context（注，也就是调度器线程的context）。因为我们只有一个CPU核，这里我在gdb中print cpus\[0\].context

![](../.gitbook/assets/image%20%28499%29.png)

这里看到的就是之前保存的当前CPU核的调度器线程的寄存器。在这些寄存器中，最有趣的就是ra（Return Address）寄存器，因为ra寄存器保存的是当前的函数调用要返回的地址，所以调度器线程中的代码会返回到ra寄存器中的地址。通过查看kernel.asm，我们可以知道这个地址的内容是什么。也可以在gdb中输入“x/i 0x800170a8”进行查看。

![](../.gitbook/assets/image%20%28509%29.png)

输出中包含了地址中的指令和指令所在的函数名。所以我们将要返回到scheduler函数中。

因为我们接下来要调用switch函数，让我们来看看switch函数的内容。switch函数位于switch.s文件中。

![](../.gitbook/assets/image%20%28530%29.png)

首先，ra寄存器被保存在了a0寄存器指向的地址。a0寄存器对应了switch函数的第一个参数，从前面可以看出这是当前线程的context对象地址 ；a1寄存器对应了switch函数的第二个参数，从前面可以看出这是即将要切换到的调度器线程的context对象地址。

所以函数中上半部分是将当前的寄存器保存在当前线程对应的context对象中，函数的下半部分是将调度器线程的寄存器，也就是我们将要切换到的线程的寄存器恢复到CPU的寄存器中。之后函数就返回了。所以调度器线程的ra寄存器的内容才显得有趣，因为它指向的是switch函数返回的地址，也就是scheduler函数。

这里有个有趣的问题，或许你们已经注意到了。switch函数的上半部分保存了ra，sp等等寄存器，但是并没有保存程序计数器pc（Program Counter），为什么会这样呢？

> 学生回答：因为程序计数器不管怎样都会随着函数调用更新。

是的，程序计数器并没有有效信息，我们现在知道我们在switch函数中执行，所以保存程序计数器并没有意义。但是我们关心的是我们是从哪调用进到switch函数的，因为当我们通过switch恢复执行当前线程并且从switch函数返回时，我们希望能够从调用点继续执行。ra寄存器保存了switch函数的调用点，所以这里保存的是ra寄存器。我们可以打印ra寄存器，如你们所预期的一样，它指向了sched函数。

![](../.gitbook/assets/image%20%28497%29.png)

另一个问题是，为什么RISC-V中有32个寄存器，但是switch函数中只保存并恢复了14个寄存器？

> 学生回答：因为switch是按照一个普通函数来调用的，对于有些寄存器，switch函数的调用者默认switch函数会做修改，所以调用者已经在自己的栈上保存了这些寄存器，当函数返回时，这些寄存器会自动恢复。所以switch函数里只需要保存Callee Saved Register就行。（注，详见5.4）

完全正确！因为switch函数是从C代码调用的，所以我们知道Caller Saved Register会被C编译器保存在当前的栈上。Caller Saved Register大概有15-18个，而我们在switch函数中只需要处理C编译器不会保存，但是对于switch函数又有用的一些寄存器。所以在切换线程的时候，我们需要保存Callee Saved Register。

最后我想看的是sp（Stack Pointer）寄存器。

![](../.gitbook/assets/image%20%28458%29.png)

从它的值很难看出它的意义是什么。它实际是当前进程的内核栈地址，它由虚拟内存系统映射在了一个高地址。

现在，我们保存了当前的寄存器，并从调度器线程的context对象恢复了寄存器，我直接跳到switch函数的最后，也就是ret指令的位置。

![](../.gitbook/assets/image%20%28485%29.png)

在我们实际返回之前，我们再来打印一些有趣的寄存器。首先sp寄存器有了一个不同的值，

![](../.gitbook/assets/image%20%28452%29.png)

sp寄存器的值现在在内存中的stack0区域中。这个区域实际上是在启动顺序中非常非常早的一个位置，start.s在这个区域创建了栈，这样才可以调用第一个C函数。所以调度器线程运行在CPU对应的bootstack上。

其次是ra寄存器，

![](../.gitbook/assets/image%20%28463%29.png)

现在指向了scheduler函数，因为我们恢复了调度器线程的context对象中的内容。

现在，我们其实已经在调度器线程中了，这里寄存器的值与上次打印的已经完全不一样了。虽然我们还在switch函数中，但是现在我们是从调度器线程中调用的switch函数。调度器线程在启动过程中调用的也是switch函数。接下来通过执行ret指令，我们就可以返回到调度器线程中。

来看一下scheduler的完整代码，

![](../.gitbook/assets/image%20%28534%29.png)

现在我们正运行在CPU拥有的调度器线程中，并且我们正好在之前调用switch函数的返回状态。之前调度器线程调用switch是因为想要运行pid为3的进程，也就是刚刚被中断的spin程序。

虽然pid为3的spin进程也调用了switch函数，但是那个switch并不是当前返回的这个switch。spin进程调用的switch函数还没有返回，而是保存在了pid为3的栈和context对象中。现在返回的是之前调度器线程对于switch函数的调用。

