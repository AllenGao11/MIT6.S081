# 11.5 XV6线程调度代码（一）

接下来，让我切换到代码。首先让我展示一下我们刚刚介绍的内容。我们先来看一下proc.h中的proc结构体，从结构体总我们可以看到很多之前介绍的内容。

![](../.gitbook/assets/image%20%28492%29.png)

* 首先是保存了用户空间线程寄存器的trapframe字段
* 其次是保存了内核线程寄存器的context字段
* 还有保存了当前进程的内核栈的kstack字段，这是进程在内核中执行时函数调用保存的位置
* state字段保存了当前进程状态，要么是RUNNING，要么是RUNABLE，要么是SLEEPING等等
* lock字段保护了很多数据，目前来说至少保护了对于state字段的更新。举个例子，因为有锁的保护，两个CPU的调度器线程不会同时拉取同一个RUNABLE进程并运行它

我接下来会运行一个简单的演示程序，在这个程序中我们会从一个线程切换到另一个。

![](../.gitbook/assets/image%20%28515%29.png)

这个程序中会创建两个进程，两个进程会一直运行。代码首先通过fork创建了一个子进程，然后两个进程都会进入一个死循环，并每隔一段时间生成一个输出表明程序还在运行。但是它们都不会很频繁的打印输出（注，每隔1000000次循环才打印一个输出），并且它们也不会主动出让CPU（注，因为每个进程都执行的是没有sleep的死循环）。所以我们这里有了两个运算密集型进程，并且因为我们接下来启动的XV6只有一个CPU核，它们都运行在同一个CPU上。为了让这两个进程都能运行，有必要让两个进程之间能相互切换。

接下来让我运行spin程序，

![](../.gitbook/assets/image%20%28517%29.png)

你可以看到一直有字符在输出，一个进程在输出“/”，另一个进程在输出"\"。从输出看，虽然现在XV6只有一个CPU核，但是每隔一会，XV6就在两个进程之间切换。“/”输出了一会之后，定时器中断将CPU切换到另一个进程运行然后又输出“\”一会。所以在这里我们可以看到定时器中断在起作用。

接下来，我在trap.c的devintr函数中的207行设置一个断点，这一行会识别出当前是在响应定时器中断。

![](../.gitbook/assets/image%20%28446%29.png)

![](../.gitbook/assets/image%20%28518%29.png)

之后在gdb中continue。立刻会停在中断的位置，因为定时器中断还是挺频繁的。现在我们可以确认我们在usertrap函数中，并且usertrap函数调用devintr函数来处理这里的中断（注，从下图的栈输出可以看出）。

![](../.gitbook/assets/image%20%28475%29.png)

因为devintr函数处理定时器中断的代码基本没有内容，接下来我在gdb中输入finish来从devintr函数中返回到usertrap函数。当我们返回到usertrap函数时，虽然我们刚刚从devintr函数中返回，但是我们期望运行到下面的yield函数。所以我们期望devintr函数返回2。

![](../.gitbook/assets/image%20%28448%29.png)

可以从gdb中看到devintr的确返回的是2。

![](../.gitbook/assets/image%20%28499%29.png)

在yield函数中，当前进程会出让CPU并让另一个进程运行。这个我们稍后再看。现在让我们看一下当定时器中断发生的时候，用户空间进程正在执行什么内容。我在gdb中输入print p来打印名称为p的变量。变量p包含了当前进程的proc结构体。

> 学生提问：是什么使得每一个进程的内核线程不一样？
>
> Robert教授：每一个进程都有一个独立的内核线程。实际上有两件事情可以区分不同进程的内核线程，其中一件是，每个进程都有不同的内核栈，它由proc结构体中的kstack字段所指向；另一件就是，任何内核代码都可以通过调用myproc函数来获取当前CPU正在运行的进程。内核线程可以通过调用这个函数知道自己属于哪个用户进程。myproc函数会使用tp寄存器来获取当前的CPU核的ID，并使用这个ID在一个保存了所有CPU上运行进程对象的结构体数组中，找到对应的proc结构体。这就是不同的内核线程区分自己的方法。

我首先会打印p-&gt;name来获取进程的名称，

![](../.gitbook/assets/image%20%28511%29.png)

当前进程是spin程序，如预期一样。

![](../.gitbook/assets/image%20%28450%29.png)

当前的进程ID是3，进程切换之后，我们预期进程ID会不一样。

我们还可以通过打印变量p的trapframe字段获取表示用户空间状态的32个寄存器，这些都是我们在Lec06中学过的内容。这里面最有意思的可能是trapframe中保存的用户程序计数器。

![](../.gitbook/assets/image%20%28485%29.png)

我们可以查看spin.asm文件来确定对应地址的指令。

![](../.gitbook/assets/image%20%28524%29.png)

可以看到定时器中断触发时，用户进程正在执行死循环的加1，这符合我们的预期。

