# 13.1

今天这节课的计划是，首先我们花几分钟来重温一下上节课 --- 线程切换的内容，因为有些内容还挺重要的。之后我们大部分时间都会讨论coordination，这是XV6中Sleep&Wake-up背后主要的机制。最后我们会讨论lost wake-up的问题。

首先是上节课的回顾。在XV6中，任何时候调用switch函数都会从一个线程切换到另一个线程，通常是在用户进程的内核线程和调度器线程之间切换。在调用switch函数之前，总是会先获取线程对应的用户进程的锁。所以过程是这样，一个进程先获取自己的锁，然后调用switch函数切换到调度器线程，调度器线程再释放锁。

![](../.gitbook/assets/image%20%28537%29.png)

实际上的代码顺序更像这样：

1. 一个进程出于某种原因想要进入休眠状态，比如说出让CPU或者等待数据，它会先获取自己的锁；
2. 之后进程将自己的状态从RUNNING设置为RUNNABLE；
3. 之后进程调用switch函数，其实是调用sched函数在sched函数中再调用的switch函数；
4. switch函数将当前的线程切换到调度器线程；
5. 调度器线程之前也调用了switch函数，现在恢复执行会从switch函数返回；
6. 返回之后，调度器线程会释放刚刚出让CPU的进程的锁

![](../.gitbook/assets/image%20%28501%29.png)

