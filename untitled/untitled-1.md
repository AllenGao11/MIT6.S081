# Untitled

接下来，我想讨论一下XV6面临的一个与Sleep&Wakeup相关的挑战，也就是如何关闭一个线程。每个线程最终都需要退出，我们需要清除线程的状态，释放线程的栈。在XV6中，一个进程如果退出的话，我们需要释放用户内存，释放page table，释放trapframe对象，将进程在进程表单中标为REUSABLE，这些都是典型的清理步骤。当线程退出或者被杀掉时，有许多东西都需要被释放。

这里会产生的两大问题是，首先我们不能直接单方面的摧毁另一个线程，因为另一个线程可能正在另一个CPU核上运行，并使用着自己的栈；也可能正在内核中持有了锁；也可能正在更新一个复杂的内核数据。如果我们直接就把线程杀掉了，我们可能在线程完成更新复杂的内核数据过程中就吧线程杀掉了。我们不能让这里的任何意见事情发生。

另一个问题是，即使一个线程调用了exit系统调用，并且是自己决定要退出。它仍然持有了执行代码时的一些资源，例如它的栈，以及它在进程表单中的位置。当它还在执行代码，它或许不能释放正在使用的资源。

