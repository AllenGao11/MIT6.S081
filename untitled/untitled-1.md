# 13.7 进程退出

接下来，我想讨论一下XV6面临的一个与Sleep&Wakeup相关的挑战，也就是如何关闭一个线程。每个线程最终都需要退出，我们需要清除线程的状态，释放线程的栈。在XV6中，一个进程如果退出的话，我们需要释放用户内存，释放page table，释放trapframe对象，将进程在进程表单中标为REUSABLE，这些都是典型的清理步骤。当线程退出或者被杀掉时，有许多东西都需要被释放。

这里会产生的两大问题是，首先我们不能直接单方面的摧毁另一个线程，因为另一个线程可能正在另一个CPU核上运行，并使用着自己的栈；也可能正在内核中持有了锁；也可能正在更新一个复杂的内核数据。如果我们直接就把线程杀掉了，我们可能在线程完成更新复杂的内核数据过程中就吧线程杀掉了。我们不能让这里的任何意见事情发生。

另一个问题是，即使一个线程调用了exit系统调用，并且是自己决定要退出。它仍然持有了执行代码时的一些资源，例如它的栈，以及它在进程表单中的位置。当它还在执行代码，它或许不能释放正在使用的资源。所以我们需要一种方法让线程能释放最后几个对于运行来说关键的资源，即使线程还需要它们。

记住这两个问题。XV6有两件事情与关闭线程进程相关。第一个是exit，第二个是kill。让我们先来看位于proc.c中的exit函数。

![](../.gitbook/assets/image%20%28499%29.png)

这就是exit系统调用的内容。从exit接口的整体来看，在最后它会释放进程的内存和page table，关闭已经打开的文件，同时我们也知道父进程会从wait系统调用中唤醒，所以exit最终会导致父进程被唤醒。这些都是我们预期可以从exit代码中看到的内容。

从上面的代码中，首先exit函数中关闭了所有已打开的文件。这里可能会很复杂，因为关闭文件系统中的文件设计到引用计数，虽然我们还没学到但是这里需要大量的工作。但是一个进程调用exit系统调用时，会关闭所有自己拥有的文件。

接下来类似的是，进程有一个对于当前目录的记录，这个记录会随着你执行cd指令而改变。在exit过程中也需要将这个引用释放给文件系统。

接下来是有关这方面的内容，如果一个进程要退出，但是它又有自己的子进程，这些子进程继承自init进程。我们接下来会看到，每一个exit的进程，都有一个父进程中的对应的wait系统调用。父进程中的wait系统调用会完成exit中结束的几个步骤。所以如果父进程exit，那么子进程就不再有父进程，当它们exit时就没有对应的父进程的wait。所以在exit函数中，会为即将exit进程的子进程重新指定父进程为init进程，也就是PID为1的进程。

![](../.gitbook/assets/image%20%28519%29.png)

最后我们需要通过调用wakeup函数唤醒当前进程的父进程，当前进程的父进程或许正在等待当前进程退出。

接下来，进程的状态被设置为ZOMBIE。现在进程还没有完全完成释放它的资源，所以它还不能被重用。我们期望的是在最后，进程的所有状态都可以被一些无关的fork系统调用复用，但是目前我们还没有到那一步。

现在我们还没有结束，因为我们还没有释放进程。我们在还没有完全释放所有资源的时候，通过调用sched函数进入到调度器线程。

到目前位置，进程的状态是ZOMBIE，并且进程不会再运行，因为调度器只会运行RUNABLE进程。同时进程也并没有完全释放，因为那对应着UNUSED状态，但是可以肯定的是它不会再运行了，因为它的状态是ZOMBIE。所以调度器线程会决定运行其他的进程。

通过Unix的exit和wait系统调用的说明我们可以知道，如果一个进程exit了，并且它的父进程调用了wait系统调用，父进程的wait会返回，表明它其中一个子进程exit了。所以接下来我们看一下wait系统调用的实现。

![](../.gitbook/assets/image%20%28521%29.png)

它里面包含了一个大的循环。当一个进程调用了wait系统调用，它会扫描进程表单，找到父进程是当前进程且状态是ZOMBIE的进程，这些进程已经在exit中几乎要执行完了。所以wait系统调用中找到了已经exit的进程，我不知道你们还记不记得，exit可以返回32bit的状态码给父进程，这样接下来的代码可以读取这个返回码。

之后由父进程调用的freeproc函数，来完成释放进程资源的最后几个步骤。我们看一下freeproc的实现，

![](../.gitbook/assets/image%20%28453%29.png)

这是关闭一个进程的最后步骤，并且如果是exiting的进程自己在exit函数中执行，将会非常奇怪。这里释放了trapframe，释放了page table。如果我们需要释放进程内核栈，那么也应该在这里释放。但是因为内核栈的guard page，我们没有必要再释放一次内核栈（？）。不管怎样，当进程还在exit函数中运行时，任何内容在exit函数中释放都会很难受，这些内容都是由父进程释放的。

wait不仅是为了父进程方便知道子进程退出，wait实际上是进程退出的一个重要组成部分。在Unix中，对于每一个退出的进程，都需要有一个对应的wait系统调用，这就是为什么当一个进程退出时，它的子进程需要交给init进程进而编程init进程的子进程。init的工作就是在一个循环中不停调用wait，因为每个进程都需要对应一个wait，这样它的父进程才能调用freeproc函数，并清理进程的资源。当父进程完成了清理进程的所有资源，子进程的状态会被设置成UNUSED。之后，fork系统调用才能重用进程的槽位。

> 学生提问：在exit系统调用中，为什么需要在重新设置父进程之前，先获取当前进程的父进程？
>
> Robert教授：这里其实就是在防止一个进程和它的父进程同时退出。通常情况下，一个进程exit，它的父进程正在wait，一切都正常。但是也可能一个进程和它的父进程同时exit。所以当子进程尝试唤醒父进程，并告诉它自己退出了时，父进程也在退出。这些代码我一年前还记得是干嘛的，现在已经记不太清了。它应该是处理这种父进程和子进程同时退出的情况。如果不是这种情况的话，一切都会非常直观，子进程会在后面通过wakeup函数唤醒父进程。
>
> 学生提问：为什么我们在唤醒父进程之后才将进程的状态设置为ZOMBIE？难道我们不应该在之前就设置吗？
>
> Robert教授：正在退出的进程会先获取自己进程的锁，父进程并不能查看当前的进程，因为父进程的wait系统调用中也会获取子进程的锁。所以这意味着，正在退出的进程获取自己的锁到它调用sched进入到调度器线程之间（注，因为调度器线程会释放进程的锁），父进程并不能看到这之间代码引起的中间状态。所以这之间的代码顺序并不重要。大部分时候，如果没有持有锁，任何代码顺序都不能工作。因为有了锁，代码的顺序就不再重要，因为父进程也看不到进程状态。

这里我想要强调的是，直到子进程exit的最后，它都没有释放所有的资源，因为它还在运行的过程中所以不能释放。相应的其他的进程，也就是父进程，释放了运行子进程代码所需要的资源。这里的设计可以让我们极大的精简exit的实现。

最后我想看的是kill系统调用。Unix中的一个进程可以将另一个进程的ID传递给kill系统调用，并让另一个进程停止运行。如果我们不够小心的话，当另一个进程还在内核执行代码，会有一些我几分钟前介绍过的风险，比如我们想要杀掉的进程的内核线程还在更新一些数据，比如说更新文件系统，创建一个文件。如果这样的话，我们不能就这样杀掉进程，因为这样会使得一些需要多步完成的操作只执行了一半。所以kill系统调用不能就直接停止目标进程的运行。实际上，在XV6和其他的Unix系统中，kill系统调用基本上不做任何事情。

![](../.gitbook/assets/image%20%28552%29.png)

它先扫描进程表单，找到目标进程。然后只是将进程的proc结构体中killed标志位设置为1。如果进程正在SLEEPING状态，将其设置为RUNNABLE。这里只是将killed标志位设置为1，并没有停止进程的运行。所以kill系统调用本身还是很温和的。

而目标进程运行到内核代码中能安全停止运行的位置时，会检查自己的killed标志位，如果设置为1，目标进程会自愿的执行exit系统调用。你可以在trap.c中看到所有可以安全停止运行的位置，

![](../.gitbook/assets/image%20%28574%29.png)

在usertrap函数中（注，详见6.6），在执行系统调用之前，如果进程已经被kill了，进程会自己调用exit。在这个内核代码位置，代码并没有持有任何锁，也不在执行任何操作的过程中，所以进程通过exit退出是完全安全的。

类似的，在usertrap函数的最后，也有类似的代码。在执行完系统调用之后，进程会再次检查自己时候已经被kill了。即使进程是被中断打断，这里的检查也会被执行。例如当一个定时器中断打断了进程的运行，我们可以通过检查发现进程是killed状态，之后进程会调用exit退出。

所以kill系统调用并不是真正的立即停止进程的运行，它更像是如果进程在用户空间，那么下一次它执行系统调用它就会退出，又或者目标进程正在执行用户代码，当时下一次定时器中断触发了

