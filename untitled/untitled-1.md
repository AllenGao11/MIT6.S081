# Untitled

接下来，我想讨论一下XV6面临的一个与Sleep&Wakeup相关的挑战，也就是如何关闭一个线程。每个线程最终都需要退出，我们需要清除线程的状态，释放线程的栈。在XV6中，一个进程如果退出的话，我们需要释放用户内存，释放page table，释放trapframe对象，将进程在进程表单中标为REUSABLE，这些都是典型的清理步骤。当线程退出或者被杀掉时，有许多东西都需要被释放。

这里会产生的两大问题是，首先我们不能直接单方面的摧毁另一个线程，因为另一个线程可能正在另一个CPU核上运行，并使用着自己的栈；也可能正在内核中持有了锁；也可能正在更新一个复杂的内核数据。如果我们直接就把线程杀掉了，我们可能在线程完成更新复杂的内核数据过程中就吧线程杀掉了。我们不能让这里的任何意见事情发生。

另一个问题是，即使一个线程调用了exit系统调用，并且是自己决定要退出。它仍然持有了执行代码时的一些资源，例如它的栈，以及它在进程表单中的位置。当它还在执行代码，它或许不能释放正在使用的资源。所以我们需要一种方法让线程能释放最后几个对于运行来说关键的资源，即使线程还需要它们。

记住这两个问题。XV6有两件事情与关闭线程进程相关。第一个是exit，第二个是kill。让我们先来看位于proc.c中的exit函数。

![](../.gitbook/assets/image%20%28496%29.png)

这就是exit系统调用的内容。从exit接口的整体来看，在最后它会释放进程的内存和page table，关闭已经打开的文件，同时我们也知道父进程会从wait系统调用中唤醒，所以exit最终会导致父进程被唤醒。这些都是我们预期可以从exit代码中看到的内容。

从上面的代码中，首先exit函数中关闭了所有已打开的文件。这里可能会很复杂，因为关闭文件系统中的文件设计到引用计数，虽然我们还没学到但是这里需要大量的工作。但是一个进程调用exit系统调用时，会关闭所有自己拥有的文件。

接下来类似的是，进程有一个对于当前目录的记录，这个记录会随着你执行cd指令而改变。在exit过程中也需要将这个引用释放给文件系统。

