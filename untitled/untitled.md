# 13.4 Sleep&Wakeup 规则

我们的目标是消灭掉lost wakeup。这可以通过消除下面的窗口时间来实现。

![](../.gitbook/assets/image%20%28473%29.png)

首先我们必须要释放uart\_tx\_lock锁，因为中断需要获取这个锁。但是我们又不能在释放锁和进程将自己标记为SLEEPING之间留有窗口，这样的话，中断处理程序中的wakeup才能看到SLEEPING状态的进程，并将其唤醒。这样我们才可以避免lost wakeup的问题。所以，我们应该关闭这里的窗口。

为了实现这里的目的，我们需要将sleep函数接口设计的稍微复杂点。这里的解决方法是，即使sleep函数不知道你在等待什么事件，它还是需要你知道你在等待什么数据，并且传入一个用来保护你在等待数据的锁。所以sleep需要特定的条件，而sleep自己有不需要知道这个条件是什么。这里sleep的特定条件是tx\_done等于1。虽然sleep不知道特定的条件是什么，但是它需要知道保护这个条件的锁，也即是这里的uart\_tx\_lock。在调用sleep的时候，锁还被当前线程持有，之后这个锁被传递给了sleep。

在接口层面，sleep承诺可以原子性的将进程设置成SLEEPING状态，同时释放锁。这样wakeup就不可能看到这样的场景：锁被释放了但是进程还没有进入到SLEEPING状态。所以sleep这里将释放锁和设置进程为SLEEPING状态这两个行为作为一个原子操作。

这里必须要有一个锁来保护sleep的条件，并且这个锁需要传递给sleep作为参数。更进一步的是，当调用wakeup时，锁必须被持有。如果程序员想要写出正确的代码，这些都是必须遵守的规则来使用sleep和wakeup。

