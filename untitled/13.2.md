# 13.2

接下来看一下Sleep&Wake-up中的coordination。

我们听过很多关于锁的介绍，并且锁可以帮助线程不必关心其他线程的具体实现。我们为共享的数据增加锁，这样就不用担心其他线程也使用相同的数据，因为锁可以确保事情是一件一件的发生的。

但是当你在写一个线程的代码时，同样也有场景需要等待一些特定的事件，或者不同的线程之间需要交互。假设我们有了Pipe，并且我在从Pipe中读数据但是Pipe中又没有数据，所以我需要能到等待一个Pipe非空的事件。类似的假设我在读取磁盘，我会告诉磁盘控制器请读取磁盘上的特定块。这或许要花费较长的时间，毫秒级别，磁盘才能完成读取，尤其当磁碟需要旋转时。而执行读磁盘的进程需要等待读磁盘结束的事件。类似的，一个Unix程序可以调用wait系统调用。这个系统调用会使得调用进程等待任何一个子进程退出。所以这里父进程有意的在等待另一个进程产生的事件。

![](../.gitbook/assets/image%20%28551%29.png)

以上就是进程需要等待特定事件的例子。特定事件可能来自于I/O，也可能来自于另一个进程，并且描述了某件事情已经发生。Coordination是帮助我们解决这些问题的工具，并能帮助我们实现这些需求。Coordination是非常基础的工具，就像锁一样，在实现线程代码时它会一直出现。

我们怎么能让进程或者线程等待一些特定的事件呢？一种非常直观的方法是通过循环实现busy-wait。假设我们想从一个Pipe读取数据，我们就写一个循环一直等待Pipe的buffer不为空。

![](../.gitbook/assets/image%20%28537%29.png)

这个循环会一直运行直到其他的线程向Pipe的buffer写了数据。之后循环会结束，我们可以从Pipe中读取数据并返回。

实际中会有这样的代码。如果你知道你要等待的事件极有可能在0.1微秒内发生，通过循环等待或许是最好的实现方式。通常来说在设备的硬件中会采用这样的等待方式，如果你要求一个硬件完成一个任务，那么你知道硬件总是能非常快的完成任务，这时通过一个类似的循环等待或许是正确的方式。

另一方面事件可能需要多个毫秒甚至你都不知道事件要多久才能发生，或许要10分钟其他的进程才能向Pipe写入数据，那么我们就不想在这一直循环并且浪费本可以用来完成其他任务的CPU时间。这时我们想要通过类似switch函数调用的方式出让CPU，并在我们关心的事件发生时重新获取CPU。Coordination就是有关出让CPU，直到等待的事件发生。人们发明了很多不同的Coordination的实现方式，但是与许多Unix风格操作系统一样，XV6使用的是Sleep&Wake-up这种方式。

介绍完背景了，接下来我们看一下XV6的代码。为了准备这节课，我重写了UARD的驱动代码，XV6通过这部分代码从console中读写字符。

![](../.gitbook/assets/image%20%28513%29.png)

首先是uartwrite函数。当shell需要输出时会调用write系统调用最终走到uartwrite函数中，这个函数会在循环中一个字符一个字符的向UART硬件写数据。这里是以一种经典的设备驱动风格实现的，你可以在很多设备驱动中看到类似的代码。UART硬件一次只能接受一个字符的传输，而通常来说会有很多字符需要写到UART硬件。你可以向UART硬件写入一个字符，并等待UART硬件说：好的我完成了传输上一个字符并且准备好了传输下一个字符，之后驱动才可以写入下一个字符。因为这里的硬件可能会非常慢，或许每秒只能传输1000个字符，我们在两个字符之间的等待时间可能会很长，1毫秒在现在计算机上是一个非常非常长的时间，它可能包含了数百万条指令时间，所以我们不想通过循环来等待UART完成字符传输，我们想通过一个更好的方式来等待。如大多数操作系统一样，XV6也的确存在更好的等待方式。

UART硬件会在完成传输一个字符后，触发一个中断。所以UART驱动中除了uartwrite函数外，还有名为uartintr的中断处理程序。这个中断处理程序会在UART硬件触发中断时由trap.c代码

![](../.gitbook/assets/image%20%28462%29.png)

