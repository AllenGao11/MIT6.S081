# 20.5 Heap exhaustion

让我们讨论一下Heap耗尽问题，我不会像[论文](https://pdos.csail.mit.edu/6.828/2020/readings/biscuit.pdf)一样深入讨论，但是至少会演示问题是什么。

![](../.gitbook/assets/image%20%28530%29.png)

假设蓝色的矩形是内核，内核会有一个heap，它会从其中申请动态内存。在XV6中，我们并没有这样一个heap，我们在内核中没有内存分配器，所有内存都是静态分配的。但是任何其他的内核中，都会有heap，所以你在内核中可以调用malloc和free。可能会通过heap分配的对象有socket对象，文件描述符对象和进程对象。所以，我们在XV6中静态分配的所有结构体，例如struck proc，struct fd，在正常的内核中都是动态分配的。所以当你打开一个新的文件描述符时，内核会通过heap分配一个文件描述符对象。

这里的问题是，你可以运行很多个应用程序，它们会打开很多个文件描述符，拥有很多个socket，它们会逐渐填满heap。

![](../.gitbook/assets/image%20%28816%29.png)

在某个时间点，heap会被填满，这时没有额外的空间可以用来分配一个新的对象。如果这时应用程序需要打开一个新的文件描述符，或者调用了fork使得内核想要在heap中分配一个新的proc结构体，heap中没有了空间。这时你该怎么办呢？这是一个不太常见的常见问题，但是如果你使劲用你的电脑，你或许会遇到所有内存都被使用了的情况，你的heap满了，并且没有进程调用了free，因为它们都还在运行且想分配更多的内存。所有的内核都会遇到这个问题，不管是C内核也好，Biscuit也好，任何内核都需要解决这个问题。

之所以这个问题对于我们来说是个严重的问题，是因为在很多内核中，你可以对malloc返回错误，实际上，XV6就是这么做的。但是在Go runtime中，当你调用new来分配一个Go对象，并没有error condition，new可以成功。让我们来讨论一些可以解决这里问题的方法。

![](../.gitbook/assets/image%20%28532%29.png)

* 第一种方法我们在XV6中见过。如果XV6不能找到一个空闲的block cache来保存disk block，它会直接panic。这明显不是一个想要的解决方案，这并不是一个实际的解决方案。所以我们称之为strawman。
* 另一个strawman方法是，当你在申请一块新的内存时，你会调用alloc或者new来分配内存，你实际上可以在内存分配器中进行等待。这实际上不是一个好的方案，原因是你可能会有死锁。假设内核有把大锁，当你调用malloc，因为没有空闲内存你会在内存分配器中等待，那么这时其他进程都不能运行了。那么下一个进程想要释放一些内存，但是因为死锁也不能运行。对于内核中有大锁的情况，这里明显有问题，但是即使你的锁很小，也很容易陷入到在内存分配器中等待的进程，持有了其他进程需要释放内存的锁，这就会导致死锁的问题。
* 下一个strawman方法是，如果没有内存了，allow返回空指针，你检查如果是空指针就直接失败，这被称为bail out。但是bail out并不是那么直观，进程或许已经申请了一些内存你需要删除它们，你或许做了一部分磁盘操作，比如说你在一个多步的文件系统操作中间，你只做了其中的一部分，你需要回退。所以实际中非常难做对。

当研究这部分，并尝试解决这个问题，Linux使用了上面两种方法，但是两种方法都有问题。实际中，内核开发人员很难将这里弄清楚。如果你对这个问题和相关的讨论感兴趣，可以Google搜索“too small to fail”，会有一片小的文章讨论释放内存，在内存分配器中等待的复杂性。

对于Biscuit来说，strawman 2解决方案不可能实施，因为new不会fail，它总是能成功。除此之外，这里的方案都不理想，所以我们需要有一种更好的方法。

![](../.gitbook/assets/image%20%28350%29.png)

Biscuit的解决方案是非常直观，当应用程序执行系统调用，例如read，fork时，在系统调用的最开始，跳转到内核之前，它会先调用reserve函数，reserve函数会保留足够的内存以运行系统调用。所以reserve会保留足够这个系统调用使用的空闲内存，以使得系统调用总是能成功。所以一旦系统调用被执行，且保留了足够的内存，那么它就可以一直运行而不会有内存耗尽和heap exhaustion的问题。

如果reserve函数执行时没有足够的内存，那么程序会在这里等待。因为现在在系统调用的最开始，系统调用现在还没有持有任何的锁，持有任何的资源，所以在这里等待完全没有问题，也没有死锁的风险。当它在等待的时候，内核可以撤回cache并尝试在heap空间增加空闲空间。或许kill一个进程来迫使释放一些内存。一旦内存够用了，并且内核决定说是可以满足需要保留的内存，之后内核会让系统调用继续运行，然后执行系统调用需要的操作。

在最后，当系统调用完成的时候，所有之前保留的内存都返回到池子中，这样后续的系统调用可以继续使用。

这个方案中有一些很好的特性：

* 在内核中没有检查。你不需要检查内存分配是否会失败，在我们的例子中这尤其的好，因为在Golang中内存分配不可能会失败。
* 这里没有error handling代码。
* 这里没有死锁的可能，因为你在最开始还没有持有锁的时候，就避免了程序继续执行。

当然，现在的问题是如何实现reserve函数，你如何计算一个运行系统调用会需要多少内存？

![](../.gitbook/assets/image%20%28828%29.png)

你保留的内存数量是重要的，你可以为每个系统调用保留一半的内存或者一些其他夸张的内存数量。但是这意味着你先试了可以并发执行的系统调用的个数，所以你这里想要做的足够好来计算一个系统调用的内存边界。

![](../.gitbook/assets/image%20%28815%29.png)

这里的解决方法是使用了高级编程语言的特性。Golang实际上非常容易做静态分析，Go runtime和Go生态里面有很多包可以用来分析代码，我们使用这些包来计算系统调用所需要的内存。所以你可以想象，如果你有一个read系统调用，我们可以通过系统调用的调用图查看比如函数f调用函数g调用函数h等等等等。我们可以做的是弄清楚这里调用的最大深度，对于最大的深度，计算这里每个函数需要的内存是多少。

![](../.gitbook/assets/image%20%28483%29.png)

比如说函数f调用了new，我们知道new的对象类型，因为这是一个高级编程语言，所以我们可以计算对象的大小。我们将所有的new所需要的内存加起来，得到了一个总和S，这就是这个调用图（或者说系统调用）任何时间可能需要的最大内存。

![](../.gitbook/assets/image%20%28813%29.png)

实际中并没有这么简单，会有点棘手。因为函数h

