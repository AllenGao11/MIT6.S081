# 16.3 ext3提升性能的方法

ext3通过3种方式提升了性能：

* 首先，它提供了异步的（asynchronous）系统调用，也就是说系统调用在写入到磁盘之前就返回了，系统调用只会更新缓存在内存中的block，并不用等待写磁盘操作。不过它可能会等待读磁盘。
* 第二，它提供了batching，可以将多个系统调用打包成一个transaction。
* 最后，它提供了并发（concurrency）。

![](../.gitbook/assets/image%20%28677%29.png)

这些基本上就是ext3有的，而XV6没有的特性。接下来我将一一介绍这里的特性。

> 学生提问：有关batching，XV6不是也支持多个系统调用同时执行start\_op和end\_op，然后再一起commit吗？
>
> Robert教授：是的，XV6具备有限能力的batching。

首先是异步的系统调用。这表示系统调用修改完在缓存中的block之后就返回，并不会出发写磁盘。所以这里明显的优势就是系统调用能够快速的返回。同时它也使得I/O可以并行的运行，也就是说应用程序可以调用一些文件系统的系统调用，来让文件系统完成一些列磁盘操作，但是之后应用程序可以从系统调用中返回并继续运算，与此同时文件系统并行的会完成被之前的系统调用所要求的的写磁盘操作。这被称为I/O concurrency，如果没有异步系统调用，很难获得I/O concurrency，或者说很难同时进行磁盘操作和应用程序运算，因为同步系统调用中，应用程序总是要等待磁盘操作结束。

另一个异步系统调用带来的好处是，它使得大量的batching变得容易。

异步系统调用的缺点是系统调用的返回并不代表系统调用应该完成的工作实际完成了。举个例子，如果你创建了一个文件并写了一些数据然后关闭文件并在console想用户输出done，最后你把电脑的电给断了。尽管所有的系统调用都完成了，程序也输出了done，但是在你重启之后，你的数据不一定还在。这意味着，在异步系统调用的世界里，如果应用程序关心可能发生的crash，那么应用程序代码应该更加的小心。这在XV6并不是什么大事，因为如果XV6中的write返回了，那么数据就在磁盘上，crash之后也还在。而ext3中，如果write返回了，你完全不能确定crash之后数据还在不在。所以一些应用程序的代码应该仔细编写，例如对于数据库，对于文本编辑器，我如果写了一个文件，我不想在我写文件过程断电然后再重启之后看到的是垃圾文件或者不完整的文件，我想看到的要么是旧的文件，要么是新的文件。

所以文件系统对于这类应用程序也提供了一些技术以获取crash之后可预期的结果。这里的工具是一个系统调用，叫做fsync，所有的UNIX都有这个系统调用。这个系统调用接收一个文件描述符作为参数，它会告诉文件系统去完成所有的与该文件相关的所有写磁盘操作，在所有的数据都确认写入到磁盘之后，再从系统调用中返回。所以如果你查看数据库，文本编辑器或者一些非常关心数据的应用程序的源代码，你将会看到精心放置的对于fsync的调用。fsync可以帮助对抗异步系统调用。对于大部分程序，例如编译器，如果crash了编译器的输出丢失了其实没什么，所以许多程序并不会调用fsync，并且乐于获得异步系统调用带来的高性能。

> 学生提问：这是不是有时也被称为flush，因为我之前经常听到这个单词？
>
> Robert教授：是的，一个合理的解释fsync的工作的方式是，它flush了所有文件相关的写磁盘操作到了磁盘中，之后再返回，所以flush也是针对这个场景的一个合理的单词。

![](../.gitbook/assets/image%20%28669%29.png)

以上就是异步系统调用，下一个ext3使用的技术是batching。在任何时候，ext3只会有一个“open” transaction。ext3中的一个transaction可以包含多个不同的系统调用。所以ext3是这么工作的：它首先会宣告要开始一个新的transaction，接下来的几秒所有的系统调用都是这个大的transaction的一部分。我认为默认情况下，ext3每5秒钟都会创建一个新的transaction，所以每个transaction都会有5秒钟内的系统调用，所有的系统调用都打包（batch）在一起。在5秒钟结束的时候，ext3会commit这个包含了数百个更新的大transaction。

为什么这是个好的方案呢？

* 首先它在多个系统调用之间分摊了transaction带来的固有的损耗。固有的损耗包括写transaction的descriptor block和commit block；在一个机械硬盘中需要查找log的位置并等待磁碟旋转。这些都是成本很高的操作，现在只需要对一批系统调用执行一次，而不是对每个系统调用执行一次，所以batching可以降低这些损耗带来的影响。
* 另外，它可以更容易触发write absorption。经常会有这样的情况，你有一堆系统调用最终在反复更新相同的一组磁盘block。举个例子，如果我创建了一些文件，我需要分配一些inode，inode或许都很小只有64个字节，一个block包含了很多个inode，所以同时创建一堆文件只会影响几个block的数据。类似的，如果我向一个文件写一堆数据，我需要申请大量的data block，我需要修改表示block空闲状态的bitmap block中的很多个bit位，如果我分配到的是相邻的data block，它们对应的bit会在同一个bitmap block中，所以我可能只是修改一个block的很多个bit位。所以一堆系统调用可能会反复更新一组相同的磁盘block。通过batching，多次更新同一组block会先快速的在内存的block cache中完成，之后在transaction结束时，一次性的写入磁盘的log中。这被称为write absorption，相比一个类似XV6的同步文件系统，它可以极大的减少写磁盘的总时间。
* 最后就是disk scheduling。假设我们要向磁盘写1000个block，不论是在机械硬盘还是SSD（机械硬盘效果会更好），一次性的向连续磁盘位置写入1000个block，



