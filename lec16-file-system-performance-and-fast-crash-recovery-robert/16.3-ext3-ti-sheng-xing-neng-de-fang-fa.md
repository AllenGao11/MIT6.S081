# 16.3 ext3提升性能的方法

ext3通过3种方式提升了性能：

* 首先，它提供了异步的（asynchronous）系统调用，也就是说系统调用在写入到磁盘之前就返回了，系统调用只会更新缓存在内存中的block，并不用等待写磁盘操作。不过它可能会等待读磁盘。
* 第二，它提供了batching，可以将多个系统调用打包成一个transaction。
* 最后，它提供了并发（concurrency）。

![](../.gitbook/assets/image%20%28677%29.png)

这些基本上就是ext3有的，而XV6没有的特性。接下来我将一一介绍这里的特性。

> 学生提问：有关batching，XV6不是也支持多个系统调用同时执行start\_op和end\_op，然后再一起commit吗？
>
> Robert教授：是的，XV6具备有限能力的batching。

首先是异步的系统调用。这表示系统调用修改完在缓存中的block之后就返回，并不会出发写磁盘。所以这里明显的优势就是系统调用能够快速的返回。同时它也使得I/O可以并行的运行，也就是说应用程序可以调用一些文件系统的系统调用，来让文件系统完成一些列磁盘操作，但是之后应用程序可以从系统调用中返回并继续运算，与此同时文件系统并行的会完成被之前的系统调用所要求的的写磁盘操作。这被称为I/O concurrency，如果没有异步系统调用，很难获得I/O concurrency，或者说很难同时进行磁盘操作和应用程序运算，因为同步系统调用中，应用程序总是要等待磁盘操作结束。

另一个异步系统调用带来的好处是，它使得大量的batching变得容易。

异步系统调用的缺点是系统调用的返回并不代表系统调用应该完成的工作实际完成了。举个例子，如果你创建了一个文件并写了一些数据然后关闭文件并在console想用户输出done，最后你把电脑的电给断了。尽管所有的系统调用都完成了，程序也输出了done，但是在你重启之后，你的数据不一定还在。这意味着，在异步系统调用的世界里，如果应用程序关心可能发生的crash，那么应用程序代码应该更加的小心。这在XV6并不是什么大事，因为如果XV6中的write返回了，那么数据就在磁盘上，crash之后也还在。而ext3中，如果write返回了，你完全不能确定crash之后数据还在不在。所以一些应用程序的代码应该仔细编写，例如对于数据库，对于文本编辑器，我如果写了一个文件，我不想在我写文件过程断电然后再重启之后看到的是垃圾文件或者不完整的文件，我想看到的要么是旧的文件，要么是新的文件。

所以文件系统对于这类应用程序也提供了一些技术以获取crash之后可预期的结果。这里的工具是一个系统调用，叫做fsync，所有的UNIX都有这个系统调用。这个系统调用接收一个文件描述符作为参数，它会告诉文件系统去完成所有的与该文件相关的所有写磁盘操作，在所有的数据都确认写入到磁盘之后，再从系统调用中返回。所以如果你查看数据库，文本编辑器或者一些非常关心数据的应用程序的源代码，你将会看到精心放置的对于fsync的调用。fsync可以帮助对抗异步系统调用。对于大部分程序，例如编译器，如果crash了编译器的输出丢失了其实没什么，所以许多程序并不会调用fsync，并且乐于获得异步系统调用带来的高性能。

> 学生提问：这是不是有时也被称为flush，因为我之前经常听到这个单词？
>
> Robert教授：是的，一个合理的解释fsync的工作的方式是，它flush了所有文件相关的写磁盘操作到了磁盘中，之后再返回，所以flush也是针对这个场景的一个合理的单词。

![](../.gitbook/assets/image%20%28669%29.png)

以上就是异步系统调用，下一个ext3使用的技术是batching。在任何时候，ext3只会有一个“open” transaction。ext3中的一个transaction可以包含多个不同的系统调用。



