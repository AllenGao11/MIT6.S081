# 16.4

接下来我们大概过一下Linux中的文件系统代码，并介绍某种程度的抽象上每个系统调用的结构。假设你有一个unlink系统调用，你们应该在XV6中对这个系统调用挺熟悉的了。我们需要每个系统调用都表明这是一些列写操作的开始，实际上在任何transaction系统中，都需要明确的表示开始和结束，这样在之间的的所有内容都是原子的。所以系统调用中会调用start函数。ext3需要知道当前正在进行的系统调用个数，我稍后会介绍这里的原因。所以每个系统调用在调用了start函数之后，会得到一个handle，它某种程度上唯一识别了当前系统调用。当前系统调用的所有写操作都是通过这个handle来识别跟踪的。

![](../.gitbook/assets/image%20%28677%29.png)

之后系统调用需要读写block，它可以通过get获取block在buffer中的缓存，同时告诉handle这个block需要被读或者被写。如果你需要更改多个block，类似的操作可能会执行多次。之后是修改位于缓存中的block。

![](../.gitbook/assets/image%20%28671%29.png)

当这个系统调用结束时，它会调用stop函数，并将handle作为参数传入。

![](../.gitbook/assets/image%20%28670%29.png)

除非transaction中所有已经开始的系统调用都完成了，transaction不能commit的。因为可能有多个transaction，文件系统需要有种方式能够记住系统调用属于哪个transaction，这样当系统调用结束时，文件系统就知道这是哪个transaction正在等待的某个系统调用，所以handle需要作为参数传递给stop函数。

因为每个transaction都有一堆block与之关联，修改这些block就是transaction的一部分内容，所以我们将handle作为参数传递给get函数是为了告诉logging系统，这个block是handle对应的transaction的一部分。

stop函数并不会导致transaction的commit，它只是告诉logging系统，当前的transaction少了一个正在进行的系统调用。transaction只能在所有已经开始了的系统调用都调用了stop之后才能commit。所以transaction需要记住所有已经开始了的handle，这样才能在系统调用结束的时候记录好。

