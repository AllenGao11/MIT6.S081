# 18.1 Monolithic kernel

今天我主要会讨论微内核（Mircro kernel）。首先我们来看一些背景知识并解释为什么人们会研究微内核。人们是在思考操作系统内核应该做什么事情的过程中设计出了微内核。XV6是一个Unix系统，它实现了Unix并提供了Unix系统调用。XV6按照Unix风格提供了各种功能，这就是我们设计XV6的目标。但是一个完全值得思考的问题是，一个内核应该具有什么功能？XV6和Linux具备的功能或许不是一个完美操作系统应该有的功能，又或许是呢。我们现在正在讨论一个变化莫测的领域，内核是一种对程序员的开发平台，而我们知道不同的程序员对于他们喜欢的编程平台有着非常不同的主观喜好。所以我们不能期望这个问题有一个完美的答案。但是我们可以期望从这个问题中学到一些东西，并且尝试想一下答案可能是什么。

首先，让我说明一下传统的系统实现方式以及应该具备的功能。我个人将Linux，Unix，XV6称为用传统方法实现的操作系统。另一个形容这些操作系统的词是monolithic。monolithic的意思是，操作系统内核是一个完成了各种事情的大的程序。实际上，这也反应了人们觉得内核应该具备什么样的功能。类似于Linux的典型操作系统内核提供了功能强大的抽象。它们选择提供例如文件系统这样一个及其复杂的组件，并且将文件，目录，文件描述符作为文件系统的接口，而不是直接将磁盘硬件作为接口暴露给应用程序。monolithic内核通常拥有例如文件系统这样的大的抽象概念。而提供功能强大的抽象而不是一些简单的抽象有一些巨大的优势。

其中一个好处是，这些高度抽象的接口通常是可移植的，你可以在各种各样的存储上实现文件和目录，你可以使用文件和目录而不用担心它们是运行在什么牌子的磁盘之上，或许是SSD，或许是HDD，或许是NFS，它们都拥有相同的接口，因为文件系统接口是高度抽象的。所以这的一个好处是可以获取可移植性。你可以写一个应用程序并运行在各种各样的硬件之上，而不用修改应用程序。

另一个例子是，Linux/Unix提供地址空间的抽象，而不是提供对于MMU硬件的直接访问权限。这不仅对于可移植性是有用的，并且可以向应用程序隐藏复杂性。所以操作系统具备强大抽象的另一个好处是，它们可以向应用程序隐藏复杂性。举个例子，XV6提供的文件描述符非常简单，你只需要对文件描述符调用读写就可以，但是在XV6内核中是非常复杂的代码来实现读写磁盘上的文件系统。这对于程序员是极好的，但是内核却因此变得又大又复杂。

这里的大的抽象还可以帮助管理共享资源。例如我们将内存管理委托给了内核，内核会跟踪哪些内存是空闲的。类似的，内核还会跟踪磁盘的哪个部分是空闲的，磁盘的哪个部分正在被使用，这样应用程序就不用考虑这些问题，所以这可以帮助简化应用程序。同时也可以提供健壮性和安全性，因为如果允许应用程序决定磁盘的某个位置是否是空闲的，那么应用程序或许可以使用一个已经被其他应用程序使用的磁盘位置。所以，内核负责资源管理可以提供资源共享能力和安全性。但是同样的，这也使得内核变得更大。

内核提供的这些诱人的抽象能力，使得内核包含了很多的复杂性，进而导致内核很大且复杂。

![](../.gitbook/assets/image%20%2831%29.png)

有关monolithic系统的另一个好处是，因为所有这些功能都在一个程序里面，所有的内核子系统，例如文件系统，内存分配，调度器，虚拟内存系统都是集成在一个巨大的程序中的一个部分，这意味着它们可以访问彼此的数据结构，这使得依赖多个子系统的工具更容易实现。举个例子，exec系统调用依赖文件系统，因为它要从磁盘中读取二进制文件并加载到内存中，同时它也依赖内存分配和虚拟内存系统，因为它需要设置好新的进程的地址空间。但是它实现起来很简单，在XV6或者Linux中做到这些完全没问题，因为这些操作系统已经在内核程序中包含了文件系统和虚拟内存系统。如果严格分隔了文件系统和虚拟内存系统，那么实现类似exec的系统调用会难得多。但是在一个monolithic操作系统中，因为本身就是一个大的程序，实现起来会容易的多。

另一个使得类似于XV6或者Linux的操作系统中可以更简单实现软件的原因是，内核的所有代码都以完整的硬件权限在运行。举个例子整个XV6都运行在Supervisor mode。这意味着你可以读写任意内存地址。所有的内核代码都以最大的权限在运行。对于类似Linux的操作系统也是这样。

所以，这种设计策略对于内核开发人员来说非常方便，并且也更容易构建更大的抽象，进而对于应用程序开发人员来说也更容易。然而，对于传统的monolithic方法，也有一些缺点。这也是出现其他内核架构，比如说微内核的动机。所以这里的问题是，为什么不使用monolithic内核呢？

第一个原因是它们大且复杂。取决于你怎么计算，Linux总是有数十万到数百万行代码。Linux的一部分可以查看Linux的另一个部分的数据，的确使得编程更加容易，但是同样也使得内部代码有大量的交互和依赖。有的时候查看并弄明白Linux代码会有点挑战。任何时候你有了一个大的程序，尤其它们还具有复杂的结构，你都会有Bug，操作系统内核也不例外。在这些年，内核有过各种各样的Bug，包括了安全性相关的Bug。

![](../.gitbook/assets/image%20%2862%29.png)

所以这是一个令人烦恼的关系图，如果你使用了大的内核，你不可避免的会遇到Bug和安全漏洞。

