# 18.7

你应该问自己，从论文中可以学到有关微内核的什么呢？

对于我们来说，论文中有很多有趣的有关微内核如何运行，有关Linux如何运行的小的知识点，你该如何设计这么一个系统。在一个更大的世界中，人们想从这篇论文中得到一些教训。论文并没有回答这个问题：微内核是不是一个好的主意？论文讨论的是微内核是否有足够的性能以值得使用。这里的原因是，在论文发表的前5-10年，有一场著名的测试针对之前的微内核，一种更早的叫做MACH的微内核。它也运行了与L4类似的结构，但是内部的设计完全不一样。通过设计发现，当按照前一节的配置运行时，MACH明显慢于普通的Unix。这里有很多原因，比如IPC系统并没有如你期望的一样被优化，这样会有更多的用户空间和内核空间的转换，cache-miss等等。有很多原因使得MACH很慢。但是很多人看到了这个测试结果并发现MACH慢于原生的操作系统，并坚信微内核是无助的低效，几乎不可能足够快，且足够有竞争力。我们应该都是用monolithic kernel。

今天的论文像是对于这种争论的一个反驳，论文中的观点是，你可以构建上一节的架构，如果你花费足够的精力去优化性能，你可以获取相比原生操作系统有竞争力的性能。因此，你不能只是因为性能就忽略微内核。你或许因为其他原因不喜欢它们，但是你不能使用性能作为拒绝它们的原因。

达成这一点的一个重要部分是，IPC被优化的快得多了，相应的技术在18.5中提到过。你可以从论文的表二看到。

![](../.gitbook/assets/image%20%28402%29.png)

表二对比了运行在硬件上的原生Linux，调用一个简单的系统调用getpid花费1.7us，对于上一节的实现，需要发送一个IPC request，并获取一个IPC response，以实现getpid系统调用，这需要花费4us。这是原生Linux的两倍，因为这里有两倍的工作，这里涉及到两次用户空间到内核空间的切换，而不是一个简单的系统调用。这也说明L4已经将这种基于IPC的系统调用的代价降到了最低，也就是2倍于一个原生Linux的系统调用。因此，它可以做的大概与你期望的一样好。

当然这里的系统调用仍然只有原生Linux一半的速度，并且这里并不清晰，除非你做一些测试来看是否系统调用都花费两倍时间是否是一个灾难，还是并没有问题。或许是个问题，如果你执行大量的系统调用，或许不是个问题，如果你执行了相对较少的系统调用，或者系统调用本身就有很多工作，或许你的系统调用比getpid要复杂的多。论文中的答案在使用AIM做的测试结果图八中:

![](../.gitbook/assets/image%20%28780%29.png)

AIM会执行各种系统调用，read/write文件，创建进程等等。从图八可以看出，AIM设置的一个更完整的应用，之比原生Linux慢几个百分点。因此，理想情况下你可以期望你想运行在计算机上行的应用，在L4+Linux可以运行的几乎一样快，相比运行在一个原生操作系统上。因为可以以近似原生Linux的速度运行，所以你们应该认真对待微内核。这是一个非常不错的结果，有点超出预期。让时间快进20年，如果之前所说，人们实际上在一些嵌入式系统使用L4，尤其在智能手机里有很多L4实例在运行。虽然看不见，但是都运行了各种定制化的软件，它们与Unix并没有兼容性。



