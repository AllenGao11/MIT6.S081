# 18.5 IPC Speed

接下来我们讨论微内核里面一个潜在的严重问题，IPC的速度。首先让我展示一个非常简单，但是也非常慢的设计。这个设计基于Unix Pipe。我之所以介绍这种方法，是因为一些早期的微内核以一种类似的方式工作，而我将展示这种方式实际上很慢。

假设我们有两个进程，P1和P2，P1想要给P2发送消息。这里该怎么工作呢？一种可能是使用Send系统调用，传入你想发送消息到的线程的ID，以及你想发送消息的指针。这个系统调用会跳到内核中，或许我们是基于XV6的pipe来设计，所以你可以想想会有一个等待缓存。或许P2正在做一些其他的事情，并没有准备好处理P1的消息。所以消息会被先送到内核的等待缓存中。当你调用send系统调用，它会将你的消息追加到一个缓存中等待P2来接收它。实际上几乎总是，在这些系统中，你很少会只想要发送一个消息，你几乎总是想要得到一个回复。所以P1在调用完send系统调用之后，会立即调用recv来获取回复。但是现在，让我们假设我们发送的就是单向的IPC，send会将你的消息追加到位于内核的缓存中，我们需要从用户空间将消息逐字节的拷贝到内核的缓存中。之后再返回，这样P1可以做一些其他的事情，或许准备好接受回复消息。

![](../.gitbook/assets/image%20%28490%29.png)

过了一会，P2可以接收消息了，它会调用recv系统调用，这个系统调用会返回消息发送线程的ID，并将消息从内核拷贝到P2的内存中。所以这里会从内核缓存中取出最前的消息，并拷贝到P2的内存中，之后再返回。

![](../.gitbook/assets/image%20%28484%29.png)

这种方式被称为异步，因为P1发完消息之后，只是缓存队列中追加了一下，并没有等待任何事情就返回了。并且这也被称作是buffered system，因为内核在发送消息时将每条消息都拷贝到了内部的缓存中，之后当接收消息时，又从buffer中将消息拷贝到了目标线程。所以这种方法是异步buffered。

![](../.gitbook/assets/image%20%28402%29.png)

如果P1要完成一次完整的消息发送和接收，那么P1会先调用send，send返回之后，假设有两个buffer一个用来发送消息，一个用来接收消息。之后P1会立即调用recv，recv会等待接收消息的buffer出现数据，所以P1会出让CPU。在一个单CPU的系统中，只有这时P1可以出让CPU，并且P2可以运行。论文中的讨论是基于单核系统。所以P1先执行，之后P1不再执行，出让CPU并等待回复消息。这时，P2才会被调度，之后P2调用recv，拷贝消息。之后P2自己再调用send将回复消息追加到buffer，之后P2的send系统调用返回，假设在某个时间P2会出让CPU，或许定时器中断会触发，之后P1可以回复运行，内核发现在接收消息buffer有了一条消息，会返回到用户空间。

![](../.gitbook/assets/image%20%28350%29.png)

这意味着，在这个慢的设计中，为了让消息的发送和回复包含的4个系统调用，两个send，两个recv，对应的8个用户态内核态之间的切换，其中每一个都明显很慢，在recv的时候，需要通过sleep来等待数据出现，并且需要一次线程调度和context switching来从P1切换到P2。每一次用户态和内核态之间的切换和context switching都很费时，因为每次用户态和内核态之间切换，都需要切换Page Table，进而清空TLB，也就是虚拟内存的查找缓存，这会使得操作费时。所以这是一种非常慢的实现方式，它包含了大量的用户态和内核态之间的切换，消息的拷贝，缓存的分配等等。实际中，对于这的场景，你发送了一个消息并期待收到回复，你可以抛开这种方法并获得简单的多的设计，L4就是采用了后者。

这种方法在一篇著名的论文中有提到，论文是[Improving IPC by Kernel Design](https://www.cse.unsw.edu.au/~cs9242/19/papers/Liedtke_93.pdf)，这篇论文在今天要讨论的论文前几年发布。它有几点不同：

其中一点是，它是同步的（Synchronized）。所以这里不会丢下消息并等待另一个进程去获取消息，这里的send会等待消息被接收，并且recv会等待消息被发送。如果我是进程P1，我想要发送消息，我会调用send。send并不会拷贝我的消息到buffer中，P1的send会等待P2调用recv。P2要么已经在内核中等待接收消息，要么P1的send就要等P2的下一次recv。当P1和P2都到达了内核中，也就是P1因为调用send进入内核，P2因为调用recv进入内核，这时才会发生一些事情。这种方式快的一个原因是，如果P2已经在recv中，P1在内核中执行send可以直接调回到P2的用户空间，就像是从recv中返回一样，这样就不用context switch或者线程调度。相比保存寄存器，出让CPU，线程调度找到一个新的进程来运行，这是内核中一种快得多的方式。P1的send知道有一个正在等待的recv，它会立即跳转到P2，就像P2从自己的recv系统调用返回一样。这种方式也被称为unbuffered。它可以做到不需要buffer一部分原因是因为它是同步的。

![](../.gitbook/assets/image%20%2862%29.png)

当send和recv都在内核中时，内核可以直接将消息从用户空间拷贝到用户空间，而不用先拷贝到内核中，再从内核中拷出来

