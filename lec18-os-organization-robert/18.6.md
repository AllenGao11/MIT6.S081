# 18.6 Run Linux on top of L4 micro kernel

以上的优化使得人们开始认真考虑用微内核替代monolithic kernel。然而，这里仍然有个问题，即使IPC很快了，操作系统的剩余部分从哪里去获取？现在的内核大概只有一个完整操作系统的百分之几，我们该怎么处理操作系统剩下的部分？这个问题通常会在一些有着相对较少资源的学校研究项目中被问到。我们需要从某个地方获取到所有这些用户空间服务，实际上存在一些特殊的应用程序，以上问题不是问题，比如说我们运行一些设备的控制器，例如车里的点火控制器，只运行了几千行代码，并且不需要一个文件系统，这样我们就可以只需要很少的用户空间内容，微内核也特别适合这种应用程序。但是微内核项目发起时，人们非常有雄心壮志，人们想的是完全替换操作系统，人们系统可以构建一些可以运行在工作站，服务器等各种地方的操作系统，并取代大的monolithic kernel。对于这种场景，你需要一个操作系统所需要的所有内容。一种可能是，重新以微内核的方式，以大量的进程实现所有的内容。实际上有项目在这么做，但是这涉及到大量的工作。

更具体的说，人们想要运行，比如我用笔记本，必须要有emacs，比如要有我最喜欢的C编译器，否则我肯定不会用你的操作系统。这意味着，微内核要想获得使用，它必须支持现有的应用程序，它必须兼容或者提供相同的系统调用或者更高层的服务接口，它必须完全兼容一些现有的操作系统，例如Unix，Linux，这样人们才愿意切换到微内核。所以这些微内核项目都面临一个具体的问题，它们怎么兼容一些为Linux，Windows写的现有的一些应用程序，对于论文中提到的项目，也就是L4，对标的是Linux。与其写属于自己的，完全新的用户空间服务，并模仿Linux，论文中决定采用一种容易的多的方法，其实许多项目都采用这种方法，也就是简单的将一个现有的monolithic kernel运行在微内核之上，而不是重新实现一个新的东西。这就是今天论文要介绍的内容。

在今天论文的讨论中，L4微内核位于底部，但是同时，一个完整的Linux作为一个巨大的服务运行在用户空间进程中。挺起来有点奇怪，Linux kernel现在是一个用户空间进程，一般的kernel都是运行在硬件之上。

![](../.gitbook/assets/image%20%28440%29.png)

实际上，如你在运行QEMU上运行XV6时所见，内核也是运行在用户空间。Linux kernel不过就是一个程序，对其做一些修改它就可以运行在用户空间。所以Linux需要被修改，论文中需要对Linux的底层做一些修改，例如Linux中期望能直接修改Page Table的代码，读写CPU寄存器。所以Linux中一部分需要被修改以将它们改成调用系统调用，或者发送IPC，而不是直接访问硬件。但是Linux的大部分都可以直接运行，而不需要做修改。所以，作为Linux的一部分，现在得到了文件系统，网络支持，各种设备驱动等等，而不需要自己实现这些。

![](../.gitbook/assets/image%20%28805%29.png)

这里的设置方式是，Linux内核作为一个L4 Task运行，每一个Linux进程又作为一个独立的L4 Task运行。所以当你登录到Linux中时，你要他运行一个Shell或者terminal，它会创建一个L4 Task在用户空间来运行这个Linux程序。所以现在有一个Task运行Linux，以及N个Task来运行每一个你在Linux中启动的进程。

![](../.gitbook/assets/image%20%28483%29.png)

Linux不会直接修改进程的Page Table，而是会向L4发送正确的IPC来使得L4来修改进程的Page Table。

这里有很多小的改动，其中一个有意思的地方是，当VI想要执行一个系统调用时，VI并不知道它运行在L4之上，在上面的方案中，所有的程序都以为它们运行在Linux中。当VI要执行系统调用时，L4并不支持，因为它执行的是Linux系统调用而不是L4系统调用。所以对于Linux进程，会有一个小的库与之关联，这个库会将类似于fork，exec，pipe，read，write的系统调用，转换成发送到Linux Task的IPC消息，并等待Linux Task的返回，再返回到进程中，看起来好像就是系统调用返回了。所以这些小的库会将系统调用转成发送到Linux的IPC消息。这意味着，如果Linux Task没有做其他事情的话，它会在一个recv系统调用中等待接收从任何一个进程发来的下一个系统调用请求IPC。

![](../.gitbook/assets/image%20%2890%29.png)

这导致了这里的Linux和普通的Linux明显不同的工作方式。在普通的Linux中，就像XV6一样，会有一个内核线程对应每一个用户空间进程。当用户空间进程调用系统调用时，内核会为这个系统调用运行一个内核线程。并且，在普通的Linux中，如果内核在内核线程之间切换，这基本上意味着从一个用户进程切换到另一个用户进程。所以这里有一对一的关系：Linux kernel运行在内核线程以及当Linux完成工作之后要运行的用户进程。

在这里，这种关系断了，这里的Linux运行在一个L4线程中，所以一次只有一个线程在Linux中运行。然而，就像XV6一样，这个控制线程会使用与XV6中的context switch非常相似的技术，在于每个用户进程对应的内核线程之间切换。这些内核线程完全是在Linux中实现的，与L4线程毫无关系，唯一的L4线程就是控制线程。

![](../.gitbook/assets/image%20%28580%29.png)

但是哪个用户进程可以运行，是由L4决定的。所以在这里的设置中，Linux或许在内核线程中执行来自VI的系统调用，同时，L4又使得Shell在用户空间运行了。这在XV6或者Linux极不可能发生，在这两个系统中活跃的内核线程和用户进程有直接的对应关系。而L4会运行它喜欢的任何Task，在Linux kernel中的线程都是私有的实现，Linux可以并发的在不同阶段执行多个系统调用，或许一个进程在它的内核线程中在等待磁盘，Linux可以运行另一个进程的内核线程来处理另一个进程的系统调用。

你或许会想知道为什么不直接使用L4线程，来实现Linux内的内核线程，或者说Linux为什么要实现自己内部的内核线程，而不是使用L4线程，答案是，

* 在论文发表时，还没有用到多核CPU硬件，他们使用的是单核CPU硬件。所以在内核中同时运行多个内核线程并没有性能优势，因为只有一个CPU核，所以第二个线程不能执行，由于硬件的限制，一次只能执行一个线程。
* 另一个或许是更强大的原因是，在论文发表时，他们使用的Linux版本并不支持将Linux kernel运行在多个CPU核上。所以他们使用的是旧版本的单核Linux，一次只能期望在内核中使用一个CPU。它并没有类似于XV6的spinlock，这使得它能正确的在内核中使用多核。所以并没有性能优势来在Linux内核中使用多个L4线程。但是如果使用的话，在没有性能优势的前提下，又需要加入spinlock和其他的内容来支持并发。所以没有在Linux内核使用L4线程。

这种架构的一个缺点是，在你会运行在笔记本电脑中的普通原生的Linux中，有大量复杂的调度机制可以做例如在不同进程上增加优先级，各种确保调度公平性。Linux可以在你的笔记本上运行这些机制，因为Linux控制了哪些进程可以运行在哪些CPU核上。但是在这里的架构中，Linux完全控制不了哪些进程可以运行，因为现在是L4在完成调度而不是Linux，这些进程都是被L4所调度。所以这里的架构失去了Linux的调度能力，这是这种架构的缺点，我相信L4的后续版本有一些方法能够让Linux通知L4调度器，来给某个进程更高优先级等等。所以现在有点奇怪。

