# 18.6

以上的优化使得人们开始认真考虑用微内核替代monolithic kernel。然而，这里仍然有个问题，即使IPC很快了，操作系统的剩余部分从哪里去获取？现在的内核大概只有一个完整操作系统的百分之几，我们该怎么处理操作系统剩下的部分？这个问题通常会在一些有着相对较少资源的学校研究项目中被问到。我们需要从某个地方获取到所有这些用户空间服务，实际上存在一些特殊的应用程序，以上问题不是问题，比如说我们运行一些设备的控制器，例如车里的点火控制器，只运行了几千行代码，并且不需要一个文件系统，这样我们就可以只需要很少的用户空间内容，微内核也特别适合这种应用程序。但是微内核项目发起时，人们非常有雄心壮志，人们想的是完全替换操作系统，人们系统可以构建一些可以运行在工作站，服务器等各种地方的操作系统，并取代大的monolithic kernel。对于这种场景，你需要一个操作系统所需要的所有内容。一种可能是，重新以微内核的方式，以大量的进程实现所有的内容。实际上有项目在这么做，但是这涉及到大量的工作。

更具体的说，人们想要运行，比如我用笔记本，必须要有emacs，比如要有我最喜欢的C编译器，否则我肯定不会用你的操作系统。这意味着，微内核要想获得使用，它必须支持现有的应用程序，它必须兼容或者提供相同的系统调用或者更高层的服务接口，它必须完全兼容一些现有的操作系统，例如Unix，Linux，这样人们才愿意切换到微内核。所以这些微内核项目都面临一个具体的问题，它们怎么兼容一些为Linux，Windows写的现有的一些应用程序，对于论文中提到的项目，也就是L4，对标的是Linux。与其写属于自己的，完全新的用户空间服务，并模仿Linux，论文中决定采用一种容易的多的方法，其实许多项目都采用这种方法，也就是简单的将一个现有的monolithic kernel运行在微内核之上，而不是重新实现一个新的东西。这就是今天论文要介绍的内容。

在今天论文的讨论中，L4微内核位于底部，但是同时，一个完整的Linux作为一个巨大的服务运行在用户空间进程中。挺起来有点奇怪，Linux kernel现在是一个用户空间进程，一般的kernel都是运行在硬件之上。

![](../.gitbook/assets/image%20%28402%29.png)

实际上，如你在运行QEMU上运行XV6时所见，内核也是运行在用户空间。Linux kernel不过就是一个程序，对其做一些修改它就可以运行在用户空间。所以Linux需要被修改，论文中需要对Linux的底层做一些修改，例如Linux中期望能直接修改Page Table的代码，读写CPU寄存器。所以Linux中一部分需要被修改以将它们改成调用系统调用，或者发送IPC，而不是直接访问硬件。但是Linux的大部分都可以直接运行，而不需要做修改。所以，作为Linux的一部分，现在得到了文件系统，网络支持，各种设备驱动等等，而不需要自己实现这些。

![](../.gitbook/assets/image%20%28726%29.png)

这里的设置方式是，Linux内核作为一个L4 Task运行，每一个Linux进程又作为一个独立的L4 Task运行。所以当你登录到Linux中时，你要他运行一个Shell或者terminal，它会创建一个L4 Task在用户空间来运行这个Linux程序。所以现在有一个Task运行Linux，以及N个Task来运行每一个你在Linux中启动的进程。

![](../.gitbook/assets/image%20%28480%29.png)

Linux不会直接修改进程的Page Table，而是会向L4发送正确的IPC来使得L4来修改进程的Page Table。

这里有很多小的改动，其中一个有意思的地方是，当VI想要执行一个系统调用时，VI并不知道它运行在L4之上，在上面的方案中，所有的程序都以为它们运行在Linux中。当VI要执行系统调用时，L4并不支持，因为它执行的是Linux系统调用而不是L4系统调用。所以对于Linux进程，会有一个小的库与之关联，这个库会将类似于fork，exec，pipe，read，write的系统调用，转换成发送到Linux Task的IPC消息，并等待Linux Task的返回，再返回到进程中，看起来好像就是系统调用返回了。所以这些小的库会将系统调用转成发送到Linux的IPC消息。这意味着，如果Linux Task没有做其他事情的话，它会在一个recv系统调用中等待接收从任何一个进程发来的下一个系统调用请求IPC。

![](../.gitbook/assets/image%20%2890%29.png)

这导致了这里的Linux和普通的Linux明显不同的工作方式。在普通的Linux中，就像XV6一样，会有一个内核线程对应每一个用户空间进程。当用户空间进程调用系统调用时，内核会为这个系统调用运行一个内核线程。并且，在普通的Linux中，如果内核在内核线程之间切换，这基本上意味着从一个用户进程切换到另一个用户进程。所以这里有一对一的关系：Linux kernel运行在内核线程以及当Linux完成工作之后要运行的用户进程。

在这里，这种关系断了，这里的Linux运行在一个L4线程中，所以一次只有一个线程在Linux中运行。然而，就像XV6一样，这个控制线程会使用与XV6中的context switch非常相似的技术，在于每个用户进程对应的内核线程之间切换。这些内核线程完全是在Linux中实现的，与L4线程毫无关系，唯一的L4线程就是控制线程。但是哪个用户进程可以运行，是由L4决定的。

