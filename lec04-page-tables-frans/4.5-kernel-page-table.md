# 4.5 Kernel Page Table

接下来，我们看一下在XV6中，page table是如何工作的？首先我们来看一下内核page的分布。下图就是地址对应关系，左边是内核的虚拟地址空间，右边上半部分是物理内存或者说是DRAM，右边下半部分是I/O设备。接下来我会首先介绍右半部分，然后再介绍左半部分。

![](../.gitbook/assets/image%20%28169%29.png)

图中的右半部分完全由硬件决定，硬件设计者决定了这部分的结构。如你们上节课看到的一样，当操作系统启动时，会从地址0x80000000开始运行，这个地址其实也是由硬件设计者决定的。更具体的来说，如果你们看一个主板，

![](../.gitbook/assets/image%20%28163%29.png)

中间是RISC-V处理器，我们现在知道了处理器中有4个核，每个核都有自己的MMU和TLB。处理器旁边就是DRAM芯片。

![](../.gitbook/assets/image%20%28181%29.png)

主板的设计人员决定了，在完成了虚拟到物理地址的翻译之后，物理地址大于0x80000000会走向DRAM芯片，物理地址低于0x80000000会走向不同的I/O设备。所以是由这个主板的设计人员决定了物理结构。如果你想要查看这里的物理结构，你可以阅读主板的手册，手册中会一一介绍内存地址对应关系。

![](../.gitbook/assets/image%20%28161%29.png)

![](../.gitbook/assets/image%20%28145%29.png)

首先，地址0是保留的，地址0x10090000对应以太网，地址0x80000000对应DDR内存，也就是处理器外的易失存储（Off-Chip Volatile Memory），这里说的就是主板上的DRAM芯片。所以，在你们的脑海里记住这张图，即使我们接下来会基于你们都知道的C语言程序---QEMU来做介绍，最终所有的事情都是有主板硬件决定的。

> 学生提问：当你说这里是由硬件决定的，硬件是特指CPU还是说CPU所在的主板？
>
> Frans教授：CPU所在的主板。CPU只是主板的一小部分，DRAM芯片位于处理器之外。是主板设计者将处理器，DRAM和许多I/O设备汇总在一起。对于一个操作系统来说，CPU只是一个部分，I/O设备同样也很重要。所以当你在写一个操作系统时，你需要同时处理CPU和I/O设备，比如你需要向互联网发送一个报文，操作系统需要调用网卡驱动和网卡来实际完成这个工作。

回到最初那张图的右侧，物理地址的分布，可以看到最下面是未被使用的，这与主板文档内容是一致的（地址为0）。地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情是运行在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000，操作系统会确保那个地址有一些数据。

![](../.gitbook/assets/image%20%28179%29.png)

这里还有一些其他的I/O设备：

* PLIC是中断控制器（Platform-Level Interrupt Controller）我们下周的课会讲。
* CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器能够将这些中断路由到合适的处理函数。
* UART0（Universal Asynchronous Receiver/Transmitter）与Console和显示器交互。
* VIRTIO disk，与磁盘进行交互。

地址0x02000000对应CLINT，当你向这个地址执行读写指令，你是向实现了CLINT的芯片执行读写。这里你可以认为你直接在与设备交互，而不是读写物理内存。

> 学生提问：确认一下，低于0x80000000的物理地址，不存在于DRAM中，当我们在使用这些地址的时候，指令会直接走向其他的硬件。
>
> Frans教授：是的。高于0x80000000的物理地址对应DRAM芯片，对于以太网接口，也有一个特定的物理地址，我们可以对这个叫做Memory-mapped I/O执行读写指令。
>
>  学生提问：为什么物理地址最上面一大块标为未被使用？
>
> Frans教授：物理地址总共有2^56那么多，但是你不用在主板上接入那么多的内存，所以取决于主板上有多少DRAM芯片，一部分地址没有被用到。实际上在XV6中，我们限制了内存的大小是128MB。
>
> 学生提问：当读指令从CPU发出后，它是怎么路由到正确的I/O设备的？比如说，当CPU要发出指令时，它会说，好的现在地址是低于0x80000000，我该怎么将指令送到正确的I/O设备？
>
> Frans教授：你可以认为在RISC-V中有一个信号选择器。

接下来我会切换到第一张图的左边，这是XV6的虚拟内存地址，当机器刚刚启动时，还没有可用的page，XV6会设置好最初的page table，虚拟地址空间，这是内核使用的地址空间。这里就是地址空间的分布。

因为我们想让XV6尽可能的简单易懂，这里的虚拟地址到物理地址的映射，大部分是相等的关系。我这里的意思是，虚拟地址0x02000000对应物理地址0x02000000。内核会按照这种方式设置page table。这意味着低于PHYSTOP的虚拟地址，与右侧使用的物理地址是一样的。

![](../.gitbook/assets/image%20%28165%29.png)

所以，这里的箭头都是水平的，因为这里是完全相等的映射。

这里有两件重要的事情：

* 首先有一些page，一些映射在内存中的位置很高。比如kernel stack在内存中映射的位置很高，它很高的原因是在它之下有一个未被映射的Guard page。所以每一个kernel stack下面的PTE的Valid bit都没有设置，这样，如果内核用光了它的stack的内容，它会用到Guard page，但是因为Guard page的PTE中Valid 标志位未设置，会触发page fault。这样好过弄乱内核的其他内存内容。立即得到一个panic，你就知道stack出错了。同时我也又不想浪费物理内存给Guard page，所以我们将kernel stack的设置的很高，然后下面有一个空的Guard PTE在stack下面。Guard page不消耗任何物理内存，它只是占据了虚拟地址空间的一段高地址。但是这意味着kernel stack page被映射了两次，它在高地址映射了一次，在PHYSTOP下的Kernel Data中又直接映射了一次。

![](../.gitbook/assets/image%20%28183%29.png)

这是众多你可以通过page table实现的有意思的事情，你可以向同一个物理地址映射两次，你可以不映射一个虚拟地址到物理地址。可以是一对一的映射，一对多映射，多对一映射。XV6并没有使用太多，不过也至少在1-2个地方用到类似的技巧。这的kernel stack和Guard page就是XV6使用的有趣技巧的一个例子，主要是用来跟踪Bug。

第二件我讨论的事情是权限。例如Kernel text page被标位R-X，意味着你可以读它，也可以对它执行指令，但是你不能向Kernel text写数据。

