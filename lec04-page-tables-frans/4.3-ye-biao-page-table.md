# 4.3 页表（Page Table）

我们如何能够实现地址空间呢？或者说如何在一个物理内存上，创建不同的地址空间？

最常见的方法，同时也是非常灵活的一种方法就是使用页表（Page Tables）。页表是在硬件中通过处理器，或者通过内存管理单元（Memory Management Unit）实现。所以，在你们的脑海中，应该有这么一张图：CPU用来执行指令，例如_sd $7, \(a0\)。_

![](../.gitbook/assets/image%20%28185%29.png)

对于任何一条带有地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。假设寄存器a0中是地址0x1000，那么这是一个虚拟内存地址。虚拟内存地址会被转到内存管理单元（MMU，Memory Management Unit）

![](../.gitbook/assets/image%20%28145%29.png)

内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。

![](../.gitbook/assets/image%20%28148%29.png)

从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。

为了能够完成虚拟内存地址到物理内存地址的翻译，MMU会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。举个例子，虚拟内存地址0x1000对应了一个我编造的物理内存地址0xFFF0。这样的表单可以非常灵活。

![](../.gitbook/assets/image%20%28149%29.png)

通常来说，内存地址对应关系的表单也保存在内存中。所以CPU中需要有一些寄存器用来存放表单在物理内存中的地址。现在，在内存的某个位置保存了地址关系表单，我们假设这个位置的物理内存地址是0x10。那么在RISC-V上一个叫做SATP的寄存器会保存地址0x10。

![](../.gitbook/assets/image%20%28172%29.png)

这样，CPU就可以告诉MMU，可以从哪哪找到将虚拟内存地址翻译成物理内存地址的表单。

> 学生提问：所以MMU并不会保存页表，它只会从内存中读取页表，然后完成翻译，是吗？
>
> Frans教授：这就是你应该记在你脑海中的图片。页表保存在内存中，MMU只是会去查看页表，我们接下来会看到，页表比我们这里画的要稍微复杂一些。

这里的基本想法是每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，用来指向新的进程在内存中的地址对应表单。这样的话，cat程序和Shell程序的虚拟内存地址就可以翻译到不同的物理内存地址，因为每个应用程序都有属于自己的地址对应表单。这样说得通吗？

> 学生提问：刚刚说道SATP寄存器会根据进程而修改，我猜每个进程对应的SATP值是由内核保存的？
>
> Frans教授：是的。内核会写SATP寄存器，写SATP寄存器是一条特殊权限指令。所以，用户应用程序不能通过更新这个寄存器来更换一个地址对应表单，否则的话就会破坏隔离性。所以，只有运行在kernel mode的代码可以更新这个寄存器。

这里只是最基本的介绍，我们画的图还有之前做的解释都比较初级且存在不合理的地方。有一件事情我刚刚没有介绍，这里的表单是如何工作的？从刚刚画的图看来，对于每个虚拟地址，在表单中都有一个条目，如果我们真的这么做，表单会有多大？原则上说，在RISC-V上会有多少地址，或者一个寄存器可以保存多少个地址？寄存器是64bit的，所以有多少个地址呢？是的，2^64个地址，所以如果我们按照每个地址管理，表单会变得非常巨大。实际上，所有的内存都会被这里的表单耗尽，所以这一点也不合理。

当然，实际情况不可能是一个虚拟内存地址对应页表中的一个条目。接下来我将分两步介绍RISC-V中是如何工作的。

第一步：不要为每个地址创建一条表单条目，而是为每个page创建一条表单条目。所以每一次地址翻译都是针对一个page，而RISC-V中，一个page是4KB，也就是4096Bytes。这个大小非常常见，几乎所有的处理器都使用4KB大小的page或者支持4KB大小的page。

现在，内存地址的翻译方式略微的不同了。首先对于虚拟内存地址，我们将它划分为两个部分，index和offset，offset对应的是一个page中的哪个字节。

![](../.gitbook/assets/image%20%28161%29.png)

当MMU在做地址翻译的时候，通过读取虚拟内存地址中的index可以知道物理内存中的page号，这个page号对应了物理内存中的4096个字节。之后虚拟内存地址中的offset指向了page中的4096个字节，假设offset是12，那么page中的第12个字节被使用了。很多同学都提到了可以将offset加上page的起始地址，可以得到物理内存地址。

![](../.gitbook/assets/image%20%28138%29.png)

有关RISC-V的一件有意思的事情是，虚拟内存地址都是64bit，这也说的通，因为RISC-V的寄存器是64bit的，但是实际上，在我们使用的RSIC-V处理器上，并不是所有的64bit都被使用了，也就是说高25bit并没有被使用。这样的结果是限制了虚拟内存地址的数量，虚拟内存地址的数量现在只有2^39个，大概是512GB。当然，如果必要的话，最新的处理器或许可以支持更大的地址空间，只需要将未使用的25bit拿出来做为虚拟内存地址的一部分即可。

在剩下的39bit中，有27bit被用来当做index，12bit被用来当做offset。offset必须是12bit，因为对应了4096个字节。这就是虚拟内存地址。

![](../.gitbook/assets/image%20%28156%29.png)

在RISC-V中，物理内存地址是56bit。所以物理内存可以大于单个虚拟内存地址空间，但是也最多到2^56。大多数主板还不支持2^56这么大的物理内存，但是原则上，如果你能造出这样的主板，那么最多可以支持2^56字节的物理内存。

物理内存地址是56bit，其中44bit是物理page号（PPN，Physical Page Number），12bit是offset完全继承自虚拟内存地址（也就是地址转换，只需要将虚拟内存中的27bit翻译成物理内存中的44bit的page号即可）。

![](../.gitbook/assets/image%20%28136%29.png)

这里有什么问题吗？这里的内容还挺重要的，你们需要掌握这的内容才能做出下一个page table lab。

> 学生提问：我想知道4096字节作为一个page，这在物理内存中是连续的吗？
>
> Frans教授：是的，在物理内存中，这是连续的4096个字节。所以物理内存是以4096为粒度使用的。
>
> 同一个学生：所以offset才是12bit，这样就足够覆盖4096个字节？
>
> Frans教授：是的，page中的每个字节都可以被offset索引到。
>
> 同一个学生：图中的56bit又是根据什么确定的？
>
> Frans教授：这是由硬件设计人员决定的。所以RISC-V的设计人员认为56bit的物理内存地址是个不错的选择。可以假定，他们是通过技术发展的趋势得到这里的数字。比如说，设计是为了满足5年的需求，可以预测物理内存在5年内不可能超过2^56这么大。或许，他们预测是的一个小得多的数字，但是为了防止预测错误，他们选择了像2^56这么大的数字。这里说的通吗？很多同学都问了这个问题。
>
> 学生提问：如果虚拟内存最多是2^27（最多应该是2^39），而物理内存最多是2^56，这样我们可以有多个进程都用光了他们的虚拟内存，但是物理内存还有剩余，对吗？
>
> Frans教授：是的，完全正确。
>
> 学生提问：56bit的物理地址，是可能的内存位置吗？我不认为这是数据bit的数量，因为这是一个64bit的机器，硬件设计人员本可以用64bit但是却用了56bit。
>
> Frans教授：是的。选择56bit而不是64bit是因为在主板上只需要56根线。
>
> 学生提问：我们从CPU到MMU之后到了内存，但是不同的进程之间的区别是什么？比如说Shell进程在地址0x1000存了一些数据，之后ls进程也在地址0x1000也存了一些数据，我们需要将它们翻译成物理内存地址。
>
> Frans教授：SATP寄存器包含了需要使用的地址转换表的内存地址。所以ls有自己的地址转换表，cat也有自己的地址转换表。每个进程都有完全属于自己的地址转换表。

如果每个进程都有自己的地址转换表，那么每个地址转换表会有多大呢？

![](../.gitbook/assets/image%20%28160%29.png)

这个地址转换表最多会有2^27个条目（虚拟内存地址中的index），这是个非常大的数字。如果每个进程都用满了地址转换表，那么物理内存很快就会耗尽。由于这个地址转换表很大，如果都填满了意味着进程消耗了大量内存。

实际上，硬件并不是按照这里的方式来存储page table。从概念上来说，你可以认为虚拟内存地址转换表从0涨到2^27，但是实际上并不是这样。实际中，page table是一个多级的结构。下图是一个真正的RISC-V page table结构和硬件实现。

![](../.gitbook/assets/image%20%28167%29.png)

我们之前提到的虚拟内存地址中的27bit的index，实际上是由3个9bit的数字组成（L2，L1，L0）。前9个bit被用来索引最高级的page directory。

![](../.gitbook/assets/image%20%28158%29.png)

一个directory是4096Bytes，就跟page的大小是一样的。Directory中的一个条目被称为PTE（Page Table Entry）是64bits，就像寄存器的大小一样，也就是8Bytes。所以一个Directory page有512个条目。

![](../.gitbook/assets/image%20%28163%29.png)

所以实际上是，SATP寄存器会指向最高一级的page directory的物理内存地址，我们用虚拟内存中index的高9bit用来索引最高一级的page directory，这样我们就能得到一个PPN，也就是物理page号。这个PPN指向了下一级的page directory。

当我们在使用下一级的page directory时，我们使用虚拟内存地址中的L1部分。接下来会走到最低一级的page directory，我们使用虚拟内存地址中的L0部分。在最低一级的page directory，我们可以得到映射到虚拟内存地址的物理内存地址。

![](../.gitbook/assets/image%20%28177%29.png)

从某种程度上来说，与之前一张图还是很相似的，除了实际的索引是由3步，而不是1步完成。这种方式的主要优点是，如果地址空间中大部分地址都没有使用，你不必为每一个index准备一个条目。举个例子，如果你的地址空间只使用了一个page，4096Bytes。

![](../.gitbook/assets/image%20%28180%29.png)

除此之外，你没有使用任何其他的地址，只有0-4095的虚拟内存地址被使用了。现在，你需要多少个page table entry，或者page table directory来映射这一个page？

在最高一级，你需要一个page directory，这里面你需要一个数字是0的条目，指向下一级page directory。同时你也需要一个中间级的page directory，里面也是一个数字0的条目，指向最后一级page directory。所以这里总共需要3个page directory（也就是3 \* 512个条目）。

![](../.gitbook/assets/image%20%28155%29.png)

而在前一个方案中，我们需要2^27个条目，这个方案中，我们只需要3 \* 512个条目。这是实际上硬件采用这种层次化的3级page directory结构的主要原因。这里有什么问题吗？这部分还是很重要的。

> 学生提问：既然每个物理page的PPN是44bit，而物理地址是56bit，我们从哪得到缺失的12bit？（我猜这个学生要问这个，其实12bit直接从虚拟地址的12bit offset继承就可以了，但是可能这个问题太简单了，Frans教授似乎理解错了问题。）
>
> Frans教授：所有的page directory传递的都是PPN，对应的物理地址是44bit的PPN加上12bit的0。如果我们查看这里的PTE 条目（也就是page directory中的每一行），它们都有相同的格式，其中44bit是PPN，但是寄存器是64bit的，所有有一些bit是留空的。实际上，支持page的硬件在低10bit存了一些标志位用来控制地址翻译。

![](../.gitbook/assets/image%20%28173%29.png)



> 如果你把44bit的PPN和10bit的Flags相加是54bit，也就是说有10bit未被使用，这10bit被用来作为未来扩展。比如说某一天你有了一个新的RISC-V处理器，它的page table可能略有不同，或许有超过44bit的PPN。如果你看下面这张图，你可以看到，这里有10bit是作为保留字段存在的。

![](../.gitbook/assets/image%20%28154%29.png)

接下来，让我们看看PTE中的Flag，因为它也很重要。每个PTE的低10bit是一堆标志位：

* 第一个标志位是Valid。如果Valid bit位为1，那么表明这是一条合法的PTE，你可以用它来做地址翻译。对于刚刚举得那个小例子（应用程序只用了1个page 4096Bytes内存），只使用了3个page directory，每个page directory中只有第0个条目被使用了，所以只有第0个条目的Valid bit位会被设置成1，其他的511个条目的Valid bit为0。这个标志位告诉MMU，你不能使用这条PTE，因为这条PTE并不包含有用的信息。
* 下两个标志位分别是Readable和Writable。表明你是否可以读/写这个page。
* Executable表明你可以从这个page执行指令。
* User表明这个page可以被运行在用户空间的进程访问。
* 其他标志位并不是那么重要，他们偶尔会出现，前面5个是重要的标志位。

> 学生提问：我对于这里的3个page table有个问题。PPN是如何合并成最终的物理内存地址？
>
> Frans教授：我之前或许没有很直接的说这部分（其实是有介绍的）。在最高级的page directory中的PPN，包含了下一级page directory的物理内存地址，依次类推。在最后一级page directory，我们还是可以得到44bit的PPN，这里包含了我们实际上想要翻译的物理page地址。
>
> Frans教授：让我来问自己的一个有趣的问题，为什么是PPN存在这些page directory中？为什么不是一个虚拟内存地址？
>
> 某学生回答：因为我们需要在物理内存中查找下一个page directory的地址。
>
> Frans教授：是的，我们不能让我们的地址翻译依赖于另一个翻译，否则我们可能陷入递归的无限循环中。所以page directory必须存物理地址。那SATP呢？它存的是物理地址还是虚拟地址？
>
> 某学生回答：还是物理地址，因为最高级的page directory还是存在物理内存中，对吧。
>
> Frans教授：是的，这里必须是物理地址，因为我们要用它来完成地址翻译，而不是对它进行地址翻译。所以SATP需要知道最高一级的page directory的物理地址是。
>
> 学生提问： 这里有层次化的3个page table，每个page table都由虚拟地址的9个bit来索引，所以是由虚拟地址中的3个9bit来分别索引3个page table，对吗？
>
> Frans教授：是的，最高的9个bit用来索引最高一级的page directory，第二个9bit用来索引下一个page directory，第三个9bit用来索引第三个page directory。
>
> 学生提问：当一个进程请求一个虚拟内存地址时，CPU会查看SATP寄存器得到对应的最高一级page table，这级page table会使用虚拟内存地址中27bit index的最高9bit来完成索引，如果索引的结果为空，MMU会会创建一个page table吗？
>
> Frans教授：不会的，MMU会告诉操作系统或者处理器，抱歉我不能翻译这个地址，最终这会变成一个page fault。如果一个地址不能被翻译，那就不翻译。就像你在运算时除以0一样，处理器会拒绝那样做。
>
> 学生提问：我想知道我们是怎么计算page table的物理地址，是不是这样，我们从最高级的page table得到44bit的PPN，然后再加上虚拟地址中的12bit offset，就得到了完整的56bit page table物理地址？
>
> Frans教授：我们不会加上虚拟地址中的offset，这里只是使用了12bit的0。所以我们用44bit的PPN，再加上12bit的0，这样就得到了56bit的物理地址，这就是下一级page directory的地址。这里要求每个page directory都都与物理page对齐（也就是page directory的起始地址就是某个page的其实地址，所以低12bit都为0）。

这些都是很好的问题，你们在page table实验中都会遇到这些问题，现在问出来很好。

