# 14.2 File system API

为了理解文件系统必须提供什么能力，让我们再看一下基本的与文件系统相关的系统调用。从这些系统调用接口，我们可以推断出有关实现的一些细节。有关这些系统调用我们在之前的课程已经看过了，我们之前看过很多Unix系统调用，例如fork，exec，pipe等等。首先让我们来看一个简单的场景，假设我们创建了文件“x/y”，或者说在目录x中创建了文件y，同时我们需要提供一些标志位，现在我们还太关心标志位所以我会忽略它。

![](../.gitbook/assets/image%20%28588%29.png)

上面的系统调用会创建文件，并返回文件描述符给调用者。调用者也就是用户应用程序可以对文件描述符调用write，我们在之前已经看过很多次了，比如说像文件写入“abc”三个字符。

![](../.gitbook/assets/image%20%28587%29.png)

从这两个调用已经可以看出一些信息了：

* 首先出现在接口中的路径名是可读的名字，它不是一串数字，而是由用户选择的字符串。
* write系统调用并没有使用offset作为参数，所以写入到文件的哪个位置这个信息是隐藏的，文件系统在某个位置必然保存了文件的offset。因为如果你再调用write系统调用，后面的数据会从第4个字节开始写。

除此之外，还有一些我们之前没有看过的有趣的系统调用。例如XV6和所有的Unix文件系统都支持通过系统调用创建链接，给同一个文件指定多个名字。你可以通过调用link系统调用，为之前创建的文件“x/y”创建另一个名字“x/z”。

![](../.gitbook/assets/image%20%28593%29.png)

所以文件系统内部需要以某种方式跟踪了指向同一个文件的多个文件名。

我们还可能会在文件打开时，删除或者更新文件的命名空间。例如，用户可以通过unlink系统调用来删除特定的文件。这样我们相当于删除了一个之前打开的文件，对应的文件描述符还是打开的状态，那我们还是能向文件写数据，而这也能正常工作。

![](../.gitbook/assets/image%20%28590%29.png)

在文件系统内部，文件描述符必然与某个对象关联，而这个对象不依赖文件名。这样，即使文件名变化了，文件描述符仍然能够指向或者引用相同的文件对象。所以，实际上操作系统内部需要对于文件有内部的表现形式，并且这种表现形式与文件名无关。

除此之外，我还想提一点。文件系统的目的是实现我们这里描述的API，也即是典型的文件系统API。

![](../.gitbook/assets/image%20%28595%29.png)

当然，这并不是唯一构建一个存储系统的方式。如果只是在磁盘上存储数据，你可以想出一个完全不同的API。举个例子，数据库也能持久化的存储数据，但是数据库就提供了一个与文件系统完全不一样的API。所以记住这一点很重要：还有其他的方式能组织存储系统。我们这节课关注在文件系统，文件系统通常由操作系统提供。而数据库如果没有直接访问磁盘的权限的话，通常是在文件系统之上实现的（注，早期数据库通常直接基于磁盘构建自己的文件系统，因为早期操作系统自带的文件系统在性能上较差，且写入不是同步的，进而导致数据库的ACID不能保证。不过现代操作系统自带的文件系统已经足够好，所以现代的数据库大部分构建在操作系统自带的文件系统之上）。

> 学生提问：link增加了了对于文件的一个引用，unlink减少了一个引用？
>
> Frans教授：是的。我们稍后会介绍更多相关的内容。
>
> 学生提问：能介绍一下soft link和hard link吗？
>
> Frans教授：我今天不会讨论这些内容。但是你们将会在下一个File system lab中实现soft link。所以XV6本身实现了hard link，需要你们来实现soft link。
>
> 学生提问：link是对inode做操作，而不是对文件描述符做操作，对吧？
>
> Frans教授：是的，link是对inode做操作，我们接下来介绍这部分内容。

