# 17.4

接下来，我将介绍几个例子来看一下如何使用之前介绍的内容。我会从一个非常简单的例子开始，之后我们会看一下Garbage Collector，因为很多同学都问了Garbage Collector的问题，所以这是一个可以深入探讨的好话题。

首先我想讨论的是一个非常简单的想法，它甚至都没有在论文中提到。但是它却是展示应用程序通过前面提到的特性而获取到的能力非常酷的一个方法。这里是构建一个大的memorization table，什么是memorization table？它就是记录一些运算的结果。举个例子，你可以这么想，下面是我们的Table，它从0开始到n。Table记录的是运行一些费时的函数的结果，函数的参数就是0到n之间的数字。

![](../.gitbook/assets/image%20%28762%29.png)

如果这个Table在最开始的时候就预计算好了，当你想知道f\(i\)的结果是什么时，你需要做的就是查看Table的i槽位，并获取f\(i\)的值。这样你可以将一个费时的函数调用转变成查找Table。所以这里一个酷的技巧就是预先将费时的计算结果保存下来，如果相同的计算运行了很多很多次，那么预计算或许是一个聪明的方案。

![](../.gitbook/assets/image%20%28758%29.png)

这里的挑战是，Table可能会很大，或许会大过物理内存，但是如果有这么一个Table仍然是极好的。这里可以用来解决这个问题的一个方法是使用论文提到的虚拟内存特性。

首先，你需要分配一个大的虚拟地址段，但是并不分配任何物理内存到这个虚拟地址段。这里只是从地址空间获取了很大一段，并说我将要使用我在地址空间的这部分来保存Table。

