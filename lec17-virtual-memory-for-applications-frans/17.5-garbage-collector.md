# 17.5 Garbage Collector

接下来我会讨论另一个例子，也就是Garbage Collector（注，后面讲Garbage Collector和Garbage Collection都称为GC），并且我也收到了很多有关Garbage Collector的问题。

GC是指编程语言替程序员完成内存分配和内存释放。所以程序员就不用像在C语言中一样，调用malloc和free来申请和释放内存。拥有GC的编程语言，程序只需要调用类似malloc来申请内存，但是不需要担心释放内存。GC会决定内存是否还在使用，如果内存并没有被使用，那么GC会释放内存。这个特性很好，有哪些编程语言带有GC呢？Java，Python，Golang，几乎除了C和Rust，其他所有的编程语言都带有GC。

你可以想象，GC有很大的设计空间。这节课讨论的论文并没有说什么样的GC是最好的，只是展示了GC可以利用用户空间虚拟内存特性。论文讨论的特定GC，是一种copying GC（注，也可以查看[维基百科](https://en.wikipedia.org/wiki/Cheney%27s_algorithm#:~:text=Garbage%20collection%20is%20performed%20by,previous%20stop%20and%20copy%20technique.)的说明）。什么是copying GC？假设你有一段内存作为heap，应用程序从其中申请内存。你将这段内存分为两个部分，其中一部分是from，另一部分是to。当程序刚刚启动的时候，所有的内存都是空闲的，然后程序会从from部分申请内存。假设我们申请了一个类似树的数据结构。树的根节点中包含了一个指针指向另一个对象，这个对象和根节点都包含了一个指针指向第三个对象。这里构成了一个循环。

![](../.gitbook/assets/image%20%28791%29.png)

或许应用程序在内存中还有其他对象，但是没有别的指针指向这些对象，所以还在使用的对象可以从根节点访问到。在某个时间，或许因为之前申请了大量的内存，已经没有空间给新对象了，也就是说整个from部分都被使用了。

Copying GC的基本思想是将对象拷贝到to部分去。具体拷贝的流程是从根节点开始拷贝，每一个应用程序都有一系列的寄存器或者在stack上的变量用来保存最高层级的指针，通常来说会存在多个根节点，但是为了说明的简单，我们假设只有一个根节点。我们从最高层级的指针（也就是根节点）开始向下跟踪。所以最开始将根节点拷贝到了to部分。现在根节点中的指针还指向着之前的对象。

![](../.gitbook/assets/image%20%28781%29.png)

之后，GC会扫描根节点对象。程序的运行时知道对象的类型是什么，当然也就知道对象中的指针。接下来GC会将对象中指针指向的对象也拷贝到to部分，因为这些对象明显也是还在使用中的对象。当一个对象拷贝到to部分时，再更新根节点中的指针，指向拷贝到to部分的对象。

![](../.gitbook/assets/image%20%28765%29.png)

在之后的过程中，我们需要记住这个对象已经被拷贝过了。所以，我们还会存储一些额外的信息来记住相应的对象已经保存在了to部分。这里将对象从from部分拷贝到to部分，并在from部分留下了一个forwarding指针。

![](../.gitbook/assets/image%20%28766%29.png)

接下来还剩下一个对象，我们将这个对象从from部分拷贝到to部分。它还有一个指针指向第二个对象。

![](../.gitbook/assets/image%20%28758%29.png)

但是通过查看指针可以看到这个对象已经被拷贝了，并且我们已经知道了这个对象的拷贝的地址（注，也就是forwarding指针）。所以我们可以直接更新第三个对象的指针到正确的地址。

![](../.gitbook/assets/image%20%28788%29.png)

现在所有的指针都被正确的更新了，与根节点相关的对象都从from部分移到了to部分，所以现在我们就完成了GC，from部分的所有对象都可以被丢弃，并且from部分现在变成了空闲区域。

![](../.gitbook/assets/image%20%28761%29.png)

以上就是copying GC的基本思路。论文中使用的方法有一些复杂的地方，我们来看一下。

第一个复杂的地方，被称为Baker算法，这是一种很老的算法。它的一个优势是它是实时的，这意味着它是一种incremental GC（注，incremental GC是指GC并不是一次做完，而是分批分步骤完成）。在Baker算法中，我们还是有from和to两个部分。假设其中还是包含了上面介绍的几个对象。

![](../.gitbook/assets/image%20%28794%29.png)

这里的基本思想是，GC的过程没有必要停止程序的运行并将所有的对象都从from部分拷贝到to部分，然后再恢复程序的运行。这里唯一必要的事情，就是将根节点拷贝到to部分。所以现在根节点被拷贝了，但是根节点内的指针还是指向之前的对象，因为根节点还没有被扫描，其中的指针还没有被更新。

![](../.gitbook/assets/image%20%28774%29.png)

如果应用程序调用了new来申请内存，那就再扫描几个对象，并将这些对象从from部分forward到to部分。这很好，因为现在我们将拷贝整个heap中还在使用的对象的过程，拆分成了渐进的步骤。每一次调用new都为整个拷贝过程贡献了一点。

![](../.gitbook/assets/image%20%28772%29.png)

当然应用程序或许还在使用这里面的某些指针。举个例子，如果根节点不再指向其中的一个对象，这个对象仍然在from空间被指向。当然这是危险的，因为我们不应该跟踪from部分的指针。所以这意味着，每次解除一个指针的引用关系（dereference），你需要检查它是否在在from部分，如果是的话，将其从from部分forward到to部分。所以应用程序允许使用指针，但是编译器对每个指针的访问都会包上一层这样的检查，这样我们就可以保证在to部分的任何指针指向的是位于to部分的对象。我们需要确保这一点，因为在最后当我们完成了GC时，我们想清空from部分，这样我们可以重用这部分内存。

![](../.gitbook/assets/image%20%28779%29.png)

论文对于这里的方案提出了两个问题：

* 第一个是每次dereference都需要有以上的额外步骤，每次dereference不再是单个load或者store指令，而是多个load或者store指令，这增加了应用程序的开销。
* 第二个问题是并不能容易的将GC并行化。如果程序运行在多核CPU的机器上，并且你拥有大量的空闲CPU，我们可以将GC运行在后台来遍历对象的图，渐进的拷贝对象。但是如果应用程序也在使用对象的图，那么这里可能会有抢占。应用程序或许在运行dereference检查并拷贝一个对象，而同时GC也在拷贝这个对象。如果我们不够小心的话，我们可能会将对象拷贝两遍，最后指针指向的不是正确的位置。所以这里存在race condition的可能。

论文中介绍，如果拥有了前面提到的虚拟内存特性，你可以使用虚拟内存来减少检查的损耗，并且以几乎零成本的代价获得并发性。这里的基本思想是将heap内存中from和to部分，再做一次划分，每一个部分包含scanned，unscanned两块。在程序启动的时候，或者刚刚完成了from和to部分的切换，整个部分都是unscanned，因为其中还没有任何对象。

之后的方案与之前相同，我们将根节点对象拷贝到to部分，根节点中的指针还是指向了位于from部分的对象。之后，对于unscanned区域，现在包括了所有的对象（只有根节点），我们会将它映射成None。这意味着，在我们切换了from和to部分之后，应用程序第一次使用根节点指针，它会得到Page Fault，因为这部分地址空间还没有被映射。

![](../.gitbook/assets/image%20%28768%29.png)

在Page Fault Handler中，扫描一个内存Page的对象，然后将对象从from部分forward到to部分。所以，在刚刚的步骤中，我们将根节点拷贝过来了，并且通过扫描，将根节点指向的对象也拷贝过来了，在我们的例子中只有两个对象。这两个对象会被拷贝到unscanned区域中，而根节点会被标记成scanned。在我们扫描完一个对象，我们可以Unprot对应的内存Page。

![](../.gitbook/assets/image%20%28792%29.png)

之后，应用程序就可以访问特定的应用程序，因为我们将对象中的指针翻译成了可以安全暴露给应用程序，应用程序可以访问这些指针。当然这些指针对应的对象中还包含了未被扫描的指针。如果访问这些指针，我们会再次得到Page Fault，之后我们会继续扫描。

这里的好处是，它仍然是递增的GC，每次只需要做一小部分工作，我们仍然可以在调用new的之后执行一些GC。除此之外，它还有额外的优势，现在没有指针检查了。或者说指针检查还在，只是现在通过虚拟内存相关的硬件来完成了。

![](../.gitbook/assets/image%20%28760%29.png)

> 学生提问：刚刚说到在Handler里面会扫描一个Page的对象，但是你怎么知道需要forward的对象位于一个Page中？
>
> Frans教授：内存Page中会有一些对象。在最开始的时候，to部分是没有任何对象的。当需要forward的时候，我刚刚描述的是拷贝一个对象，但是实际上拷贝的是一个内存Page中的N个对象，这样它们可以填满整个Page。所以现在我们在to部分中，有N个对象位于一个Page中，并且它们都没有被扫描。之后某个时间，Page Fault Handler会被调用，GC会遍历这个内存Page上的N个对象，并检查它们的指针。对于这些指针，GC会将对应的对象拷贝到to部分的unscanned区域中。之后，当应用程序使用了这些未被扫描的对象，它会得到Page Fault，进而再扫描这些对象，以此类推。
>
> 学生提问：在完成了GC之后，会切换from和to部分吗？
>
> Frans教授：最开始我们使用的是from空间，当用完了的时候，你会将对象拷贝到to空间，一旦完成了扫描，from空间也被完全清空了，你可以切换两个空间的名字。现在会使用to空间来完成内存分配。直到它也满了，你会再次切换。

论文中提到使用虚拟内存的另一个好处是，它简化了GC的并发。GC现在可以遍历未被扫描的内存Page，并且一次扫描一个Page，同时可以确保应用程序不能访问这个内存Page，因为内存Page现在还没有映射。虚拟内存的硬件引入了这种显示的同步，或者说对于抢占的保护。因为现在只有GC可以反问这里的内存Page，应用程序不能访问。所以这里提供了自动的并发，应用程序可以运行并完成它的工作，GC也可以完成自己的工作，它们不会互相得罪，因为一旦应用程序访问了一个未被扫描的Page，它就会得到一个Page Fault。而GC也永远不会访问扫描过的Page，所以也永远不会干扰到应用程序。

所以这里以零成本获取到了并发性，但是实际上有个麻烦的问题。unscanned区域实际上并没有映射物理内存。回到我们之前那张图，我们在heap中有from空间，to空间。在to空间中又分为了unscanned和scanned区域，unscanned区域中的Page权限为None。

![](../.gitbook/assets/image%20%28775%29.png)

这就引出了另一个问题，GC怎么能访问这个区域的内存Page，因为这些Page应该是没有映射的，或者它们是inaccessible。这里的技巧是使用map2。这里我们会将同一个物理内存映射两次，第一次是我们之前介绍的方式，也就是为应用程序进行映射，第二次专门为GC映射。在GC的视角中，我们仍然有from和to空间。在to空间的unscanned区域中，Page具有读写权限。

![](../.gitbook/assets/image%20%28777%29.png)

所以GC可以遍历这些内存Page，并forward必要的对象。这里使用了map2将物理内存映射到应用程序中两次。每次都有不同的权限。这样这里的场景才能工作。

> 学生提问：GC和应用程序是不是有不同的Page Table？
>
> Frans教授：不，它们拥有相同的Page Table。它们只是将物理内存映射到了地址空间的两个位置，也即是Page Table的两个位置。在一个位置，PTE被标记成invalid，在另一个位置，PTE被标记成可读写的。

为了更清晰的说明，我这里有个针对论文中的方法的简单实现，我可以肯定它包含了一些bug，因为我并没有认真的测试它。

首先，应用程序使用的API包括了new和readptr。

![](../.gitbook/assets/image%20%28780%29.png)

readptr会检查指针是否位于from空间，如果是的话，那么它需要被拷贝。当然，当我们使用虚拟内存时，这里的readptr成本会比较低，它只需要返回参数即可。在这个简单的例子中，我有一个循环链表，并且有两个根节点，其中一个指向头节点，另一个指向尾节点。

应用程序线程的工作是执行1000次，每次创建list，再检查list。

![](../.gitbook/assets/image%20%28759%29.png)

所以它会产生大量的垃圾，因为每次make\_clist完成之后，再次make\_clist，上一个list就成为垃圾了。所以GC会有一些工作要做。

make\_clist的代码有点丑，主要是因为每个指针都需要被readptr检查包围。通常这里的检查是由编译器生成的。但是我这里并没有一个针对带GC编程语言的编译器，所以我在模仿一个编译器可能生成的内容。

![](../.gitbook/assets/image%20%28796%29.png)

make\_clist会构建一个LISTSZ大小的链表，分配新的元素，并将新元素加到链表的起始位置，之后更新链表尾指向链表新的起始位置，这样能构成一个循环链表。

这里更有趣的部分是，GC部分怎么实现。首先让我们看看如果没有虚拟内存会怎样。我们只需要查看两个API：new和readptr。

![](../.gitbook/assets/image%20%28767%29.png)

以上就是new的实现，先不考虑这里的mutex，因为这是为基于虚拟内存的实现提供的。先假设我们并需要扫描，也不需要collect。接下来会检查是否有足够的空间，如果有足够的空间，我们就将指针增加一些，来分配内存空间给对象。然后返回。

如果没有足够的空间，我们需要调用flip，也就是运行GC。

