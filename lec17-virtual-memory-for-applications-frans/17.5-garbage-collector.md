# 17.5 Garbage Collector

接下来我会讨论另一个例子，也就是Garbage Collector（注，后面讲Garbage Collector和Garbage Collection都称为GC），并且我也收到了很多有关Garbage Collector的问题。

GC是指编程语言替程序员完成内存分配和内存释放。所以程序员就不用像在C语言中一样，调用malloc和free来申请和释放内存。拥有GC的编程语言，程序只需要调用类似malloc来申请内存，但是不需要担心释放内存。GC会决定内存是否还在使用，如果内存并没有被使用，那么GC会释放内存。这个特性很好，有哪些编程语言带有GC呢？Java，Python，Golang，几乎除了C和Rust，其他所有的编程语言都带有GC。

你可以想象，GC有很大的设计空间。这节课讨论的论文并没有说什么样的GC是最好的，只是展示了GC可以利用用户空间虚拟内存特性。论文讨论的特定GC，是一种copying GC（注，也可以查看[维基百科](https://en.wikipedia.org/wiki/Cheney%27s_algorithm#:~:text=Garbage%20collection%20is%20performed%20by,previous%20stop%20and%20copy%20technique.)的说明）。什么是copying GC？假设你有一段内存作为heap，应用程序从其中申请内存。你将这段内存分为两个部分，其中一部分是from，另一部分是to。当程序刚刚启动的时候，所有的内存都是空闲的，然后程序会从from部分申请内存。假设我们申请了一个类似树的数据结构。树的根节点中包含了一个指针指向另一个对象，这个对象和根节点都包含了一个指针指向第三个对象。这里构成了一个循环。

![](../.gitbook/assets/image%20%28782%29.png)

或许应用程序在内存中还有其他对象，但是没有别的指针指向这些对象，所以还在使用的对象可以从根节点访问到。在某个时间，或许因为之前申请了大量的内存，已经没有空间给新对象了，也就是说整个from部分都被使用了。

Copying GC的基本思想是将对象拷贝到to部分去。具体拷贝的流程是从根节点开始拷贝，每一个应用程序都有一系列的寄存器或者在stack上的变量用来保存最高层级的指针，通常来说会存在多个根节点，但是为了说明的简单，我们假设只有一个根节点。我们从最高层级的指针（也就是根节点）开始向下跟踪。所以最开始将根节点拷贝到了to部分。现在根节点中的指针还指向着之前的对象。

![](../.gitbook/assets/image%20%28773%29.png)

之后，GC会扫描根节点对象。程序的运行时知道对象的类型是什么，当然也就知道对象中的指针。接下来GC会将对象中指针指向的对象也拷贝到to部分，因为这些对象明显也是还在使用中的对象。当一个对象拷贝到to部分时，再更新根节点中的指针，指向拷贝到to部分的对象。

![](../.gitbook/assets/image%20%28763%29.png)

在之后的过程中，我们需要记住这个对象已经被拷贝过了。所以，我们还会存储一些额外的信息来记住相应的对象已经保存在了to部分。这里将对象从from部分拷贝到to部分，并在from部分留下了一个forwarding指针。

![](../.gitbook/assets/image%20%28764%29.png)

接下来还剩下一个对象，我们将这个对象从from部分拷贝到to部分。它还有一个指针指向第二个对象。

![](../.gitbook/assets/image%20%28758%29.png)

但是通过查看指针可以看到这个对象已经被拷贝了，并且我们已经知道了这个对象的拷贝的地址（注，也就是forwarding指针）。所以我们可以直接更新第三个对象的指针到正确的地址。

![](../.gitbook/assets/image%20%28779%29.png)

现在所有的指针都被正确的更新了，与根节点相关的对象都从from部分移到了to部分，所以现在我们就完成了GC，from部分的所有对象都可以被丢弃，并且from部分现在变成了空闲区域。

![](../.gitbook/assets/image%20%28759%29.png)

以上就是copying GC的基本思路。论文中使用的方法有一些复杂的地方，我们来看一下。

第一个复杂的地方，被称为Baker算法，这是一种很老的算法。它的一个优势是它是实时的，这意味着它是一种incremental GC（注，incremental GC是指GC并不是一次做完，而是分批分步骤完成）。在Baker算法中，我们还是有from和to两个部分。假设其中还是包含了上面介绍的几个对象。

![](../.gitbook/assets/image%20%28784%29.png)

这里的基本思想是，GC的过程没有必要停止程序的运行并将所有的对象都从from部分拷贝到to部分，然后再恢复程序的运行。这里唯一必要的事情，就是将根节点拷贝到to部分。所以现在根节点被拷贝了，但是根节点内的指针还是指向之前的对象，因为根节点还没有被扫描，其中的指针还没有被更新。

![](../.gitbook/assets/image%20%28769%29.png)

如果应用程序调用了new来申请内存，那就再扫描几个对象，并将这些对象从from部分forward到to部分。这很好，因为现在我们将拷贝整个heap中还在使用的对象的过程，拆分成了渐进的步骤。每一次调用new都为整个拷贝过程贡献了一点。

![](../.gitbook/assets/image%20%28767%29.png)

当然应用程序或许还在使用这里面的某些指针。举个例子，如果根节点不再指向其中的一个对象，这个对象仍然在from空间被指向。当然这是危险的，因为我们不应该跟踪from部分的指针。所以这意味着，每次解除一个指针的引用关系（dereference），你需要检查它是否在在from部分，如果是的话，将其从from部分forward到to部分。所以应用程序允许使用指针，但是编译器对每个指针的访问都会包上一层这样的检查，这样我们就可以保证在to部分的任何指针指向的是位于to部分的对象。我们需要确保这一点，因为在最后当我们完成了GC时，我们想清空from部分，这样我们可以重用这部分内存。

![](../.gitbook/assets/image%20%28772%29.png)

论文对于这里的方案提出了两个问题：

* 第一个是每次dereference都需要有以上的额外步骤，每次dereference不再是单个load或者store指令，而是多个load或者store指令，这增加了应用程序的开销。
* 第二个问题是并不能容易的将GC并行化。如果程序运行在多核CPU的机器上，并且你拥有大量的空闲CPU，我们可以将GC运行在后台来遍历对象的图，渐进的拷贝对象。但是如果应用程序也在使用对象的图，那么这里可能会有抢占。应用程序或许在运行dereference检查并拷贝一个对象，而同时GC也在拷贝这个对象。如果我们不够小心的话，我们可能会将对象拷贝两遍，最后指针指向的不是正确的位置。所以这里存在race condition的可能。

论文中介绍，如果拥有了前面提到的虚拟内存特性，你可以使用虚拟内存来减少检查的损耗，并且以几乎零成本的代价获得并发性。这里的基本思想是将heap内存中from和to部分，再做一次划分，每一个部分包含scanned，unscanned。最初整个部分都是unscanned。

