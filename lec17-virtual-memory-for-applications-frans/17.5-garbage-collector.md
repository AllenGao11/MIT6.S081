# 17.5 Garbage Collector

接下来我会讨论另一个例子，也就是Garbage Collector（注，后面讲Garbage Collector和Garbage Collection都称为GC），并且我也收到了很多有关Garbage Collector的问题。

GC是指编程语言替程序员完成内存分配和内存释放。所以程序员就不用像在C语言中一样，调用malloc和free来申请和释放内存。拥有GC的编程语言，程序只需要调用类似malloc来申请内存，但是不需要担心释放内存。GC会决定内存是否还在使用，如果内存并没有被使用，那么GC会释放内存。这个特性很好，有哪些编程语言带有GC呢？Java，Python，Golang，几乎除了C和Rust，其他所有的编程语言都带有GC。

你可以想象，GC有很大的设计空间。这节课讨论的论文并没有说什么样的GC是最好的，只是展示了GC可以利用用户空间虚拟内存特性。论文讨论的特定GC，是一种copying GC（注，也可以查看[维基百科](https://en.wikipedia.org/wiki/Cheney%27s_algorithm#:~:text=Garbage%20collection%20is%20performed%20by,previous%20stop%20and%20copy%20technique.)的说明）。什么是copying GC？假设你有一段内存作为heap，应用程序从其中申请内存。你将这段内存分为两个部分，其中一部分是from，另一部分是to。当程序刚刚启动的时候，所有的内存都是空闲的，然后程序会从from部分申请内存。假设我们申请了一个类似树的数据结构。树的根节点中包含了一个指针指向另一个对象，这个对象和根节点都包含了一个指针指向第三个对象。这里构成了一个循环。

![](../.gitbook/assets/image%20%28799%29.png)

或许应用程序在内存中还有其他对象，但是没有别的指针指向这些对象，所以还在使用的对象可以从根节点访问到。在某个时间，或许因为之前申请了大量的内存，已经没有空间给新对象了，也就是说整个from部分都被使用了。

Copying GC的基本思想是将对象拷贝到to部分去。具体拷贝的流程是从根节点开始拷贝，每一个应用程序都有一系列的寄存器或者在stack上的变量用来保存最高层级的指针，通常来说会存在多个根节点，但是为了说明的简单，我们假设只有一个根节点。我们从最高层级的指针（也就是根节点）开始向下跟踪。所以最开始将根节点拷贝到了to部分。现在根节点中的指针还指向着之前的对象。

![](../.gitbook/assets/image%20%28784%29.png)

之后，GC会扫描根节点对象。程序的运行时知道对象的类型是什么，当然也就知道对象中的指针。接下来GC会将对象中指针指向的对象也拷贝到to部分，因为这些对象明显也是还在使用中的对象。当一个对象拷贝到to部分时，再更新根节点中的指针，指向拷贝到to部分的对象。

![](../.gitbook/assets/image%20%28765%29.png)

在之后的过程中，我们需要记住这个对象已经被拷贝过了。所以，我们还会存储一些额外的信息来记住相应的对象已经保存在了to部分。这里将对象从from部分拷贝到to部分，并在from部分留下了一个forwarding指针。

![](../.gitbook/assets/image%20%28766%29.png)

接下来还剩下一个对象，我们将这个对象从from部分拷贝到to部分。它还有一个指针指向第二个对象。

![](../.gitbook/assets/image%20%28758%29.png)

但是通过查看指针可以看到这个对象已经被拷贝了，并且我们已经知道了这个对象的拷贝的地址（注，也就是forwarding指针）。所以我们可以直接更新第三个对象的指针到正确的地址。

![](../.gitbook/assets/image%20%28793%29.png)

现在所有的指针都被正确的更新了，与根节点相关的对象都从from部分移到了to部分，所以现在我们就完成了GC，from部分的所有对象都可以被丢弃，并且from部分现在变成了空闲区域。

![](../.gitbook/assets/image%20%28761%29.png)

以上就是copying GC的基本思路。论文中使用的方法有一些复杂的地方，我们来看一下。

第一个复杂的地方，被称为Baker算法，这是一种很老的算法。它的一个优势是它是实时的，这意味着它是一种incremental GC（注，incremental GC是指GC并不是一次做完，而是分批分步骤完成）。在Baker算法中，我们还是有from和to两个部分。假设其中还是包含了上面介绍的几个对象。

![](../.gitbook/assets/image%20%28802%29.png)

这里的基本思想是，GC的过程没有必要停止程序的运行并将所有的对象都从from部分拷贝到to部分，然后再恢复程序的运行。这里唯一必要的事情，就是将根节点拷贝到to部分。所以现在根节点被拷贝了，但是根节点内的指针还是指向之前的对象，因为根节点还没有被扫描，其中的指针还没有被更新。

![](../.gitbook/assets/image%20%28776%29.png)

如果应用程序调用了new来申请内存，那就再扫描几个对象，并将这些对象从from部分forward到to部分。这很好，因为现在我们将拷贝整个heap中还在使用的对象的过程，拆分成了渐进的步骤。每一次调用new都为整个拷贝过程贡献了一点。

![](../.gitbook/assets/image%20%28773%29.png)

当然应用程序或许还在使用这里面的某些指针。举个例子，如果根节点不再指向其中的一个对象，这个对象仍然在from空间被指向。当然这是危险的，因为我们不应该跟踪from部分的指针。所以这意味着，每次解除一个指针的引用关系（dereference），你需要检查它是否在在from部分，如果是的话，将其从from部分forward到to部分。所以应用程序允许使用指针，但是编译器对每个指针的访问都会包上一层这样的检查，这样我们就可以保证在to部分的任何指针指向的是位于to部分的对象。我们需要确保这一点，因为在最后当我们完成了GC时，我们想清空from部分，这样我们可以重用这部分内存。

![](../.gitbook/assets/image%20%28782%29.png)

论文对于这里的方案提出了两个问题：

* 第一个是每次dereference都需要有以上的额外步骤，每次dereference不再是单个load或者store指令，而是多个load或者store指令，这增加了应用程序的开销。
* 第二个问题是并不能容易的将GC并行化。如果程序运行在多核CPU的机器上，并且你拥有大量的空闲CPU，我们可以将GC运行在后台来遍历对象的图，渐进的拷贝对象。但是如果应用程序也在使用对象的图，那么这里可能会有抢占。应用程序或许在运行dereference检查并拷贝一个对象，而同时GC也在拷贝这个对象。如果我们不够小心的话，我们可能会将对象拷贝两遍，最后指针指向的不是正确的位置。所以这里存在race condition的可能。

论文中介绍，如果拥有了前面提到的虚拟内存特性，你可以使用虚拟内存来减少检查的损耗，并且以几乎零成本的代价获得并发性。这里的基本思想是将heap内存中from和to部分，再做一次划分，每一个部分包含scanned，unscanned两块。在程序启动的时候，或者刚刚完成了from和to部分的切换，整个部分都是unscanned，因为其中还没有任何对象。

之后的方案与之前相同，我们将根节点对象拷贝到to部分，根节点中的指针还是指向了位于from部分的对象。之后，对于unscanned区域，现在包括了所有的对象（只有根节点），我们会将它映射成None。这意味着，在我们切换了from和to部分之后，应用程序第一次使用根节点指针，它会得到Page Fault，因为这部分地址空间还没有被映射。

![](../.gitbook/assets/image%20%28768%29.png)

在Page Fault Handler中，扫描一个内存Page的对象，然后将对象从from部分forward到to部分。所以，在刚刚的步骤中，我们将根节点拷贝过来了，并且通过扫描，将根节点指向的对象也拷贝过来了，在我们的例子中只有两个对象。这两个对象会被拷贝到unscanned区域中，而根节点会被标记成scanned。在我们扫描完一个对象，我们可以Unprot对应的内存Page。

![](../.gitbook/assets/image%20%28800%29.png)

之后，应用程序就可以访问特定的应用程序，因为我们将对象中的指针翻译成了可以安全暴露给应用程序，应用程序可以访问这些指针。当然这些指针对应的对象中还包含了未被扫描的指针。如果访问这些指针，我们会再次得到Page Fault，之后我们会继续扫描。

这里的好处是，它仍然是递增的GC，每次只需要做一小部分工作，我们仍然可以在调用new的之后执行一些GC。除此之外，它还有额外的优势，现在没有指针检查了。或者说指针检查还在，只是现在通过虚拟内存相关的硬件来完成了。

![](../.gitbook/assets/image%20%28760%29.png)

> 学生提问：刚刚说到在Handler里面会扫描一个Page的对象，但是你怎么知道需要forward的对象位于一个Page中？
>
> Frans教授：内存Page中会有一些对象。在最开始的时候，to部分是没有任何对象的。当需要forward的时候，我刚刚描述的是拷贝一个对象，但是实际上拷贝的是一个内存Page中的N个对象，这样它们可以填满整个Page。所以现在我们在to部分中，有N个对象位于一个Page中，并且它们都没有被扫描。之后某个时间，Page Fault Handler会被调用，GC会遍历这个内存Page上的N个对象，并检查它们的指针。对于这些指针，GC会将对应的对象拷贝到to部分的unscanned区域中。之后，当应用程序使用了这些未被扫描的对象，它会得到Page Fault，进而再扫描这些对象，以此类推。
>
> 学生提问：在完成了GC之后，会切换from和to部分吗？
>
> Frans教授：最开始我们使用的是from空间，当用完了的时候，你会将对象拷贝到to空间，一旦完成了扫描，from空间也被完全清空了，你可以切换两个空间的名字。现在会使用to空间来完成内存分配。直到它也满了，你会再次切换。

论文中提到使用虚拟内存的另一个好处是，它简化了GC的并发。GC现在可以遍历未被扫描的内存Page，并且一次扫描一个Page，同时可以确保应用程序不能访问这个内存Page，因为内存Page现在还没有映射。虚拟内存的硬件引入了这种显示的同步，或者说对于抢占的保护。因为现在只有GC可以反问这里的内存Page，应用程序不能访问。所以这里提供了自动的并发，应用程序可以运行并完成它的工作，GC也可以完成自己的工作，它们不会互相得罪，因为一旦应用程序访问了一个未被扫描的Page，它就会得到一个Page Fault。而GC也永远不会访问扫描过的Page，所以也永远不会干扰到应用程序。

所以这里以零成本获取到了并发性，但是实际上有个麻烦的问题。unscanned区域实际上并没有映射物理内存。回到我们之前那张图，我们在heap中有from空间，to空间。在to空间中又分为了unscanned和scanned区域，unscanned区域中的Page权限为None。

![](../.gitbook/assets/image%20%28777%29.png)

这就引出了另一个问题，GC怎么能访问这个区域的内存Page，因为这些Page应该是没有映射的，或者它们是inaccessible。这里的技巧是使用map2。这里我们会将同一个物理内存映射两次，第一次是我们之前介绍的方式，也就是为应用程序进行映射，第二次专门为GC映射。在GC的视角中，我们仍然有from和to空间。在to空间的unscanned区域中，Page具有读写权限。

![](../.gitbook/assets/image%20%28779%29.png)

所以GC可以遍历这些内存Page，并forward必要的对象。这里使用了map2将物理内存映射到应用程序中两次。每次都有不同的权限。这样这里的场景才能工作。

> 学生提问：GC和应用程序是不是有不同的Page Table？
>
> Frans教授：不，它们拥有相同的Page Table。它们只是将物理内存映射到了地址空间的两个位置，也即是Page Table的两个位置。在一个位置，PTE被标记成invalid，在另一个位置，PTE被标记成可读写的。

为了更清晰的说明，我这里有个针对论文中的方法的简单实现，我可以肯定它包含了一些bug，因为我并没有认真的测试它。

首先，应用程序使用的API包括了new和readptr。

![](../.gitbook/assets/image%20%28783%29.png)

readptr会检查指针是否位于from空间，如果是的话，那么它需要被拷贝。当然，当我们使用虚拟内存时，这里的readptr成本会比较低，它只需要返回参数即可。在这个简单的例子中，我有一个循环链表，并且有两个根节点，其中一个指向头节点，另一个指向尾节点。

应用程序线程的工作是执行1000次，每次创建list，再检查list。

![](../.gitbook/assets/image%20%28759%29.png)

所以它会产生大量的垃圾，因为每次make\_clist完成之后，再次make\_clist，上一个list就成为垃圾了。所以GC会有一些工作要做。

make\_clist的代码有点丑，主要是因为每个指针都需要被readptr检查包围。通常这里的检查是由编译器生成的。但是我这里并没有一个针对带GC编程语言的编译器，所以我在模仿一个编译器可能生成的内容。

![](../.gitbook/assets/image%20%28804%29.png)

make\_clist会构建一个LISTSZ大小的链表，分配新的元素，并将新元素加到链表的起始位置，之后更新链表尾指向链表新的起始位置，这样能构成一个循环链表。

这里更有趣的部分是，GC部分怎么实现。首先让我们看看如果没有虚拟内存会怎样。我们只需要查看两个API：new和readptr。

![](../.gitbook/assets/image%20%28767%29.png)

以上就是new的实现，先不考虑这里的mutex，因为这是为基于虚拟内存的实现提供的。先假设我们并需要扫描，也不需要collect。接下来会检查是否有足够的空间，如果有足够的空间，我们就将指针增加一些，来分配内存空间给对象。然后返回。

如果没有足够的空间，我们需要调用flip，也就是运行GC。

![](../.gitbook/assets/image%20%28797%29.png)

flip首先会切换from和to指针，之后将这个应用程序的两个根节点从from空间forward到to空间。接下来我们看一下forward函数。

![](../.gitbook/assets/image%20%28774%29.png)

这个函数会forward指针o指向的对象，首先检查o是不是在from空间，如果是的话，并且之前没有被拷贝过，那么就将它拷贝到to空间。如果之前拷贝过，那么就可以用to空间对象的指针代替对象指针，并将其返回。

![](../.gitbook/assets/image%20%28780%29.png)

对于readptr，如果我们没有使用虚拟内存。会对指针p做forward操作，forward操作的意思是如果对象在from空间，那么拷贝到to空间。所以这里会有耗时的检查。

接下来我们看一下如何使用虚拟内存对应的技巧。

![](../.gitbook/assets/image%20%28786%29.png)

首先是设置内存，通过[shm\_open](https://man7.org/linux/man-pages/man3/shm_open.3.html)创建一个Share-memory object，这是一个Linux/Uinx系统调用。Share-memory object表现的像是一个文件，但是它并不是一个文件，它位于内存，并没有磁盘文件与之相关，如果你愿意的话，可以认为它是一个位于内存的文件系统。

之后我们裁剪这个Shared-memory object到from和to空间的大小。

之后我们通过mmap先将其映射一次，以供mutator也就是实际的应用程序使用。再映射一次，以供GC使用。这里shm\_open，ftruncate，和两次mmap，等效于map2。

会过去看之前的代码，

![](../.gitbook/assets/image%20%28769%29.png)

readptr将不做任何事情，直接将参数返回。当然，如果我们使用这里的指针，我们会得到Page Fault。在Page Fault hanlder中，

![](../.gitbook/assets/image%20%28796%29.png)

如果对象之前就拷贝到了to空间，并且位于unscanned区域，那么我们会得到一个Page Fault，在handler中会运行scan函数。但是scan函数是以GC的地址段来运行的，所以它能工作。因为否则的话，应用程序或者mutator不能访问这些Page，这会产生Page Fault。一旦scan执行完成，handler中会将Page设置成对应用程序可访问的。

在flip函数中，

![](../.gitbook/assets/image%20%28797%29.png)

完成from和to空间的切换时，我们会通过mprotect将整个to空间对应用程序标记成不可访问的。之后GC将root\_head和root\_last移到to空间中，这样应用程序就不能访问这两个对象，任何时候应用程序访问这两个对象，都会导致一个Page Fault。在Page Fault handler中，GC可以将对象从from空间拷贝到to空间，之后再Unprot对应的Page。

在Page Fault handler中，先scan内存Page，再将内存Page标记成对应用程序可访问的这个步骤是至关重要的，因为如果你先将内存Page标记成应用程序可访问的，然后再扫描它，如果有多个应用程序线程，那么应用程序可能会查看到unscanned区域的对象。当然我们要禁止这一点，所以这里的代码是先扫描，再增加内存的访问权限，这样应用程序就可以访问这些内存Page。

接下来，我总结一下这节课的内容。有一个问题，你应该在这里使用虚拟内存吗？或者说这里的这些技巧值得吗？因为许多的GC并没有使用虚拟内存，而是通过编译器生成的代码来完成GC，以及各种其他的技巧来减少性能损耗。所以大部分场景都可以通过一些额外的指令来完成。这对于一个编译器，程序运行时，或者编程语言来说，并不是一个太糟糕的选择。因为编译器就可以完成这些操作。但是如果没有程序运行时或者编译器，那么这个过程可能会很痛苦。所以对于一些完全没有编译器参与的应用程序，例如checkpointing，shared-virtual memory，它们的确需要这里提到的虚拟内存特性。所以实际中，足够的应用程序开发人员发现了这些特性值得，所以今天的操作系统都支持了这些特性。

![](../.gitbook/assets/image%20%28794%29.png)

很多人问了这个问题，从91年（论文发表的年份）至今，虚拟内存系统发生了什么改变？其中一个改变是，大部分的Unix系统都支持了这些虚拟内存特性了，并且从91年至今有许多变化。或许很难想象，但是在虚拟内存系统中有持续的开发，所以如果你查看Linux的git log，你可以发现在内核的各个方面都有持续的开发，其中包括了对虚拟内存系统的持续开发。在过去有一些重大的改变，现在的Page Table是5级的，来处理非常大的地址；有地址空间标识符来处理TLB flush；大概一年前，一种叫做KPTI（kernel page table isolation）的功能被引入，它是针对Meltdown attack的功能。虚拟内存系统绝对不是一个静态的系统，几乎Linux内核的所有方向都不是静态的。几乎每两个月在内核的不同方向都会有大量的更新。所以每个子系统时不时的就会被重写。

![](../.gitbook/assets/image%20%28785%29.png)

> 学生提问：VMA中的连续地址是什么意思？
>
> Frans教授：这里是指连续的虚拟内存地址，比如说一个VMA表示1000-2000这段地址。如果你有另一端地址，2100-2200，那么它会有属于自己的VMA。所以每个VMA覆盖了一段连续的地址，中间不会有中断。你们将会在mmap lab中看到，这样的设计是更加的合理的。你们认为对于每个mmap系统调用，都会有一个VMA，如果地址没有重叠的话。
>
> 学生提问：在GC中的from和to空间，你会什么时候停止再开始？我认为GC可以一直运行，如果它是并发的。
>
> Frans教授：是的，基于虚拟内存的解决方案一个酷的地方在于，GC可以一直运行。它可以在没有unscanned对象时停止。
>
> 学生提问：但是你需要遍历所有在from空间的对象，你怎么知道已经遍历了所有的对象呢？ 
>
> Frans教授：你会从根节点开始扫描，整个对象图，在某个时间点，你不再添加新的对象了，因为所有的对象已经被拷贝过了。当你不再添加新的对象，你的unscanned区域就不再增长，如果它不再增长，那么你就遍历了所有的对象。

