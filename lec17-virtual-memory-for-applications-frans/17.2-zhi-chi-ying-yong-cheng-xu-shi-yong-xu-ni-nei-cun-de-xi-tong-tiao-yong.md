# 17.2 支持应用程序使用虚拟内存的系统调用

第一个或许也是最重要的一个，是一个叫做mmap的系统调用。它接收某个对象，并将其映射到调用者的地址空间中。举个例子，如果你想映射一个文件，那么你需要将文件描述符传递给mmap系统调用。mmap系统调用有许多令人眼花缭乱的参数：

* 第一个参数是一个你想映射到的特定地址，如果传入null表示不指定特定地址，这样的话内核会选择一个地址来完成映射，并从系统调用返回。
* 第二个参数是长度len。
* 第三个参数是Protection bit，例如读写R\|W。
* 第四个参数是map private，你需要指定如果你写了传入的对象，会发生什么。我们会跳过这一段。
* 第五个参数是传入的对象，在这里就是文件描述符。
* 第六个参数是offset。

![](../.gitbook/assets/image%20%28753%29.png)

通过上面的系统调用，将文件描述符指向的文件内容，增加offset之后的len长度，映射到特定的内存地址（如果指定了的话）。这使得你可以实现Memory Mapped File，你可以将文件的内容带到内存地址空间，进而只需要方便的通过普通的指针操作，而不用调用read/write系统调用，就可以将文件内容写回到磁盘中。所以这是一个方便的接口，可以用来操纵存储在文件中的数据结构。实际上，你们将会在下个lab实现基于文件的mmap，下个lab结合了XV6的文件系统和虚拟内存，进而实现mmap。

mmap还可以用作他途。除了可以映射文件之外，还可以用来映射匿名的内存（Anonymous Memory）。这是sbreak的替代方案，你可以向内核申请物理内存，然后映射到特定的虚拟内存地址。这是实现应用程序虚拟内存的核心系统调用之一，我们稍后会将它与之前提到的特性关联起来。

除此之外，还需要有一些系统调用来支持论文中讨论到的特性。

mprotect系统调用。当你将某个对象映射到了虚拟内存地址空间，你可以修改对应虚拟内存的权限，这样你就可以以特定的权限保护对象的一部分，或者整个对象。

![](../.gitbook/assets/image%20%28751%29.png)

举个例子，使用了mprotect之后，load指令还能执行，但是store指令将会变成Page Fault。类似的，如果你想要将地址空间的一段变成完成不可访问的，那么可以在mprotect中的权限参数传入None，那么任何访问该段地址空间，也就是从addr开始到addr+len结束，都会生成Page Fault。

